SCRIPT  /home/transpalette/.vim/bundle/SimpylFold/ftplugin/python/SimpylFold.vim
Sourced 1 time
Total time:   0.000101
 Self time:   0.000071

count  total (s)   self (s)
    1              0.000007 if exists('b:loaded_SimpylFold')
                                finish
                            endif
    1              0.000004 let b:loaded_SimpylFold = 1
                            
    1   0.000042   0.000012 call SimpylFold#BufferInit()
    1              0.000007 setlocal foldexpr=SimpylFold#FoldExpr(v:lnum)
    1              0.000003 setlocal foldmethod=expr
                            
    1              0.000003 augroup SimpylFold
    1              0.000015     autocmd TextChanged,InsertLeave <buffer> call SimpylFold#Recache()
    1              0.000001 augroup END
                            
    1              0.000004 if exists('g:SimpylFold_docstring_preview') && g:SimpylFold_docstring_preview
                                setlocal foldtext=foldtext()\ .\ SimpylFold#FoldText()
                            endif

SCRIPT  /home/transpalette/.vim/bundle/vim-flake8/ftplugin/python_flake8.vim
Sourced 1 time
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
                            "
                            " Python filetype plugin for running flake8
                            " Language:     Python (ft=python)
                            " Maintainer:   Vincent Driessen <vincent@3rdcloud.com>
                            " Version:      Vim 7 (may work with lower Vim versions, but not tested)
                            " URL:          http://github.com/nvie/vim-flake8
                            "
                            " Only do this when not done yet for this buffer
    1              0.000005 if exists("b:loaded_flake8_ftplugin")
                                finish
                            endif
    1              0.000003 let b:loaded_flake8_ftplugin=1
                            
    1              0.000008 let s:save_cpo = &cpo
    1              0.000008 set cpo&vim
                            
                            "" Highlight groups for errors
                            " pep8 errors
    1              0.000012 highlight default Flake8_Error
                                        \ ctermbg=DarkRed ctermfg=Red cterm=bold
                                        \ guibg=DarkRed   guifg=Red   gui=bold
                            " pep8 warnings
    1              0.000005 highlight default Flake8_Warning
                                        \ ctermbg=Yellow ctermfg=DarkYellow cterm=bold
                                        \ guibg=Yellow   guifg=DarkYellow   gui=bold
                            " PyFlakes codes
    1              0.000004 highlight default Flake8_PyFlake
                                        \ ctermbg=DarkBlue ctermfg=Blue cterm=bold
                                        \ guibg=DarkBlue   guifg=Blue   gui=bold
                            " McCabe complexity warnings
    1              0.000004 highlight default Flake8_Complexity
                                        \ ctermbg=DarkBlue ctermfg=Blue cterm=bold
                                        \ guibg=DarkBlue   guifg=Blue   gui=bold
                            " naming conventions
    1              0.000004 highlight default Flake8_Naming
                                        \ ctermbg=DarkBlue ctermfg=Blue cterm=bold
                                        \ guibg=DarkBlue   guifg=Blue   gui=bold
                            
                            " to not break with old versions
    1              0.000003 function! Flake8()
                                call flake8#Flake8()
                            endfunction
                            
                            " Add mappings, unless the user didn't want this.
                            " The default mapping is registered under to <F7> by default, unless the user
                            " remapped it already (or a mapping exists already for <F7>)
    1              0.000005 if !exists("no_plugin_maps") && !exists("no_flake8_maps")
    1              0.000032     if !hasmapto('Flake8(') && !hasmapto('flake8#Flake8(')
    1              0.000015         noremap <buffer> <F7> :call flake8#Flake8()<CR>
    1              0.000001     endif
    1              0.000001 endif
                            
    1              0.000008 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            

SCRIPT  /usr/share/vim/vim80/ftplugin/python.vim
Sourced 1 time
Total time:   0.000651
 Self time:   0.000651

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	python
                            " Maintainer:	Tom Picton <tom@tompicton.co.uk>
                            " Previous Maintainer: James Sully <sullyj3@gmail.com>
                            " Previous Maintainer: Johannes Zellner <johannes@zellner.org>
                            " Last Change:	Wed, 20 December 2017
                            " https://github.com/tpict/vim-ftplugin-python
                            
    1              0.000007 if exists("b:did_ftplugin") | finish | endif
    1              0.000003 let b:did_ftplugin = 1
    1              0.000006 let s:keepcpo= &cpo
    1              0.000006 set cpo&vim
                            
    1              0.000003 setlocal cinkeys-=0#
    1              0.000003 setlocal indentkeys-=0#
    1              0.000003 setlocal include=^\\s*\\(from\\\|import\\)
    1              0.000003 setlocal includeexpr=substitute(v:fname,'\\.','/','g')
    1              0.000002 setlocal suffixesadd=.py
    1              0.000004 setlocal comments=b:#,fb:-
    1              0.000002 setlocal commentstring=#\ %s
                            
    1              0.000002 setlocal omnifunc=pythoncomplete#Complete
    1              0.000014 if has('python3')
    1              0.000003        setlocal omnifunc=python3complete#Complete
    1              0.000001 endif
                            
    1              0.000011 set wildignore+=*.pyc
                            
    1              0.000003 let b:next_toplevel='\v%$\|^(class\|def\|async def)>'
    1              0.000003 let b:prev_toplevel='\v^(class\|def\|async def)>'
    1              0.000002 let b:next_endtoplevel='\v%$\|\S.*\n+(def\|class)'
    1              0.000002 let b:prev_endtoplevel='\v\S.*\n+(def\|class)'
    1              0.000003 let b:next='\v%$\|^\s*(class\|def\|async def)>'
    1              0.000002 let b:prev='\v^\s*(class\|def\|async def)>'
    1              0.000003 let b:next_end='\v\S\n*(%$\|^(\s*\n*)*(class\|def\|async def)\|^\S)'
    1              0.000003 let b:prev_end='\v\S\n*(^(\s*\n*)*(class\|def\|async def)\|^\S)'
                            
    1              0.000029 execute "nnoremap <silent> <buffer> ]] :call <SID>Python_jump('n', '". b:next_toplevel."', 'W')<cr>"
    1              0.000020 execute "nnoremap <silent> <buffer> [[ :call <SID>Python_jump('n', '". b:prev_toplevel."', 'Wb')<cr>"
    1              0.000018 execute "nnoremap <silent> <buffer> ][ :call <SID>Python_jump('n', '". b:next_endtoplevel."', 'W', 0)<cr>"
    1              0.000016 execute "nnoremap <silent> <buffer> [] :call <SID>Python_jump('n', '". b:prev_endtoplevel."', 'Wb', 0)<cr>"
    1              0.000019 execute "nnoremap <silent> <buffer> ]m :call <SID>Python_jump('n', '". b:next."', 'W')<cr>"
    1              0.000017 execute "nnoremap <silent> <buffer> [m :call <SID>Python_jump('n', '". b:prev."', 'Wb')<cr>"
    1              0.000022 execute "nnoremap <silent> <buffer> ]M :call <SID>Python_jump('n', '". b:next_end."', 'W', 0)<cr>"
    1              0.000019 execute "nnoremap <silent> <buffer> [M :call <SID>Python_jump('n', '". b:prev_end."', 'Wb', 0)<cr>"
                            
    1              0.000020 execute "onoremap <silent> <buffer> ]] :call <SID>Python_jump('o', '". b:next_toplevel."', 'W')<cr>"
    1              0.000017 execute "onoremap <silent> <buffer> [[ :call <SID>Python_jump('o', '". b:prev_toplevel."', 'Wb')<cr>"
    1              0.000018 execute "onoremap <silent> <buffer> ][ :call <SID>Python_jump('o', '". b:next_endtoplevel."', 'W', 0)<cr>"
    1              0.000016 execute "onoremap <silent> <buffer> [] :call <SID>Python_jump('o', '". b:prev_endtoplevel."', 'Wb', 0)<cr>"
    1              0.000026 execute "onoremap <silent> <buffer> ]m :call <SID>Python_jump('o', '". b:next."', 'W')<cr>"
    1              0.000016 execute "onoremap <silent> <buffer> [m :call <SID>Python_jump('o', '". b:prev."', 'Wb')<cr>"
    1              0.000019 execute "onoremap <silent> <buffer> ]M :call <SID>Python_jump('o', '". b:next_end."', 'W', 0)<cr>"
    1              0.000019 execute "onoremap <silent> <buffer> [M :call <SID>Python_jump('o', '". b:prev_end."', 'Wb', 0)<cr>"
                            
    1              0.000018 execute "xnoremap <silent> <buffer> ]] :call <SID>Python_jump('x', '". b:next_toplevel."', 'W')<cr>"
    1              0.000017 execute "xnoremap <silent> <buffer> [[ :call <SID>Python_jump('x', '". b:prev_toplevel."', 'Wb')<cr>"
    1              0.000016 execute "xnoremap <silent> <buffer> ][ :call <SID>Python_jump('x', '". b:next_endtoplevel."', 'W', 0)<cr>"
    1              0.000015 execute "xnoremap <silent> <buffer> [] :call <SID>Python_jump('x', '". b:prev_endtoplevel."', 'Wb', 0)<cr>"
    1              0.000018 execute "xnoremap <silent> <buffer> ]m :call <SID>Python_jump('x', '". b:next."', 'W')<cr>"
    1              0.000016 execute "xnoremap <silent> <buffer> [m :call <SID>Python_jump('x', '". b:prev."', 'Wb')<cr>"
    1              0.000019 execute "xnoremap <silent> <buffer> ]M :call <SID>Python_jump('x', '". b:next_end."', 'W', 0)<cr>"
    1              0.000019 execute "xnoremap <silent> <buffer> [M :call <SID>Python_jump('x', '". b:prev_end."', 'Wb', 0)<cr>"
                            
    1              0.000005 if !exists('*<SID>Python_jump')
                              fun! <SID>Python_jump(mode, motion, flags, ...) range
                                  let l:startofline = (a:0 >= 1) ? a:1 : 1
                            
                                  if a:mode == 'x'
                                      normal! gv
                                  endif
                            
                                  if l:startofline == 1
                                      normal! 0
                                  endif
                            
                                  let cnt = v:count1
                                  mark '
                                  while cnt > 0
                                      call search(a:motion, a:flags)
                                      let cnt = cnt - 1
                                  endwhile
                            
                                  if l:startofline == 1
                                      normal! ^
                                  endif
                              endfun
                            endif
                            
    1              0.000006 if has("browsefilter") && !exists("b:browsefilter")
    1              0.000005     let b:browsefilter = "Python Files (*.py)\t*.py\n" .
                                            \ "All Files (*.*)\t*.*\n"
    1              0.000001 endif
                            
    1              0.000004 if !exists("g:python_recommended_style") || g:python_recommended_style != 0
                                " As suggested by PEP8.
    1              0.000013     setlocal expandtab shiftwidth=4 softtabstop=4 tabstop=8
    1              0.000001 endif
                            
                            " First time: try finding "pydoc".
    1              0.000003 if !exists('g:pydoc_executable')
                                if executable('pydoc')
                                    let g:pydoc_executable = 1
                                else
                                    let g:pydoc_executable = 0
                                endif
                            endif
                            " If "pydoc" was found use it for keywordprg.
    1              0.000001 if g:pydoc_executable
    1              0.000004     setlocal keywordprg=pydoc
    1              0.000001 endif
                            
    1              0.000008 let &cpo = s:keepcpo
    1              0.000004 unlet s:keepcpo

SCRIPT  /home/transpalette/.vim/bundle/indentpython.vim/indent/python.vim
Sourced 1 time
Total time:   0.000206
 Self time:   0.000206

count  total (s)   self (s)
                            " Python indent file
                            " Language:	    Python
                            " Maintainer:	    Eric Mc Sween <em@tomcom.de>
                            " Original Author:  David Bustos <bustos@caltech.edu> 
                            " Last Change:      2004 Jun 07
                            
                            " Only load this indent file when no other was loaded.
    1              0.000008 if exists("b:did_indent")
                                finish
                            endif
    1              0.000003 let b:did_indent = 1
                            
    1              0.000008 setlocal expandtab
    1              0.000011 setlocal nolisp
    1              0.000002 setlocal autoindent
    1              0.000004 setlocal indentexpr=GetPythonIndent(v:lnum)
    1              0.000003 setlocal indentkeys=!^F,o,O,<:>,0),0],0},=elif,=except
                            
    1              0.000005 let s:maxoff = 50
                            
                            " Find backwards the closest open parenthesis/bracket/brace.
    1              0.000004 function! s:SearchParensPair()
                                let line = line('.')
                                let col = col('.')
                                
                                " Skip strings and comments and don't look too far
                                let skip = "line('.') < " . (line - s:maxoff) . " ? dummy :" .
                                            \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? ' .
                                            \ '"string\\|comment"'
                            
                                " Search for parentheses
                                call cursor(line, col)
                                let parlnum = searchpair('(', '', ')', 'bW', skip)
                                let parcol = col('.')
                            
                                " Search for brackets
                                call cursor(line, col)
                                let par2lnum = searchpair('\[', '', '\]', 'bW', skip)
                                let par2col = col('.')
                            
                                " Search for braces
                                call cursor(line, col)
                                let par3lnum = searchpair('{', '', '}', 'bW', skip)
                                let par3col = col('.')
                            
                                " Get the closest match
                                if par2lnum > parlnum || (par2lnum == parlnum && par2col > parcol)
                                    let parlnum = par2lnum
                                    let parcol = par2col
                                endif
                                if par3lnum > parlnum || (par3lnum == parlnum && par3col > parcol)
                                    let parlnum = par3lnum
                                    let parcol = par3col
                                endif 
                            
                                " Put the cursor on the match
                                if parlnum > 0
                                    call cursor(parlnum, parcol)
                                endif
                                return parlnum
                            endfunction
                            
                            " Find the start of a multi-line statement
    1              0.000002 function! s:StatementStart(lnum)
                                let lnum = a:lnum
                                while 1
                                    if getline(lnum - 1) =~ '\\$'
                                        let lnum = lnum - 1
                                    else
                                        call cursor(lnum, 1)
                                        let maybe_lnum = s:SearchParensPair()
                                        if maybe_lnum < 1
                                            return lnum
                                        else
                                            let lnum = maybe_lnum
                                        endif
                                    endif
                                endwhile
                            endfunction
                            
                            " Find the block starter that matches the current line
    1              0.000002 function! s:BlockStarter(lnum, block_start_re)
                                let lnum = a:lnum
                                let maxindent = 10000       " whatever
                                while lnum > 1
                                    let lnum = prevnonblank(lnum - 1)
                                    if indent(lnum) < maxindent
                                        if getline(lnum) =~ a:block_start_re
                                            return lnum
                                        else 
                                            let maxindent = indent(lnum)
                                            " It's not worth going further if we reached the top level
                                            if maxindent == 0
                                                return -1
                                            endif
                                        endif
                                    endif
                                endwhile
                                return -1
                            endfunction
                                            
    1              0.000001 function! GetPythonIndent(lnum)
                            
                                " First line has indent 0
                                if a:lnum == 1
                                    return 0
                                endif
                                
                                " If we can find an open parenthesis/bracket/brace, line up with it.
                                call cursor(a:lnum, 1)
                                let parlnum = s:SearchParensPair()
                                if parlnum > 0
                                    let parcol = col('.')
                                    let closing_paren = match(getline(a:lnum), '^\s*[])}]') != -1
                                    if match(getline(parlnum), '[([{]\s*$', parcol - 1) != -1
                                        if closing_paren
                                            return indent(parlnum)
                                        else
                                            return indent(parlnum) + &shiftwidth
                                        endif
                                    else
                                        if closing_paren
                                            return parcol - 1
                                        else
                                            return parcol
                                        endif
                                    endif
                                endif
                                
                                " Examine this line
                                let thisline = getline(a:lnum)
                                let thisindent = indent(a:lnum)
                            
                                " If the line starts with 'elif' or 'else', line up with 'if' or 'elif'
                                if thisline =~ '^\s*\(elif\|else\)\>'
                                    let bslnum = s:BlockStarter(a:lnum, '^\s*\(if\|elif\)\>')
                                    if bslnum > 0
                                        return indent(bslnum)
                                    else
                                        return -1
                                    endif
                                endif
                                    
                                " If the line starts with 'except' or 'finally', line up with 'try'
                                " or 'except'
                                if thisline =~ '^\s*\(except\|finally\)\>'
                                    let bslnum = s:BlockStarter(a:lnum, '^\s*\(try\|except\)\>')
                                    if bslnum > 0
                                        return indent(bslnum)
                                    else
                                        return -1
                                    endif
                                endif
                                
                                " Examine previous line
                                let plnum = a:lnum - 1
                                let pline = getline(plnum)
                                let sslnum = s:StatementStart(plnum)
                                
                                " If the previous line is blank, keep the same indentation
                                if pline =~ '^\s*$'
                                    return -1
                                endif
                                
                                " If this line is explicitly joined, try to find an indentation that looks
                                " good. 
                                if pline =~ '\\$'
                                    let compound_statement = '^\s*\(if\|while\|for\s.*\sin\|except\)\s*'
                                    let maybe_indent = matchend(getline(sslnum), compound_statement)
                                    if maybe_indent != -1
                                        return maybe_indent
                                    else
                                        return indent(sslnum) + &sw * 2
                                    endif
                                endif
                                
                                " If the previous line ended with a colon, indent relative to
                                " statement start.
                                if pline =~ ':\s*$'
                                    return indent(sslnum) + &sw
                                endif
                            
                                " If the previous line was a stop-execution statement or a pass
                                if getline(sslnum) =~ '^\s*\(break\|continue\|raise\|return\|pass\)\>'
                                    " See if the user has already dedented
                                    if indent(a:lnum) > indent(sslnum) - &sw
                                        " If not, recommend one dedent
                                        return indent(sslnum) - &sw
                                    endif
                                    " Otherwise, trust the user
                                    return -1
                                endif
                            
                                " In all other cases, line up with the start of the previous statement.
                                return indent(sslnum)
                            endfunction

SCRIPT  /usr/share/vim/vim80/indent/python.vim
Sourced 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
                            " Vim indent file
                            " Language:		Python
                            " Maintainer:		Bram Moolenaar <Bram@vim.org>
                            " Original Author:	David Bustos <bustos@caltech.edu>
                            " Last Change:		2013 Jul 9
                            
                            " Only load this indent file when no other was loaded.
    1              0.000005 if exists("b:did_indent")
    1              0.000002   finish
                            endif
                            let b:did_indent = 1
                            
                            " Some preliminary settings
                            setlocal nolisp		" Make sure lisp indenting doesn't supersede us
                            setlocal autoindent	" indentexpr isn't much help otherwise
                            
                            setlocal indentexpr=GetPythonIndent(v:lnum)
                            setlocal indentkeys+=<:>,=elif,=except
                            
                            " Only define the function once.
                            if exists("*GetPythonIndent")
                              finish
                            endif
                            let s:keepcpo= &cpo
                            set cpo&vim
                            
                            " Come here when loading the script the first time.
                            
                            let s:maxoff = 50	" maximum number of lines to look backwards for ()
                            
                            function GetPythonIndent(lnum)
                            
                              " If this line is explicitly joined: If the previous line was also joined,
                              " line it up with that one, otherwise add two 'shiftwidth'
                              if getline(a:lnum - 1) =~ '\\$'
                                if a:lnum > 1 && getline(a:lnum - 2) =~ '\\$'
                                  return indent(a:lnum - 1)
                                endif
                                return indent(a:lnum - 1) + (exists("g:pyindent_continue") ? eval(g:pyindent_continue) : (shiftwidth() * 2))
                              endif
                            
                              " If the start of the line is in a string don't change the indent.
                              if has('syntax_items')
                            	\ && synIDattr(synID(a:lnum, 1, 1), "name") =~ "String$"
                                return -1
                              endif
                            
                              " Search backwards for the previous non-empty line.
                              let plnum = prevnonblank(v:lnum - 1)
                            
                              if plnum == 0
                                " This is the first non-empty line, use zero indent.
                                return 0
                              endif
                            
                              " If the previous line is inside parenthesis, use the indent of the starting
                              " line.
                              " Trick: use the non-existing "dummy" variable to break out of the loop when
                              " going too far back.
                              call cursor(plnum, 1)
                              let parlnum = searchpair('(\|{\|\[', '', ')\|}\|\]', 'nbW',
                            	  \ "line('.') < " . (plnum - s:maxoff) . " ? dummy :"
                            	  \ . " synIDattr(synID(line('.'), col('.'), 1), 'name')"
                            	  \ . " =~ '\\(Comment\\|Todo\\|String\\)$'")
                              if parlnum > 0
                                let plindent = indent(parlnum)
                                let plnumstart = parlnum
                              else
                                let plindent = indent(plnum)
                                let plnumstart = plnum
                              endif
                            
                            
                              " When inside parenthesis: If at the first line below the parenthesis add
                              " two 'shiftwidth', otherwise same as previous line.
                              " i = (a
                              "       + b
                              "       + c)
                              call cursor(a:lnum, 1)
                              let p = searchpair('(\|{\|\[', '', ')\|}\|\]', 'bW',
                            	  \ "line('.') < " . (a:lnum - s:maxoff) . " ? dummy :"
                            	  \ . " synIDattr(synID(line('.'), col('.'), 1), 'name')"
                            	  \ . " =~ '\\(Comment\\|Todo\\|String\\)$'")
                              if p > 0
                                if p == plnum
                                  " When the start is inside parenthesis, only indent one 'shiftwidth'.
                                  let pp = searchpair('(\|{\|\[', '', ')\|}\|\]', 'bW',
                            	  \ "line('.') < " . (a:lnum - s:maxoff) . " ? dummy :"
                            	  \ . " synIDattr(synID(line('.'), col('.'), 1), 'name')"
                            	  \ . " =~ '\\(Comment\\|Todo\\|String\\)$'")
                                  if pp > 0
                            	return indent(plnum) + (exists("g:pyindent_nested_paren") ? eval(g:pyindent_nested_paren) : shiftwidth())
                                  endif
                                  return indent(plnum) + (exists("g:pyindent_open_paren") ? eval(g:pyindent_open_paren) : (shiftwidth() * 2))
                                endif
                                if plnumstart == p
                                  return indent(plnum)
                                endif
                                return plindent
                              endif
                            
                            
                              " Get the line and remove a trailing comment.
                              " Use syntax highlighting attributes when possible.
                              let pline = getline(plnum)
                              let pline_len = strlen(pline)
                              if has('syntax_items')
                                " If the last character in the line is a comment, do a binary search for
                                " the start of the comment.  synID() is slow, a linear search would take
                                " too long on a long line.
                                if synIDattr(synID(plnum, pline_len, 1), "name") =~ "\\(Comment\\|Todo\\)$"
                                  let min = 1
                                  let max = pline_len
                                  while min < max
                            	let col = (min + max) / 2
                            	if synIDattr(synID(plnum, col, 1), "name") =~ "\\(Comment\\|Todo\\)$"
                            	  let max = col
                            	else
                            	  let min = col + 1
                            	endif
                                  endwhile
                                  let pline = strpart(pline, 0, min - 1)
                                endif
                              else
                                let col = 0
                                while col < pline_len
                                  if pline[col] == '#'
                            	let pline = strpart(pline, 0, col)
                            	break
                                  endif
                                  let col = col + 1
                                endwhile
                              endif
                            
                              " If the previous line ended with a colon, indent this line
                              if pline =~ ':\s*$'
                                return plindent + shiftwidth()
                              endif
                            
                              " If the previous line was a stop-execution statement...
                              if getline(plnum) =~ '^\s*\(break\|continue\|raise\|return\|pass\)\>'
                                " See if the user has already dedented
                                if indent(a:lnum) > indent(plnum) - shiftwidth()
                                  " If not, recommend one dedent
                                  return indent(plnum) - shiftwidth()
                                endif
                                " Otherwise, trust the user
                                return -1
                              endif
                            
                              " If the current line begins with a keyword that lines up with "try"
                              if getline(a:lnum) =~ '^\s*\(except\|finally\)\>'
                                let lnum = a:lnum - 1
                                while lnum >= 1
                                  if getline(lnum) =~ '^\s*\(try\|except\)\>'
                            	let ind = indent(lnum)
                            	if ind >= indent(a:lnum)
                            	  return -1	" indent is already less than this
                            	endif
                            	return ind	" line up with previous try or except
                                  endif
                                  let lnum = lnum - 1
                                endwhile
                                return -1		" no matching "try"!
                              endif
                            
                              " If the current line begins with a header keyword, dedent
                              if getline(a:lnum) =~ '^\s*\(elif\|else\)\>'
                            
                                " Unless the previous line was a one-liner
                                if getline(plnumstart) =~ '^\s*\(for\|if\|try\)\>'
                                  return plindent
                                endif
                            
                                " Or the user has already dedented
                                if indent(a:lnum) <= plindent - shiftwidth()
                                  return -1
                                endif
                            
                                return plindent - shiftwidth()
                              endif
                            
                              " When after a () construct we probably want to go back to the start line.
                              " a = (b
                              "       + c)
                              " here
                              if parlnum > 0
                                return plindent
                              endif
                            
                              return -1
                            
                            endfunction
                            
                            let &cpo = s:keepcpo
                            unlet s:keepcpo
                            
                            " vim:sw=2

SCRIPT  /usr/share/vim/vim80/syntax/python.vim
Sourced 1 time
Total time:   0.001044
 Self time:   0.001044

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Python
                            " Maintainer:	Zvezdan Petkovic <zpetkovic@acm.org>
                            " Last Change:	2016 Oct 29
                            " Credits:	Neil Schemenauer <nas@python.ca>
                            "		Dmitry Vasiliev
                            "
                            "		This version is a major rewrite by Zvezdan Petkovic.
                            "
                            "		- introduced highlighting of doctests
                            "		- updated keywords, built-ins, and exceptions
                            "		- corrected regular expressions for
                            "
                            "		  * functions
                            "		  * decorators
                            "		  * strings
                            "		  * escapes
                            "		  * numbers
                            "		  * space error
                            "
                            "		- corrected synchronization
                            "		- more highlighting is ON by default, except
                            "		- space error highlighting is OFF by default
                            "
                            " Optional highlighting can be controlled using these variables.
                            "
                            "   let python_no_builtin_highlight = 1
                            "   let python_no_doctest_code_highlight = 1
                            "   let python_no_doctest_highlight = 1
                            "   let python_no_exception_highlight = 1
                            "   let python_no_number_highlight = 1
                            "   let python_space_error_highlight = 1
                            "
                            " All the options above can be switched on together.
                            "
                            "   let python_highlight_all = 1
                            "
                            
                            " quit when a syntax file was already loaded.
    1              0.000004 if exists("b:current_syntax")
                              finish
                            endif
                            
                            " We need nocompatible mode in order to continue lines with backslashes.
                            " Original setting will be restored.
    1              0.000007 let s:cpo_save = &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000003 if exists("python_no_doctest_highlight")
                              let python_no_doctest_code_highlight = 1
                            endif
                            
    1              0.000003 if exists("python_highlight_all")
                              if exists("python_no_builtin_highlight")
                                unlet python_no_builtin_highlight
                              endif
                              if exists("python_no_doctest_code_highlight")
                                unlet python_no_doctest_code_highlight
                              endif
                              if exists("python_no_doctest_highlight")
                                unlet python_no_doctest_highlight
                              endif
                              if exists("python_no_exception_highlight")
                                unlet python_no_exception_highlight
                              endif
                              if exists("python_no_number_highlight")
                                unlet python_no_number_highlight
                              endif
                              let python_space_error_highlight = 1
                            endif
                            
                            " Keep Python keywords in alphabetical order inside groups for easy
                            " comparison with the table in the 'Python Language Reference'
                            " https://docs.python.org/2/reference/lexical_analysis.html#keywords,
                            " https://docs.python.org/3/reference/lexical_analysis.html#keywords.
                            " Groups are in the order presented in NAMING CONVENTIONS in syntax.txt.
                            " Exceptions come last at the end of each group (class and def below).
                            "
                            " Keywords 'with' and 'as' are new in Python 2.6
                            " (use 'from __future__ import with_statement' in Python 2.5).
                            "
                            " Some compromises had to be made to support both Python 3 and 2.
                            " We include Python 3 features, but when a definition is duplicated,
                            " the last definition takes precedence.
                            "
                            " - 'False', 'None', and 'True' are keywords in Python 3 but they are
                            "   built-ins in 2 and will be highlighted as built-ins below.
                            " - 'exec' is a built-in in Python 3 and will be highlighted as
                            "   built-in below.
                            " - 'nonlocal' is a keyword in Python 3 and will be highlighted.
                            " - 'print' is a built-in in Python 3 and will be highlighted as
                            "   built-in below (use 'from __future__ import print_function' in 2)
                            " - async and await were added in Python 3.5 and are soft keywords.
                            "
    1              0.000013 syn keyword pythonStatement	False None True
    1              0.000005 syn keyword pythonStatement	as assert break continue del exec global
    1              0.000005 syn keyword pythonStatement	lambda nonlocal pass print return with yield
    1              0.000014 syn keyword pythonStatement	class def nextgroup=pythonFunction skipwhite
    1              0.000004 syn keyword pythonConditional	elif else if
    1              0.000003 syn keyword pythonRepeat	for while
    1              0.000005 syn keyword pythonOperator	and in is not or
    1              0.000003 syn keyword pythonException	except finally raise try
    1              0.000004 syn keyword pythonInclude	from import
    1              0.000003 syn keyword pythonAsync		async await
                            
                            " Decorators (new in Python 2.4)
                            " A dot must be allowed because of @MyClass.myfunc decorators.
    1              0.000008 syn match   pythonDecorator	"@" display contained
    1              0.000014 syn match   pythonDecoratorName	"@\s*\h\%(\w\|\.\)*" display contains=pythonDecorator
                            
                            " Python 3.5 introduced the use of the same symbol for matrix multiplication:
                            " https://www.python.org/dev/peps/pep-0465/.  We now have to exclude the
                            " symbol from highlighting when used in that context.
                            " Single line multiplication.
    1              0.000027 syn match   pythonMatrixMultiply
                                  \ "\%(\w\|[])]\)\s*@"
                                  \ contains=ALLBUT,pythonDecoratorName,pythonDecorator,pythonFunction,pythonDoctestValue
                                  \ transparent
                            " Multiplication continued on the next line after backslash.
    1              0.000025 syn match   pythonMatrixMultiply
                                  \ "[^\\]\\\s*\n\%(\s*\.\.\.\s\)\=\s\+@"
                                  \ contains=ALLBUT,pythonDecoratorName,pythonDecorator,pythonFunction,pythonDoctestValue
                                  \ transparent
                            " Multiplication in a parenthesized expression over multiple lines with @ at
                            " the start of each continued line; very similar to decorators and complex.
    1              0.000036 syn match   pythonMatrixMultiply
                                  \ "^\s*\%(\%(>>>\|\.\.\.\)\s\+\)\=\zs\%(\h\|\%(\h\|[[(]\).\{-}\%(\w\|[])]\)\)\s*\n\%(\s*\.\.\.\s\)\=\s\+@\%(.\{-}\n\%(\s*\.\.\.\s\)\=\s\+@\)*"
                                  \ contains=ALLBUT,pythonDecoratorName,pythonDecorator,pythonFunction,pythonDoctestValue
                                  \ transparent
                            
    1              0.000006 syn match   pythonFunction	"\h\w*" display contained
                            
    1              0.000010 syn match   pythonComment	"#.*$" contains=pythonTodo,@Spell
    1              0.000005 syn keyword pythonTodo		FIXME NOTE NOTES TODO XXX contained
                            
                            " Triple-quoted strings can contain doctests.
    1              0.000018 syn region  pythonString matchgroup=pythonQuotes
                                  \ start=+[uU]\=\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=pythonEscape,@Spell
    1              0.000020 syn region  pythonString matchgroup=pythonTripleQuotes
                                  \ start=+[uU]\=\z('''\|"""\)+ end="\z1" keepend
                                  \ contains=pythonEscape,pythonSpaceError,pythonDoctest,@Spell
    1              0.000011 syn region  pythonRawString matchgroup=pythonQuotes
                                  \ start=+[uU]\=[rR]\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=@Spell
    1              0.000016 syn region  pythonRawString matchgroup=pythonTripleQuotes
                                  \ start=+[uU]\=[rR]\z('''\|"""\)+ end="\z1" keepend
                                  \ contains=pythonSpaceError,pythonDoctest,@Spell
                            
    1              0.000006 syn match   pythonEscape	+\\[abfnrtv'"\\]+ contained
    1              0.000005 syn match   pythonEscape	"\\\o\{1,3}" contained
    1              0.000004 syn match   pythonEscape	"\\x\x\{2}" contained
    1              0.000006 syn match   pythonEscape	"\%(\\u\x\{4}\|\\U\x\{8}\)" contained
                            " Python allows case-insensitive Unicode IDs: http://www.unicode.org/charts/
    1              0.000006 syn match   pythonEscape	"\\N{\a\+\%(\s\a\+\)*}" contained
    1              0.000003 syn match   pythonEscape	"\\$"
                            
                            " It is very important to understand all details before changing the
                            " regular expressions below or their order.
                            " The word boundaries are *not* the floating-point number boundaries
                            " because of a possible leading or trailing decimal point.
                            " The expressions below ensure that all valid number literals are
                            " highlighted, and invalid number literals are not.  For example,
                            "
                            " - a decimal point in '4.' at the end of a line is highlighted,
                            " - a second dot in 1.0.0 is not highlighted,
                            " - 08 is not highlighted,
                            " - 08e0 or 08j are highlighted,
                            "
                            " and so on, as specified in the 'Python Language Reference'.
                            " https://docs.python.org/2/reference/lexical_analysis.html#numeric-literals
                            " https://docs.python.org/3/reference/lexical_analysis.html#numeric-literals
    1              0.000004 if !exists("python_no_number_highlight")
                              " numbers (including longs and complex)
    1              0.000005   syn match   pythonNumber	"\<0[oO]\=\o\+[Ll]\=\>"
    1              0.000006   syn match   pythonNumber	"\<0[xX]\x\+[Ll]\=\>"
    1              0.000004   syn match   pythonNumber	"\<0[bB][01]\+[Ll]\=\>"
    1              0.000005   syn match   pythonNumber	"\<\%([1-9]\d*\|0\)[Ll]\=\>"
    1              0.000003   syn match   pythonNumber	"\<\d\+[jJ]\>"
    1              0.000005   syn match   pythonNumber	"\<\d\+[eE][+-]\=\d\+[jJ]\=\>"
    1              0.000009   syn match   pythonNumber
                            	\ "\<\d\+\.\%([eE][+-]\=\d\+\)\=[jJ]\=\%(\W\|$\)\@="
    1              0.000008   syn match   pythonNumber
                            	\ "\%(^\|\W\)\zs\d*\.\d\+\%([eE][+-]\=\d\+\)\=[jJ]\=\>"
    1              0.000001 endif
                            
                            " Group the built-ins in the order in the 'Python Library Reference' for
                            " easier comparison.
                            " https://docs.python.org/2/library/constants.html
                            " https://docs.python.org/3/library/constants.html
                            " http://docs.python.org/2/library/functions.html
                            " http://docs.python.org/3/library/functions.html
                            " http://docs.python.org/2/library/functions.html#non-essential-built-in-functions
                            " http://docs.python.org/3/library/functions.html#non-essential-built-in-functions
                            " Python built-in functions are in alphabetical order.
    1              0.000004 if !exists("python_no_builtin_highlight")
                              " built-in constants
                              " 'False', 'True', and 'None' are also reserved words in Python 3
    1              0.000008   syn keyword pythonBuiltin	False True None
    1              0.000009   syn keyword pythonBuiltin	NotImplemented Ellipsis __debug__
                              " built-in functions
    1              0.000011   syn keyword pythonBuiltin	abs all any bin bool bytearray callable chr
    1              0.000005   syn keyword pythonBuiltin	classmethod compile complex delattr dict dir
    1              0.000005   syn keyword pythonBuiltin	divmod enumerate eval filter float format
    1              0.000004   syn keyword pythonBuiltin	frozenset getattr globals hasattr hash
    1              0.000005   syn keyword pythonBuiltin	help hex id input int isinstance
    1              0.000004   syn keyword pythonBuiltin	issubclass iter len list locals map max
    1              0.000006   syn keyword pythonBuiltin	memoryview min next object oct open ord pow
    1              0.000004   syn keyword pythonBuiltin	print property range repr reversed round set
    1              0.000004   syn keyword pythonBuiltin	setattr slice sorted staticmethod str
    1              0.000005   syn keyword pythonBuiltin	sum super tuple type vars zip __import__
                              " Python 2 only
    1              0.000004   syn keyword pythonBuiltin	basestring cmp execfile file
    1              0.000004   syn keyword pythonBuiltin	long raw_input reduce reload unichr
    1              0.000004   syn keyword pythonBuiltin	unicode xrange
                              " Python 3 only
    1              0.000004   syn keyword pythonBuiltin	ascii bytes exec
                              " non-essential built-in functions; Python 2 only
    1              0.000003   syn keyword pythonBuiltin	apply buffer coerce intern
                              " avoid highlighting attributes as builtins
    1              0.000022   syn match   pythonAttribute	/\.\h\w*/hs=s+1
                            	\ contains=ALLBUT,pythonBuiltin,pythonFunction,pythonAsync
                            	\ transparent
    1              0.000001 endif
                            
                            " From the 'Python Library Reference' class hierarchy at the bottom.
                            " http://docs.python.org/2/library/exceptions.html
                            " http://docs.python.org/3/library/exceptions.html
    1              0.000003 if !exists("python_no_exception_highlight")
                              " builtin base exceptions (used mostly as base classes for other exceptions)
    1              0.000005   syn keyword pythonExceptions	BaseException Exception
    1              0.000004   syn keyword pythonExceptions	ArithmeticError BufferError
    1              0.000004   syn keyword pythonExceptions	LookupError
                              " builtin base exceptions removed in Python 3
    1              0.000004   syn keyword pythonExceptions	EnvironmentError StandardError
                              " builtin exceptions (actually raised)
    1              0.000004   syn keyword pythonExceptions	AssertionError AttributeError
    1              0.000004   syn keyword pythonExceptions	EOFError FloatingPointError GeneratorExit
    1              0.000004   syn keyword pythonExceptions	ImportError IndentationError
    1              0.000004   syn keyword pythonExceptions	IndexError KeyError KeyboardInterrupt
    1              0.000004   syn keyword pythonExceptions	MemoryError NameError NotImplementedError
    1              0.000004   syn keyword pythonExceptions	OSError OverflowError ReferenceError
    1              0.000004   syn keyword pythonExceptions	RuntimeError StopIteration SyntaxError
    1              0.000004   syn keyword pythonExceptions	SystemError SystemExit TabError TypeError
    1              0.000004   syn keyword pythonExceptions	UnboundLocalError UnicodeError
    1              0.000004   syn keyword pythonExceptions	UnicodeDecodeError UnicodeEncodeError
    1              0.000003   syn keyword pythonExceptions	UnicodeTranslateError ValueError
    1              0.000003   syn keyword pythonExceptions	ZeroDivisionError
                              " builtin OS exceptions in Python 3
    1              0.000004   syn keyword pythonExceptions	BlockingIOError BrokenPipeError
    1              0.000004   syn keyword pythonExceptions	ChildProcessError ConnectionAbortedError
    1              0.000004   syn keyword pythonExceptions	ConnectionError ConnectionRefusedError
    1              0.000009   syn keyword pythonExceptions	ConnectionResetError FileExistsError
    1              0.000020   syn keyword pythonExceptions	FileNotFoundError InterruptedError
    1              0.000012   syn keyword pythonExceptions	IsADirectoryError NotADirectoryError
    1              0.000011   syn keyword pythonExceptions	PermissionError ProcessLookupError
    1              0.000011   syn keyword pythonExceptions	RecursionError StopAsyncIteration
    1              0.000019   syn keyword pythonExceptions	TimeoutError
                              " builtin exceptions deprecated/removed in Python 3
    1              0.000015   syn keyword pythonExceptions	IOError VMSError WindowsError
                              " builtin warnings
    1              0.000015   syn keyword pythonExceptions	BytesWarning DeprecationWarning FutureWarning
    1              0.000011   syn keyword pythonExceptions	ImportWarning PendingDeprecationWarning
    1              0.000013   syn keyword pythonExceptions	RuntimeWarning SyntaxWarning UnicodeWarning
    1              0.000011   syn keyword pythonExceptions	UserWarning Warning
                              " builtin warnings in Python 3
    1              0.000007   syn keyword pythonExceptions	ResourceWarning
    1              0.000001 endif
                            
    1              0.000007 if exists("python_space_error_highlight")
                              " trailing whitespace
                              syn match   pythonSpaceError	display excludenl "\s\+$"
                              " mixed tabs and spaces
                              syn match   pythonSpaceError	display " \+\t"
                              syn match   pythonSpaceError	display "\t\+ "
                            endif
                            
                            " Do not spell doctests inside strings.
                            " Notice that the end of a string, either ''', or """, will end the contained
                            " doctest too.  Thus, we do *not* need to have it as an end pattern.
    1              0.000003 if !exists("python_no_doctest_highlight")
    1              0.000003   if !exists("python_no_doctest_code_highlight")
    1              0.000020     syn region pythonDoctest
                            	  \ start="^\s*>>>\s" end="^\s*$"
                            	  \ contained contains=ALLBUT,pythonDoctest,pythonFunction,@Spell
    1              0.000012     syn region pythonDoctestValue
                            	  \ start=+^\s*\%(>>>\s\|\.\.\.\s\|"""\|'''\)\@!\S\++ end="$"
                            	  \ contained
    1              0.000001   else
                                syn region pythonDoctest
                            	  \ start="^\s*>>>" end="^\s*$"
                            	  \ contained contains=@NoSpell
                              endif
    1              0.000000 endif
                            
                            " Sync at the beginning of class, function, or method definition.
    1              0.000009 syn sync match pythonSync grouphere NONE "^\%(def\|class\)\s\+\h\w*\s*[(:]"
                            
                            " The default highlight links.  Can be overridden later.
    1              0.000011 hi def link pythonStatement		Statement
    1              0.000007 hi def link pythonConditional		Conditional
    1              0.000006 hi def link pythonRepeat		Repeat
    1              0.000006 hi def link pythonOperator		Operator
    1              0.000006 hi def link pythonException		Exception
    1              0.000006 hi def link pythonInclude		Include
    1              0.000005 hi def link pythonAsync			Statement
    1              0.000007 hi def link pythonDecorator		Define
    1              0.000006 hi def link pythonDecoratorName		Function
    1              0.000007 hi def link pythonFunction		Function
    1              0.000005 hi def link pythonComment		Comment
    1              0.000006 hi def link pythonTodo			Todo
    1              0.000006 hi def link pythonString		String
    1              0.000005 hi def link pythonRawString		String
    1              0.000005 hi def link pythonQuotes		String
    1              0.000003 hi def link pythonTripleQuotes		pythonQuotes
    1              0.000006 hi def link pythonEscape		Special
    1              0.000003 if !exists("python_no_number_highlight")
    1              0.000005   hi def link pythonNumber		Number
    1              0.000001 endif
    1              0.000003 if !exists("python_no_builtin_highlight")
    1              0.000007   hi def link pythonBuiltin		Function
    1              0.000000 endif
    1              0.000002 if !exists("python_no_exception_highlight")
    1              0.000007   hi def link pythonExceptions		Structure
    1              0.000001 endif
    1              0.000002 if exists("python_space_error_highlight")
                              hi def link pythonSpaceError		Error
                            endif
    1              0.000002 if !exists("python_no_doctest_highlight")
    1              0.000005   hi def link pythonDoctest		Special
    1              0.000006   hi def link pythonDoctestValue	Define
    1              0.000001 endif
                            
    1              0.000003 let b:current_syntax = "python"
                            
    1              0.000009 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            
                            " vim:set sw=2 sts=2 ts=8 noet:

SCRIPT  /home/transpalette/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim
Sourced 1 time
Total time:   0.008620
 Self time:   0.008455

count  total (s)   self (s)
                            " =============================================================================
                            " File:          autoload/ctrlp.vim
                            " Description:   Fuzzy file, buffer, mru, tag, etc finder.
                            " Author:        CtrlP Dev Team
                            " Original:      Kien Nguyen <github.com/kien>
                            " Version:       1.80
                            " =============================================================================
                            
                            " ** Static variables {{{1
                            " s:ignore() {{{2
    1              0.000020 fu! s:ignore()
                            	let igdirs = [
                            		\ '\.git',
                            		\ '\.hg',
                            		\ '\.svn',
                            		\ '_darcs',
                            		\ '\.bzr',
                            		\ '\.cdv',
                            		\ '\~\.dep',
                            		\ '\~\.dot',
                            		\ '\~\.nib',
                            		\ '\~\.plst',
                            		\ '\.pc',
                            		\ '_MTN',
                            		\ 'blib',
                            		\ 'CVS',
                            		\ 'RCS',
                            		\ 'SCCS',
                            		\ '_sgbak',
                            		\ 'autom4te\.cache',
                            		\ 'cover_db',
                            		\ '_build',
                            		\ ]
                            	let igfiles = [
                            		\ '\~$',
                            		\ '#.+#$',
                            		\ '[._].*\.swp$',
                            		\ 'core\.\d+$',
                            		\ '\.exe$',
                            		\ '\.so$',
                            		\ '\.bak$',
                            		\ '\.png$',
                            		\ '\.jpg$',
                            		\ '\.gif$',
                            		\ '\.zip$',
                            		\ '\.rar$',
                            		\ '\.tar\.gz$',
                            		\ ]
                            	retu {
                            		\ 'dir': '\v[\/]('.join(igdirs, '|').')$',
                            		\ 'file': '\v'.join(igfiles, '|'),
                            		\ }
                            endf
                            " Script local vars {{{2
    1   0.000660   0.000495 let [s:pref, s:bpref, s:opts, s:new_opts, s:lc_opts] =
                            	\ ['g:ctrlp_', 'b:ctrlp_', {
                            	\ 'abbrev':                ['s:abbrev', {}],
                            	\ 'arg_map':               ['s:argmap', 0],
                            	\ 'buffer_func':           ['s:buffunc', {}],
                            	\ 'by_filename':           ['s:byfname', 0],
                            	\ 'custom_ignore':         ['s:usrign', s:ignore()],
                            	\ 'default_input':         ['s:deftxt', 0],
                            	\ 'dont_split':            ['s:nosplit', 'netrw'],
                            	\ 'dotfiles':              ['s:showhidden', 0],
                            	\ 'extensions':            ['s:extensions', []],
                            	\ 'follow_symlinks':       ['s:folsym', 0],
                            	\ 'highlight_match':       ['s:mathi', [1, 'CtrlPMatch']],
                            	\ 'jump_to_buffer':        ['s:jmptobuf', 'Et'],
                            	\ 'key_loop':              ['s:keyloop', 0],
                            	\ 'lazy_update':           ['s:lazy', 0],
                            	\ 'match_func':            ['s:matcher', {}],
                            	\ 'match_window':          ['s:mw', ''],
                            	\ 'match_window_bottom':   ['s:mwbottom', 1],
                            	\ 'match_window_reversed': ['s:mwreverse', 1],
                            	\ 'max_depth':             ['s:maxdepth', 40],
                            	\ 'max_files':             ['s:maxfiles', 10000],
                            	\ 'max_height':            ['s:mxheight', 10],
                            	\ 'max_history':           ['s:maxhst', exists('+hi') ? &hi : 20],
                            	\ 'mruf_default_order':    ['s:mrudef', 0],
                            	\ 'open_func':             ['s:openfunc', {}],
                            	\ 'open_multi':            ['s:opmul', '1v'],
                            	\ 'open_new_file':         ['s:newfop', 'v'],
                            	\ 'prompt_mappings':       ['s:urprtmaps', 0],
                            	\ 'regexp_search':         ['s:regexp', 0],
                            	\ 'root_markers':          ['s:rmarkers', []],
                            	\ 'split_window':          ['s:splitwin', 0],
                            	\ 'status_func':           ['s:status', {}],
                            	\ 'tabpage_position':      ['s:tabpage', 'ac'],
                            	\ 'use_caching':           ['s:caching', 1],
                            	\ 'user_command':          ['s:usrcmd', ''],
                            	\ 'validate':              ['s:validate', ''],
                            	\ 'working_path_mode':     ['s:pathmode', 'ra'],
                            	\ 'line_prefix':           ['s:lineprefix', '> '],
                            	\ 'open_single_match':     ['s:opensingle', []],
                            	\ 'brief_prompt':          ['s:brfprt', 0],
                            	\ 'match_current_file':    ['s:matchcrfile', 0],
                            	\ 'match_natural_name':    ['s:matchnatural', 0],
                            	\ 'compare_lim':           ['s:compare_lim', 3000],
                            	\ 'bufname_mod':           ['s:bufname_mod', ':t'],
                            	\ 'bufpath_mod':           ['s:bufpath_mod', ':~:.:h'],
                            	\ 'formatline_func':       ['s:flfunc', 's:formatline(v:val)'],
                            	\ 'user_command_async':    ['s:usrcmdasync', 0],
                            	\ }, {
                            	\ 'open_multiple_files':   's:opmul',
                            	\ 'regexp':                's:regexp',
                            	\ 'reuse_window':          's:nosplit',
                            	\ 'show_hidden':           's:showhidden',
                            	\ 'switch_buffer':         's:jmptobuf',
                            	\ }, {
                            	\ 'root_markers':          's:rmarkers',
                            	\ 'user_command':          's:usrcmd',
                            	\ 'working_path_mode':     's:pathmode',
                            	\ }]
                            
                            " Global options
    1              0.000057 let s:glbs = { 'magic': 1, 'to': 1, 'tm': 0, 'sb': 1, 'hls': 0, 'im': 0,
                            	\ 'report': 9999, 'sc': 0, 'ss': 0, 'siso': 0, 'mfd': 200, 'ttimeout': 0,
                            	\ 'gcr': 'a:blinkon0', 'ic': 1, 'lmap': '', 'mousef': 0, 'imd': 1 }
                            
                            " Keymaps
    1              0.000328 let [s:lcmap, s:prtmaps] = ['nn <buffer> <silent>', {
                            	\ 'PrtBS()':              ['<bs>', '<c-]>'],
                            	\ 'PrtDelete()':          ['<del>'],
                            	\ 'PrtDeleteWord()':      ['<c-w>'],
                            	\ 'PrtClear()':           ['<c-u>'],
                            	\ 'PrtSelectMove("j")':   ['<c-j>', '<down>'],
                            	\ 'PrtSelectMove("k")':   ['<c-k>', '<up>'],
                            	\ 'PrtSelectMove("t")':   ['<Home>', '<kHome>'],
                            	\ 'PrtSelectMove("b")':   ['<End>', '<kEnd>'],
                            	\ 'PrtSelectMove("u")':   ['<PageUp>', '<kPageUp>'],
                            	\ 'PrtSelectMove("d")':   ['<PageDown>', '<kPageDown>'],
                            	\ 'PrtHistory(-1)':       ['<c-n>'],
                            	\ 'PrtHistory(1)':        ['<c-p>'],
                            	\ 'AcceptSelection("e")': ['<cr>', '<2-LeftMouse>'],
                            	\ 'AcceptSelection("h")': ['<c-x>', '<c-cr>', '<c-s>'],
                            	\ 'AcceptSelection("t")': ['<c-t>'],
                            	\ 'AcceptSelection("v")': ['<c-v>', '<RightMouse>'],
                            	\ 'ToggleFocus()':        ['<s-tab>'],
                            	\ 'ToggleRegex()':        ['<c-r>'],
                            	\ 'ToggleByFname()':      ['<c-d>'],
                            	\ 'ToggleType(1)':        ['<c-f>', '<c-up>'],
                            	\ 'ToggleType(-1)':       ['<c-b>', '<c-down>'],
                            	\ 'PrtExpandDir()':       ['<tab>'],
                            	\ 'PrtInsert("c")':       ['<MiddleMouse>', '<insert>'],
                            	\ 'PrtInsert()':          ['<c-\>'],
                            	\ 'PrtCurStart()':        ['<c-a>'],
                            	\ 'PrtCurEnd()':          ['<c-e>'],
                            	\ 'PrtCurLeft()':         ['<c-h>', '<left>', '<c-^>'],
                            	\ 'PrtCurRight()':        ['<c-l>', '<right>'],
                            	\ 'PrtClearCache()':      ['<F5>'],
                            	\ 'PrtDeleteEnt()':       ['<F7>'],
                            	\ 'CreateNewFile()':      ['<c-y>'],
                            	\ 'MarkToOpen()':         ['<c-z>'],
                            	\ 'OpenMulti()':          ['<c-o>'],
                            	\ 'YankLine()':           [],
                            	\ 'PrtExit()':            ['<esc>', '<c-c>', '<c-g>'],
                            	\ }]
                            
    1              0.000033 if !has('gui_running')
    1              0.000035 	cal add(s:prtmaps['PrtBS()'], remove(s:prtmaps['PrtCurLeft()'], 0))
    1              0.000005 en
                            
    1              0.000012 let s:ficounts = {}
                            
    1              0.000013 let s:ccex = s:pref.'clear_cache_on_exit'
                            
                            " Regexp
    1              0.000028 let s:fpats = {
                            	\ '^\(\\|\)\|\(\\|\)$': '\\|',
                            	\ '^\\\(zs\|ze\|<\|>\)': '^\\\(zs\|ze\|<\|>\)',
                            	\ '^\S\*$': '\*',
                            	\ '^\S\\?$': '\\?',
                            	\ }
                            
    1              0.000012 let s:has_conceal = has('conceal')
    1              0.000007 let s:bufnr_width = 3
                            
                            " Keypad
    1              0.000017 let s:kprange = {
                            	\ 'Plus': '+',
                            	\ 'Minus': '-',
                            	\ 'Divide': '/',
                            	\ 'Multiply': '*',
                            	\ 'Point': '.',
                            	\ }
                            
                            " Highlight groups
    1              0.000058 let s:hlgrps = {
                            	\ 'NoEntries': 'Error',
                            	\ 'Mode1': 'Character',
                            	\ 'Mode2': 'LineNr',
                            	\ 'Stats': 'Function',
                            	\ 'Match': 'Identifier',
                            	\ 'PrtBase': 'Comment',
                            	\ 'PrtText': 'Normal',
                            	\ 'PrtCursor': 'Constant',
                            	\ 'BufferNr':      'Constant',
                            	\ 'BufferInd':     'Normal',
                            	\ 'BufferHid':     'Comment',
                            	\ 'BufferHidMod':  'String',
                            	\ 'BufferVis':     'Normal',
                            	\ 'BufferVisMod':  'Identifier',
                            	\ 'BufferCur':     'Question',
                            	\ 'BufferCurMod':  'WarningMsg',
                            	\ 'BufferPath':    'Comment',
                            	\ }
                            
                            " lname, sname of the basic(non-extension) modes
    1              0.000009 let s:types = ['fil', 'buf', 'mru']
    1              0.000010 if !exists('g:ctrlp_types')
    1              0.000014 	let g:ctrlp_types = s:types
    1              0.000004 el
                            	call filter(g:ctrlp_types, "index(['fil', 'buf', 'mru'], v:val)!=-1")
                            en
    1              0.000021 let g:ctrlp_builtins = len(g:ctrlp_types)-1
                            
    1              0.000015 let s:coretype_names = {
                            	\ 'fil' : 'files',
                            	\ 'buf' : 'buffers',
                            	\ 'mru' : 'mru files',
                            	\ }
                            
    1              0.000044 let s:coretypes = map(copy(g:ctrlp_types), '[s:coretype_names[v:val], v:val]')
                            
                            " Get the options {{{2
    1              0.000009 fu! s:opts(...)
                            	unl! s:usrign s:usrcmd s:urprtmaps
                            	for each in ['byfname', 'regexp', 'extensions'] | if exists('s:'.each)
                            		let {each} = s:{each}
                            	en | endfo
                            	for [ke, va] in items(s:opts)
                            		let {va[0]} = exists(s:pref.ke) ? {s:pref.ke} : va[1]
                            	endfo
                            	unl va
                            	for [ke, va] in items(s:new_opts)
                            		let {va} = {exists(s:pref.ke) ? s:pref.ke : va}
                            	endfo
                            	unl va
                            	for [ke, va] in items(s:lc_opts)
                            		if exists(s:bpref.ke)
                            			unl {va}
                            			let {va} = {s:bpref.ke}
                            		en
                            	endfo
                            	" Match window options
                            	cal s:match_window_opts()
                            	" One-time values
                            	if a:0 && a:1 != {}
                            		unl va
                            		for [ke, va] in items(a:1)
                            			let opke = substitute(ke, '\(\w:\)\?ctrlp_', '', '')
                            			if has_key(s:lc_opts, opke)
                            				let sva = s:lc_opts[opke]
                            				unl {sva}
                            				let {sva} = va
                            			en
                            		endfo
                            	en
                            	for each in ['byfname', 'regexp'] | if exists(each)
                            		let s:{each} = {each}
                            	en | endfo
                            	if !exists('g:ctrlp_tilde_homedir') | let g:ctrlp_tilde_homedir = 0 | en
                            	if !exists('g:ctrlp_newcache') | let g:ctrlp_newcache = 0 | en
                            	let s:maxdepth = min([s:maxdepth, 100])
                            	let s:glob = s:showhidden ? '.*\|*' : '*'
                            	let s:igntype = empty(s:usrign) ? -1 : type(s:usrign)
                            	let s:lash = ctrlp#utils#lash()
                            	if s:keyloop
                            		let [s:lazy, s:glbs['imd']] = [0, 0]
                            	en
                            	if s:lazy
                            		cal extend(s:glbs, { 'ut': ( s:lazy > 1 ? s:lazy : 250 ) })
                            	en
                            	" Extensions
                            	if !( exists('extensions') && extensions == s:extensions )
                            		for each in s:extensions
                            			exe 'ru autoload/ctrlp/'.each.'.vim'
                            		endfo
                            	en
                            	" Keymaps
                            	if type(s:urprtmaps) == 4
                            		cal extend(s:prtmaps, s:urprtmaps)
                            	en
                            endf
                            
    1              0.000007 fu! s:match_window_opts()
                            	let s:mw_pos =
                            		\ s:mw =~ 'top\|bottom' ? matchstr(s:mw, 'top\|bottom') :
                            		\ exists('g:ctrlp_match_window_bottom') ? ( s:mwbottom ? 'bottom' : 'top' )
                            		\ : 'bottom'
                            	let s:mw_order =
                            		\ s:mw =~ 'order:[^,]\+' ? matchstr(s:mw, 'order:\zs[^,]\+') :
                            		\ exists('g:ctrlp_match_window_reversed') ? ( s:mwreverse ? 'btt' : 'ttb' )
                            		\ : 'btt'
                            	let s:mw_max =
                            		\ s:mw =~ 'max:[^,]\+' ? str2nr(matchstr(s:mw, 'max:\zs\d\+')) :
                            		\ exists('g:ctrlp_max_height') ? s:mxheight
                            		\ : 10
                            	let s:mw_min =
                            		\ s:mw =~ 'min:[^,]\+' ? str2nr(matchstr(s:mw, 'min:\zs\d\+')) : 1
                            	let [s:mw_max, s:mw_min] = [max([s:mw_max, 1]), max([s:mw_min, 1])]
                            	let s:mw_min = min([s:mw_min, s:mw_max])
                            	let s:mw_res =
                            		\ s:mw =~ 'results:[^,]\+' ? str2nr(matchstr(s:mw, 'results:\zs\d\+'))
                            		\ : min([s:mw_max, &lines])
                            endf
                            "}}}1
                            " * Open & Close {{{1
    1              0.000005 fu! s:Open()
                            	cal s:log(1)
                            	cal s:getenv()
                            	cal s:execextvar('enter')
                            	sil! exe 'keepa' ( s:mw_pos == 'top' ? 'to' : 'bo' ) '1new ControlP'
                            	cal s:buffunc(1)
                            	let [s:bufnr, s:winw] = [bufnr('%'), winwidth(0)]
                            	let [s:focus, s:prompt] = [1, ['', '', '']]
                            	abc <buffer>
                            	if !exists('s:hstry')
                            		let hst = filereadable(s:gethistloc()[1]) ? s:gethistdata() : ['']
                            		let s:hstry = empty(hst) || !s:maxhst ? [''] : hst
                            	en
                            	for [ke, va] in items(s:glbs) | if exists('+'.ke)
                            		sil! exe 'let s:glb_'.ke.' = &'.ke.' | let &'.ke.' = '.string(va)
                            	en | endfo
                            	if s:opmul != '0' && has('signs')
                            		sign define ctrlpmark text=+> texthl=CtrlPMark
                            		hi def link CtrlPMark Search
                            	en
                            	cal s:setupblank()
                            endf
                            
    1              0.000006 fu! s:Close()
                            	cal s:buffunc(0)
                            	if winnr('$') == 1
                            		bw!
                            	el
                            		try | bun!
                            		cat | clo! | endt
                            		cal s:unmarksigns()
                            	en
                            	for key in keys(s:glbs) | if exists('+'.key)
                            		sil! exe 'let &'.key.' = s:glb_'.key
                            	en | endfo
                            	if exists('s:glb_acd') | let &acd = s:glb_acd | en
                            	let g:ctrlp_lines = []
                            	if s:winres[1] >= &lines && s:winres[2] == winnr('$')
                            		exe s:winres[0].s:winres[0]
                            	en
                            	unl! s:focus s:hisidx s:hstgot s:marked s:statypes s:init s:savestr
                            		\ s:mrbs s:did_exp
                            	cal ctrlp#recordhist()
                            	cal s:execextvar('exit')
                            	cal s:log(0)
                            	let v:errmsg = s:ermsg
                            	ec
                            endf
                            " * Clear caches {{{1
    1              0.000005 fu! ctrlp#clr(...)
                            	let [s:matches, g:ctrlp_new{ a:0 ? a:1 : 'cache' }] = [1, 1]
                            endf
                            
    1              0.000004 fu! ctrlp#clra()
                            	let cadir = ctrlp#utils#cachedir()
                            	if isdirectory(cadir)
                            		let cafiles = split(s:glbpath(s:fnesc(cadir, 'g', ','), '**', 1), "\n")
                            		let eval = '!isdirectory(v:val) && v:val !~ ''\v[\/]cache[.a-z]+$|\.log$'''
                            		sil! cal map(s:ifilter(cafiles, eval), 'delete(v:val)')
                            	en
                            	cal ctrlp#clr()
                            endf
                            
    1              0.000006 fu! s:Reset(args)
                            	let opts = has_key(a:args, 'opts') ? [a:args['opts']] : []
                            	cal call('s:opts', opts)
                            	cal s:autocmds()
                            	cal ctrlp#utils#opts()
                            	cal s:execextvar('opts')
                            endf
                            " * Files {{{1
    1              0.000004 fu! ctrlp#files()
                            	let cafile = ctrlp#utils#cachefile()
                            	if g:ctrlp_newcache || !filereadable(cafile) || s:nocache(cafile)
                            		let [lscmd, s:initcwd, g:ctrlp_allfiles] = [s:lsCmd(), s:dyncwd, []]
                            		" Get the list of files
                            		if empty(lscmd)
                            			if !ctrlp#igncwd(s:dyncwd)
                            				cal s:InitCustomFuncs()
                            				cal s:GlobPath(s:fnesc(s:dyncwd, 'g', ','), 0)
                            				cal s:CloseCustomFuncs()
                            			en
                            		el
                            			sil! cal ctrlp#progress('Indexing...')
                            			try | cal s:UserCmd(lscmd)
                            			cat | retu [] | endt
                            		en
                            		" Remove base directory
                            		cal ctrlp#rmbasedir(g:ctrlp_allfiles)
                            		if len(g:ctrlp_allfiles) <= s:compare_lim
                            			cal sort(g:ctrlp_allfiles, 'ctrlp#complen')
                            		en
                            		cal s:writecache(cafile)
                            		let catime = getftime(cafile)
                            	el
                            		let catime = getftime(cafile)
                            		if !( exists('s:initcwd') && s:initcwd == s:dyncwd )
                            			\ || get(s:ficounts, s:dyncwd, [0, catime])[1] != catime
                            			let s:initcwd = s:dyncwd
                            			let g:ctrlp_allfiles = ctrlp#utils#readfile(cafile)
                            		en
                            	en
                            	cal extend(s:ficounts, { s:dyncwd : [len(g:ctrlp_allfiles), catime] })
                            	retu g:ctrlp_allfiles
                            endf
                            
    1              0.000006 fu! s:InitCustomFuncs()
                            	if s:igntype == 4 && has_key(s:usrign, 'func-init') && s:usrign['func-init'] != ''
                            		exe call(s:usrign['func-init'], [])
                            	en
                            endf
                            
    1              0.000006 fu! s:CloseCustomFuncs()
                            	if s:igntype == 4 && has_key(s:usrign, 'func-close') && s:usrign['func-close'] != ''
                            		exe call(s:usrign['func-close'], [])
                            	en
                            endf
                            
    1              0.000007 fu! s:GlobPath(dirs, depth)
                            	let entries = split(globpath(a:dirs, s:glob), "\n")
                            	let [dnf, depth] = [ctrlp#dirnfile(entries), a:depth + 1]
                            	cal extend(g:ctrlp_allfiles, dnf[1])
                            	if !empty(dnf[0]) && !s:maxf(len(g:ctrlp_allfiles)) && depth <= s:maxdepth
                            		sil! cal ctrlp#progress(len(g:ctrlp_allfiles), 1)
                            		cal s:GlobPath(join(map(dnf[0], 's:fnesc(v:val, "g", ",")'), ','), depth)
                            	en
                            endf
                            
    1              0.000006 fu! ctrlp#addfile(ch, file)
                            	call add(g:ctrlp_allfiles, a:file)
                            	cal s:BuildPrompt(1)
                            endf
                            
    1              0.000006 fu! s:safe_printf(format, ...)
                            	try
                            		retu call('printf', [a:format] + a:000)
                            	cat
                            		retu a:format
                            	endt
                            endf
                            
    1              0.000005 fu! s:UserCmd(lscmd)
                            	let [path, lscmd] = [s:dyncwd, a:lscmd]
                            	let do_ign =
                            		\ type(s:usrcmd) == 4 && has_key(s:usrcmd, 'ignore') && s:usrcmd['ignore']
                            	if do_ign && ctrlp#igncwd(s:cwd) | retu | en
                            	if exists('+ssl') && &ssl && &shell !~ 'sh'
                            		let [ssl, &ssl, path] = [&ssl, 0, tr(path, '/', '\')]
                            	en
                            	if (has('win32') || has('win64')) && match(&shellcmdflag, "/") != -1
                            		let lscmd = substitute(lscmd, '\v(^|\&\&\s*)\zscd (/d)@!', 'cd /d ', '')
                            	en
                            	let path = exists('*shellescape') ? shellescape(path) : path
                            	if (has('win32') || has('win64')) && match(&shell, 'sh') != -1
                            		let path = tr(path, '\', '/')
                            	en
                            	if s:usrcmdasync && v:version >= 800 && exists('*job_start')
                            		if exists('s:job')
                            			call job_stop(s:job)
                            		en
                            		let g:ctrlp_allfiles = []
                            		let s:job = job_start([&shell, &shellcmdflag, printf(lscmd, path)], {'callback': 'ctrlp#addfile'})
                            	elsei has('patch-7.4-597') && !(has('win32') || has('win64'))
                            		let g:ctrlp_allfiles = systemlist(s:safe_printf(lscmd, path))
                            	el
                            		let g:ctrlp_allfiles = split(system(s:safe_printf(lscmd, path)), "\n")
                            	en
                            	if exists('+ssl') && exists('ssl')
                            		let &ssl = ssl
                            		cal map(g:ctrlp_allfiles, 'tr(v:val, "\\", "/")')
                            	en
                            	if exists('s:vcscmd') && s:vcscmd
                            		cal map(g:ctrlp_allfiles, 'tr(v:val, "/", "\\")')
                            	en
                            	if do_ign
                            		if !empty(s:usrign)
                            			let g:ctrlp_allfiles = ctrlp#dirnfile(g:ctrlp_allfiles)[1]
                            		en
                            		if &wig != ''
                            			cal filter(g:ctrlp_allfiles, 'glob(v:val) != ""')
                            		en
                            	en
                            endf
                            
    1              0.000004 fu! s:lsCmd()
                            	let cmd = s:usrcmd
                            	if type(cmd) == 1
                            		retu cmd
                            	elsei type(cmd) == 3 && len(cmd) >= 2 && cmd[:1] != ['', '']
                            		if s:findroot(s:dyncwd, cmd[0], 0, 1) == []
                            			retu len(cmd) == 3 ? cmd[2] : ''
                            		en
                            		let s:vcscmd = s:lash == '\'
                            		retu cmd[1]
                            	elsei type(cmd) == 4 && ( has_key(cmd, 'types') || has_key(cmd, 'fallback') )
                            		let fndroot = []
                            		if has_key(cmd, 'types') && cmd['types'] != {}
                            			let [markrs, cmdtypes] = [[], values(cmd['types'])]
                            			for pair in cmdtypes
                            				cal add(markrs, pair[0])
                            			endfo
                            			let fndroot = s:findroot(s:dyncwd, markrs, 0, 1)
                            		en
                            		if fndroot == []
                            			retu has_key(cmd, 'fallback') ? cmd['fallback'] : ''
                            		en
                            		for pair in cmdtypes
                            			if pair[0] == fndroot[0] | brea | en
                            		endfo
                            		let s:vcscmd = s:lash == '\'
                            		retu pair[1]
                            	en
                            endf
                            " - Buffers {{{1
    1              0.000006 fu! s:bufparts(bufnr)
                            	let idc  = (a:bufnr == bufnr('#')      ? '#' : '')  " alternative
                            	let idc .= (getbufvar(a:bufnr, '&mod') ? '+' : '')  " modified
                            	let idc .= (getbufvar(a:bufnr, '&ma')  ? '' : '-')  " nomodifiable
                            	let idc .= (getbufvar(a:bufnr, '&ro')  ? '=' : '')  " readonly
                            
                            	" flags for highlighting
                            	let hiflags  = (bufwinnr(a:bufnr) != -1    ? '*' : '')  " visible
                            	let hiflags .= (getbufvar(a:bufnr, '&mod') ? '+' : '')  " modified
                            	let hiflags .= (a:bufnr == s:crbufnr       ? '!' : '')  " current
                            
                            	let bname = bufname(a:bufnr)
                            	let bname = (bname == '' ? '[No Name]' : fnamemodify(bname, s:bufname_mod))
                            
                            	let bpath = empty(s:bufpath_mod) ? '' : fnamemodify(bufname(a:bufnr), s:bufpath_mod).s:lash()
                            
                            	retu [idc, hiflags, bname, bpath]
                            endf
    1              0.000047 fu! ctrlp#buffers(...)
                            	let ids = sort(filter(range(1, bufnr('$')), '(empty(getbufvar(v:val, "&bt"))'
                            		\ .' || s:isterminal(v:val)) && getbufvar(v:val, "&bl")'), 's:compmreb')
                            	if a:0 && a:1 == 'id'
                            		retu ids
                            	el
                            		let bufs = [[], []]
                            		for id in ids
                            			let bname = bufname(id)
                            			let ebname = bname == ''
                            			let fname = fnamemodify(ebname ? '['.id.'*No Name]' : bname, ':.')
                            			cal add(bufs[ebname], fname)
                            		endfo
                            		retu bufs[0] + bufs[1]
                            	en
                            endf
                            " * MatchedItems() {{{1
    1              0.000008 fu! s:MatchIt(items, pat, limit, exc)
                            	let [lines, id] = [[], 0]
                            	let pat =
                            		\ s:byfname() ? map(split(a:pat, '^[^;]\+\\\@<!\zs;', 1), 's:martcs.v:val')
                            		\ : s:martcs.a:pat
                            	for item in a:items
                            		let id += 1
                            		try
                            			if (s:matchcrfile || !( s:ispath && item ==# a:exc )) &&
                            						\call(s:mfunc, [item, pat]) >= 0
                            				cal add(lines, item)
                            			en
                            		cat | brea | endt
                            		if a:limit > 0 && len(lines) >= a:limit | brea | en
                            	endfo
                            	let s:mdata = [s:dyncwd, s:itemtype, s:regexp, s:sublist(a:items, id, -1)]
                            	retu lines
                            endf
                            
    1              0.000007 fu! s:MatchedItems(items, pat, limit)
                            	let exc = exists('s:crfilerel') ? s:crfilerel : ''
                            	let items = s:narrowable() ? s:matched + s:mdata[3] : a:items
                            	let matcher = s:getextvar('matcher')
                            	if empty(matcher) || type(matcher) != 4 || !has_key(matcher, 'match')
                            		unlet matcher
                            		let matcher = s:matcher
                            	en
                            	if matcher != {}
                            		let argms =
                            			\ has_key(matcher, 'arg_type') && matcher['arg_type'] == 'dict' ? [{
                            			\ 'items':  items,
                            			\ 'str':    a:pat,
                            			\ 'limit':  a:limit,
                            			\ 'mmode':  s:mmode(),
                            			\ 'ispath': s:ispath,
                            			\ 'crfile': exc,
                            			\ 'regex':  s:regexp,
                            			\ }] : [items, a:pat, a:limit, s:mmode(), s:ispath, exc, s:regexp]
                            		let lines = call(matcher['match'], argms, matcher)
                            	el
                            		let lines = s:MatchIt(items, a:pat, a:limit, exc)
                            	en
                            	let s:matches = len(lines)
                            	unl! s:did_exp
                            	retu lines
                            endf
                            
    1              0.000006 fu! s:SplitPattern(str)
                            	let str = a:str
                            	let s:savestr = str
                            	if s:regexp
                            		let pat = s:regexfilter(str)
                            	el
                            		let lst = split(str, '\zs')
                            		if exists('+ssl') && !&ssl
                            			cal map(lst, 'escape(v:val, ''\'')')
                            		en
                            		for each in ['^', '$', '.']
                            			cal map(lst, 'escape(v:val, each)')
                            		endfo
                            	en
                            	if exists('lst')
                            		let pat = ''
                            		if !empty(lst)
                            			if s:byfname() && index(lst, ';') > 0
                            				let fbar = index(lst, ';')
                            				let lst_1 = s:sublist(lst, 0, fbar - 1)
                            				let lst_2 = len(lst) - 1 > fbar ? s:sublist(lst, fbar + 1, -1) : ['']
                            				let pat = s:buildpat(lst_1).';'.s:buildpat(lst_2)
                            			el
                            				let pat = s:buildpat(lst)
                            			en
                            		en
                            	en
                            	retu escape(pat, '~')
                            endf
                            " * BuildPrompt() {{{1
    1              0.000006 fu! s:Render(lines, pat)
                            	let [&ma, lines, s:res_count] = [1, a:lines, len(a:lines)]
                            	let height = min([max([s:mw_min, s:res_count]), s:winmaxh])
                            	let pat = s:byfname() ? split(a:pat, '^[^;]\+\\\@<!\zs;', 1)[0] : a:pat
                            	let cur_cmd = 'keepj norm! '.( s:mw_order == 'btt' ? 'G' : 'gg' ).'1|'
                            
                            	" Setup the match window
                            	sil! exe '%d _ | res' height
                            	" Print the new items
                            	if empty(lines)
                            		let [s:matched, s:lines] = [[], []]
                            		let lines = [' == NO ENTRIES ==']
                            		cal setline(1, s:offset(lines, height - 1))
                            		setl noma nocul
                            		exe cur_cmd
                            		cal s:unmarksigns()
                            		if s:dohighlight() | cal clearmatches() | en
                            		retu
                            	en
                            	let s:matched = copy(lines)
                            	" Sorting
                            	if !s:nosort()
                            		let s:compat = s:martcs.pat
                            		cal sort(lines, 's:mixedsort')
                            		unl s:compat
                            	en
                            	if s:mw_order == 'btt' | cal reverse(lines) | en
                            	let s:lines = copy(lines)
                            	cal map(lines, s:flfunc)
                            	cal setline(1, s:offset(lines, height))
                            	cal s:unmarksigns()
                            	cal s:remarksigns()
                            	" Highlighting
                            	if s:dohighlight()
                            		cal s:highlight(pat, s:mathi[1])
                            	en
                            	setl noma cul
                            	exe cur_cmd
                            endf
                            
    1              0.000005 fu! s:Update(str)
                            	" Get the previous string if existed
                            	let oldstr = exists('s:savestr') ? s:savestr : ''
                            	" Get the new string sans tail
                            	let str = s:sanstail(a:str)
                            	" Stop if the string's unchanged
                            	if str == oldstr && !empty(str) && !exists('s:force') | retu | en
                            	" Optionally send the string to a custom validate function
                            	if s:validate != '' | let str = call(s:validate, [str]) | en
                            	let s:martcs = &scs && str =~ '\u' ? '\C' : ''
                            	let pat = s:matcher == {} ? s:SplitPattern(str) : str
                            	let lines = s:nolim == 1 && empty(str) ? copy(g:ctrlp_lines)
                            		\ : s:MatchedItems(g:ctrlp_lines, pat, s:mw_res)
                            	if empty(str) | cal clearmatches() | en
                            	cal s:Render(lines, pat)
                            	return lines
                            endf
                            
    1              0.000005 fu! s:ForceUpdate()
                            	let pos = exists('*getcurpos') ? getcurpos() : getpos('.')
                            	sil! cal s:Update(escape(s:getinput(), '\'))
                            	cal setpos('.', pos)
                            endf
                            
    1              0.000006 fu! s:BuildPrompt(upd)
                            	let base = ( s:regexp ? 'r' : '>' ).( s:byfname() ? 'd' : '>' ).'> '
                            	let str = escape(s:getinput(), '\')
                            	let lazy = str == '' || exists('s:force') || !has('autocmd') ? 0 : s:lazy
                            	if a:upd && !lazy && ( s:matches || s:regexp || exists('s:did_exp')
                            		\ || str =~ '\(\\\(<\|>\)\|[*|]\)\|\(\\\:\([^:]\|\\:\)*$\)' )
                            		sil! cal s:Update(str)
                            	en
                            	sil! cal ctrlp#statusline()
                            	" Toggling
                            	let [hiactive, hicursor, base] = s:focus
                            		\ ? ['CtrlPPrtText', 'CtrlPPrtCursor', base]
                            		\ : ['CtrlPPrtBase', 'CtrlPPrtBase', tr(base, '>', '-')]
                            	let hibase = 'CtrlPPrtBase'
                            	" Build it
                            	redr
                            	let prt = copy(s:prompt)
                            	cal map(prt, 'escape(v:val, ''"\'')')
                            	exe 'echoh' hibase '| echon "'.base.'"
                            		\ | echoh' hiactive '| echon "'.prt[0].'"
                            		\ | echoh' hicursor '| echon "'.prt[1].'"
                            		\ | echoh' hiactive '| echon "'.prt[2].'" | echoh None'
                            	" Append the cursor at the end
                            	if empty(prt[1]) && s:focus
                            		exe 'echoh' hibase '| echon "_" | echoh None'
                            	en
                            endf
                            " - SetDefTxt() {{{1
    1              0.000006 fu! s:SetDefTxt()
                            	if s:deftxt == '0' || ( s:deftxt == 1 && !s:ispath ) | retu | en
                            	let txt = s:deftxt
                            	if !type(txt)
                            		let path = s:crfpath.s:lash(s:crfpath)
                            		let txt = txt && !stridx(path, s:dyncwd) ? ctrlp#rmbasedir([path])[0] : ''
                            	en
                            	let s:prompt[0] = txt
                            endf
                            " ** Prt Actions {{{1
                            " Editing {{{2
    1              0.000005 fu! s:PrtClear()
                            	if !s:focus | retu | en
                            	unl! s:hstgot
                            	let [s:prompt, s:matches] = [['', '', ''], 1]
                            	cal s:BuildPrompt(1)
                            endf
                            
    1              0.000005 fu! s:PrtAdd(char)
                            	unl! s:hstgot
                            	let s:act_add = 1
                            	let s:prompt[0] .= a:char
                            	cal s:BuildPrompt(1)
                            	unl s:act_add
                            endf
                            
    1              0.000004 fu! s:PrtBS()
                            	if !s:focus | retu | en
                            	if empty(s:prompt[0]) && s:brfprt != 0
                            		cal s:PrtExit()
                            		retu
                            	en
                            	unl! s:hstgot
                            	let [s:prompt[0], s:matches] = [substitute(s:prompt[0], '.$', '', ''), 1]
                            	cal s:BuildPrompt(1)
                            endf
                            
    1              0.000005 fu! s:PrtDelete()
                            	if !s:focus | retu | en
                            	unl! s:hstgot
                            	let [prt, s:matches] = [s:prompt, 1]
                            	let prt[1] = matchstr(prt[2], '^.')
                            	let prt[2] = substitute(prt[2], '^.', '', '')
                            	cal s:BuildPrompt(1)
                            endf
                            
    1              0.000005 fu! s:PrtDeleteWord()
                            	if !s:focus | retu | en
                            	unl! s:hstgot
                            	let [str, s:matches] = [s:prompt[0], 1]
                            	let str = str =~ '\W\w\+$' ? matchstr(str, '^.\+\W\ze\w\+$')
                            		\ : str =~ '\w\W\+$' ? matchstr(str, '^.\+\w\ze\W\+$')
                            		\ : str =~ '\s\+$' ? matchstr(str, '^.*\S\ze\s\+$')
                            		\ : str =~ '\v^(\S+|\s+)$' ? '' : str
                            	let s:prompt[0] = str
                            	cal s:BuildPrompt(1)
                            endf
                            
    1              0.000004 fu! s:PrtInsert(...)
                            	if !s:focus | retu | en
                            	let type = !a:0 ? '' : a:1
                            	if !a:0
                            		let type = s:insertstr()
                            		if type == 'cancel' | retu | en
                            	en
                            	if type ==# 'r'
                            		let regcont = s:getregs()
                            		if regcont < 0 | retu | en
                            	en
                            	unl! s:hstgot
                            	let s:act_add = 1
                            	let s:prompt[0] .= type ==# 'w' ? s:crword
                            		\ : type ==# 'f' ? s:crgfile
                            		\ : type ==# 's' ? s:regisfilter('/')
                            		\ : type ==# 'v' ? s:crvisual
                            		\ : type ==# 'c' ? s:regisfilter('+')
                            		\ : type ==# 'r' ? regcont : ''
                            	cal s:BuildPrompt(1)
                            	unl s:act_add
                            endf
                            
    1              0.000004 fu! s:PrtExpandDir()
                            	if !s:focus | retu | en
                            	let str = s:getinput('c')
                            	if str =~ '\v^\@(cd|lc[hd]?|chd)\s.+' && s:spi
                            		let hasat = split(str, '\v^\@(cd|lc[hd]?|chd)\s*\zs')
                            		let str = get(hasat, 1, '')
                            		if str =~# '\v^[~$]\i{-}[\/]?|^#(\<?\d+)?:(p|h|8|\~|\.|g?s+)'
                            			let str = expand(s:fnesc(str, 'g'))
                            		elsei str =~# '\v^(\%|\<c\h{4}\>):(p|h|8|\~|\.|g?s+)'
                            			let spc = str =~# '^%' ? s:crfile
                            				\ : str =~# '^<cfile>' ? s:crgfile
                            				\ : str =~# '^<cword>' ? s:crword
                            				\ : str =~# '^<cWORD>' ? s:crnbword : ''
                            			let pat = '(:(p|h|8|\~|\.|g?s(.)[^\3]*\3[^\3]*\3))+'
                            			let mdr = matchstr(str, '\v^[^:]+\zs'.pat)
                            			let nmd = matchstr(str, '\v^[^:]+'.pat.'\zs.{-}$')
                            			let str = fnamemodify(s:fnesc(spc, 'g'), mdr).nmd
                            		en
                            	en
                            	if str == '' | retu | en
                            	unl! s:hstgot
                            	let s:act_add = 1
                            	let [base, seed] = s:headntail(str)
                            	if str =~# '^[\/]'
                            		let base = expand('/').base
                            	en
                            	let dirs = s:dircompl(base, seed)
                            	if len(dirs) == 1
                            		let str = dirs[0]
                            	elsei len(dirs) > 1
                            		let str .= s:findcommon(dirs, str)
                            	en
                            	let s:prompt[0] = exists('hasat') ? hasat[0].str : str
                            	cal s:BuildPrompt(1)
                            	unl s:act_add
                            endf
                            " Movement {{{2
    1              0.000005 fu! s:PrtCurLeft()
                            	if !s:focus | retu | en
                            	let prt = s:prompt
                            	if !empty(prt[0])
                            		let s:prompt = [substitute(prt[0], '.$', '', ''), matchstr(prt[0], '.$'),
                            			\ prt[1] . prt[2]]
                            	en
                            	cal s:BuildPrompt(0)
                            endf
                            
    1              0.000005 fu! s:PrtCurRight()
                            	if !s:focus | retu | en
                            	let prt = s:prompt
                            	let s:prompt = [prt[0] . prt[1], matchstr(prt[2], '^.'),
                            		\ substitute(prt[2], '^.', '', '')]
                            	cal s:BuildPrompt(0)
                            endf
                            
    1              0.000005 fu! s:PrtCurStart()
                            	if !s:focus | retu | en
                            	let str = join(s:prompt, '')
                            	let s:prompt = ['', matchstr(str, '^.'), substitute(str, '^.', '', '')]
                            	cal s:BuildPrompt(0)
                            endf
                            
    1              0.000005 fu! s:PrtCurEnd()
                            	if !s:focus | retu | en
                            	let s:prompt = [join(s:prompt, ''), '', '']
                            	cal s:BuildPrompt(0)
                            endf
                            
    1              0.000006 fu! s:PrtSelectMove(dir)
                            	let wht = winheight(0)
                            	let dirs = {'t': 'gg','b': 'G','j': 'j','k': 'k','u': wht.'k','d': wht.'j'}
                            	exe 'keepj norm!' dirs[a:dir]
                            	let pos = exists('*getcurpos') ? getcurpos() : getpos('.')
                            	cal s:BuildPrompt(0)
                            	cal setpos('.', pos)
                            endf
                            
    1              0.000006 fu! s:PrtSelectJump(char)
                            	let lines = copy(s:lines)
                            	if s:byfname()
                            		cal map(lines, 'split(v:val, ''[\/]\ze[^\/]\+$'')[-1]')
                            	en
                            	" Cycle through matches, use s:jmpchr to store last jump
                            	let chr = escape(matchstr(a:char, '^.'), '.~')
                            	let smartcs = &scs && chr =~ '\u' ? '\C' : ''
                            	if match(lines, smartcs.'^'.chr) >= 0
                            		" If not exists or does but not for the same char
                            		let pos = match(lines, smartcs.'^'.chr)
                            		if !exists('s:jmpchr') || ( exists('s:jmpchr') && s:jmpchr[0] != chr )
                            			let [jmpln, s:jmpchr] = [pos, [chr, pos]]
                            		elsei exists('s:jmpchr') && s:jmpchr[0] == chr
                            			" Start of lines
                            			if s:jmpchr[1] == -1 | let s:jmpchr[1] = pos | en
                            			let npos = match(lines, smartcs.'^'.chr, s:jmpchr[1] + 1)
                            			let [jmpln, s:jmpchr] = [npos == -1 ? pos : npos, [chr, npos]]
                            		en
                            		exe 'keepj norm!' ( jmpln + 1 ).'G'
                            		let pos = exists('*getcurpos') ? getcurpos() : getpos('.')
                            		cal s:BuildPrompt(0)
                            		cal setpos('.', pos)
                            	en
                            endf
                            " Misc {{{2
    1              0.000022 fu! s:PrtFocusMap(char)
                            	cal call(( s:focus ? 's:PrtAdd' : 's:PrtSelectJump' ), [a:char])
                            endf
                            
    1              0.000004 fu! s:PrtClearCache()
                            	let ct = s:curtype()
                            	if ct == 'fil'
                            		cal ctrlp#clr()
                            	elsei s:itemtype >= len(s:coretypes)
                            		cal ctrlp#clr(s:statypes[s:itemtype][1])
                            	en
                            	if ct == 'mru'
                            		let g:ctrlp_lines = ctrlp#mrufiles#refresh()
                            	el
                            		cal ctrlp#setlines()
                            	en
                            	let s:force = 1
                            	cal s:BuildPrompt(1)
                            	unl s:force
                            endf
                            
    1              0.000005 fu! s:PrtDeleteEnt()
                            	let ct = s:curtype()
                            	if ct == 'mru'
                            		cal s:PrtDeleteMRU()
                            	elsei ct == 'buf'
                            		cal s:delbuf()
                            	elsei type(s:getextvar('wipe')) == 1
                            		cal s:delent(s:getextvar('wipe'))
                            	en
                            endf
                            
    1              0.000004 fu! s:PrtDeleteMRU()
                            	if s:curtype() == 'mru'
                            		cal s:delent('ctrlp#mrufiles#remove')
                            	en
                            endf
                            
    1              0.000005 fu! s:PrtExit()
                            	let bw = bufwinnr('%')
                            	exe bufwinnr(s:bufnr).'winc w'
                            	if bufnr('%') == s:bufnr && bufname('%') == 'ControlP'
                            		noa cal s:Close()
                            		noa winc p
                            	els
                            		exe bw.'winc w'
                            	en
                            endf
                            
    1              0.000005 fu! s:PrtHistory(...)
                            	if !s:focus || !s:maxhst | retu | en
                            	let [str, hst, s:matches] = [join(s:prompt, ''), s:hstry, 1]
                            	" Save to history if not saved before
                            	let [hst[0], hslen] = [exists('s:hstgot') ? hst[0] : str, len(hst)]
                            	let idx = exists('s:hisidx') ? s:hisidx + a:1 : a:1
                            	" Limit idx within 0 and hslen
                            	let idx = idx < 0 ? 0 : idx >= hslen ? hslen > 1 ? hslen - 1 : 0 : idx
                            	let s:prompt = [hst[idx], '', '']
                            	let [s:hisidx, s:hstgot, s:force] = [idx, 1, 1]
                            	cal s:BuildPrompt(1)
                            	unl s:force
                            endf
                            "}}}1
                            " * Mappings {{{1
    1              0.000005 fu! s:MapNorms()
                            	if exists('s:nmapped') && s:nmapped == s:bufnr | retu | en
                            	let pcmd = "nn \<buffer> \<silent> \<k%s> :\<c-u>cal \<SID>%s(\"%s\")\<cr>"
                            	let cmd = substitute(pcmd, 'k%s', 'char-%d', '')
                            	let pfunc = 'PrtFocusMap'
                            	let ranges = [32, 33, 125, 126] + range(35, 91) + range(93, 123)
                            	for each in [34, 92, 124]
                            		exe printf(cmd, each, pfunc, escape(nr2char(each), '"|\'))
                            	endfo
                            	for each in ranges
                            		exe printf(cmd, each, pfunc, nr2char(each))
                            	endfo
                            	for each in range(0, 9)
                            		exe printf(pcmd, each, pfunc, each)
                            	endfo
                            	for [ke, va] in items(s:kprange)
                            		exe printf(pcmd, ke, pfunc, va)
                            	endfo
                            	let s:nmapped = s:bufnr
                            endf
                            
    1              0.000004 fu! s:MapSpecs()
                            	if !( exists('s:smapped') && s:smapped == s:bufnr )
                            		" Correct arrow keys in terminal
                            		if ( has('termresponse') && v:termresponse =~ "\<ESC>" )
                            			\ || &term =~? '\vxterm|<k?vt|gnome|screen|linux|ansi|tmux|st(-[-a-z0-9]*)?$'
                            			for each in ['\A <up>','\B <down>','\C <right>','\D <left>']
                            				exe s:lcmap.' <esc>['.each
                            			endfo
                            		en
                            	en
                            	for [ke, va] in items(s:prtmaps) | for kp in va
                            		exe s:lcmap kp ':<c-u>cal <SID>'.ke.'<cr>'
                            	endfo | endfo
                            	let s:smapped = s:bufnr
                            endf
                            
    1              0.000005 fu! s:KeyLoop()
                            	let [t_ve, guicursor] = [&t_ve, &guicursor]
                            	wh exists('s:init') && s:keyloop
                            		try
                            			set t_ve=
                            			if guicursor != ''
                            				set guicursor=a:NONE
                            			en
                            			let nr = getchar()
                            		fina
                            			let &t_ve = t_ve
                            			let &guicursor = guicursor
                            		endt
                            		let chr = !type(nr) ? nr2char(nr) : nr
                            		if nr >=# 0x20
                            			cal s:PrtFocusMap(chr)
                            		el
                            			let cmd = matchstr(maparg(chr), ':<C-U>\zs.\+\ze<CR>$')
                            			try
                            				exe ( cmd != '' ? cmd : 'norm '.chr )
                            			cat
                            			endt
                            		en
                            	endw
                            endf
                            " * Toggling {{{1
    1              0.000006 fu! s:ToggleFocus()
                            	let s:focus = !s:focus
                            	cal s:BuildPrompt(0)
                            endf
                            
    1              0.000004 fu! s:ToggleRegex()
                            	let s:regexp = !s:regexp
                            	cal s:PrtSwitcher()
                            endf
                            
    1              0.000005 fu! s:ToggleByFname()
                            	if s:ispath
                            		let s:byfname = !s:byfname
                            		let s:mfunc = s:mfunc()
                            		cal s:PrtSwitcher()
                            	en
                            endf
                            
    1              0.000005 fu! s:ToggleType(dir)
                            	let max = len(g:ctrlp_ext_vars) + len(s:coretypes) - 1
                            	let next = s:walker(max, s:itemtype, a:dir)
                            	cal ctrlp#setlines(next)
                            	cal ctrlp#syntax()
                            	cal s:PrtSwitcher()
                            endf
                            
    1              0.000004 fu! s:ToggleKeyLoop()
                            	let s:keyloop = !s:keyloop
                            	if exists('+imd')
                            		let &imd = !s:keyloop
                            	en
                            	if s:keyloop
                            		let [&ut, s:lazy] = [0, 0]
                            		cal s:KeyLoop()
                            	elsei has_key(s:glbs, 'ut')
                            		let [&ut, s:lazy] = [s:glbs['ut'], 1]
                            	en
                            endf
                            
    1              0.000005 fu! s:ToggleMRURelative()
                            	cal ctrlp#mrufiles#tgrel()
                            	cal s:PrtClearCache()
                            endf
                            
    1              0.000005 fu! s:PrtSwitcher()
                            	let [s:force, s:matches] = [1, 1]
                            	cal s:BuildPrompt(1)
                            	unl s:force
                            endf
                            " - SetWD() {{{1
    1              0.000005 fu! s:SetWD(args)
                            	if has_key(a:args, 'args') && stridx(a:args['args'], '--dir') >= 0
                            		\ && exists('s:dyncwd')
                            		cal ctrlp#setdir(s:dyncwd) | retu
                            	en
                            	if has_key(a:args, 'dir') && a:args['dir'] != ''
                            		cal ctrlp#setdir(a:args['dir']) | retu
                            	en
                            	let pmodes = has_key(a:args, 'mode') ? a:args['mode'] : s:pathmode
                            	let [s:crfilerel, s:dyncwd] = [fnamemodify(s:crfile, ':.'), getcwd()]
                            	if (!type(pmodes))
                            		let pmodes =
                            			\ pmodes == 0 ? '' :
                            			\ pmodes == 1 ? 'a' :
                            			\ pmodes == 2 ? 'r' :
                            			\ 'c'
                            	en
                            	let spath = pmodes =~ 'd' ? s:dyncwd : pmodes =~ 'w' ? s:cwd : s:crfpath
                            	for pmode in split(pmodes, '\zs')
                            		if ctrlp#setpathmode(pmode, spath) | retu | en
                            	endfo
                            endf
                            " * AcceptSelection() {{{1
    1              0.000023 fu! ctrlp#acceptfile(...)
                            	let useb = 0
                            	if a:0 == 1 && type(a:1) == 4
                            		let [md, line] = [a:1['action'], a:1['line']]
                            		let atl = has_key(a:1, 'tail') ? a:1['tail'] : ''
                            	el
                            		let [md, line] = [a:1, a:2]
                            		let atl = a:0 > 2 ? a:3 : ''
                            	en
                            	if !type(line)
                            		let [filpath, bufnr, useb] = [line, line, 1]
                            	el
                            		let [bufnr, filpath] = s:bufnrfilpath(line)
                            		if bufnr == filpath
                            			let useb = 1
                            		en
                            	en
                            	cal s:PrtExit()
                            	let tail = s:tail()
                            	let j2l = atl != '' ? atl : matchstr(tail, '^ +\zs\d\+$')
                            	if bufnr > 0 && ( !empty(s:jmptobuf) && s:jmptobuf =~ md )
                            		\ && !( md == 'e' && bufnr == bufnr('%') )
                            		let [jmpb, bufwinnr] = [1, bufwinnr(bufnr)]
                            		let buftab = ( s:jmptobuf =~# '[tTVH]' || s:jmptobuf > 1 )
                            			\ ? s:buftab(bufnr, md) : [0, 0]
                            	en
                            	" Switch to existing buffer or open new one
                            	if exists('jmpb') && bufwinnr > 0
                            		\ && !( md == 't' && ( s:jmptobuf !~# toupper(md) || buftab[0] ) )
                            		exe bufwinnr.'winc w'
                            		if j2l | cal ctrlp#j2l(j2l) | en
                            	elsei exists('jmpb') && buftab[0]
                            		\ && !( md =~ '[evh]' && s:jmptobuf !~# toupper(md) )
                            		exe 'tabn' buftab[0]
                            		exe buftab[1].'winc w'
                            		if j2l | cal ctrlp#j2l(j2l) | en
                            	el
                            		" Determine the command to use
                            		let useb = bufnr > 0 && buflisted(bufnr) && ( empty(tail) || useb )
                            		let cmd =
                            			\ md == 't' || s:splitwin == 1 ? ( useb ? 'tab sb' : 'tabe' ) :
                            			\ md == 'h' || s:splitwin == 2 ? ( useb ? 'sb' : 'new' ) :
                            			\ md == 'v' || s:splitwin == 3 ? ( useb ? 'vert sb' : 'vne' ) :
                            			\ call('ctrlp#normcmd', useb ? ['b', 'bo vert sb'] : ['e'])
                            		" Reset &switchbuf option
                            		let [swb, &swb] = [&swb, '']
                            		" Open new window/buffer
                            		let [fid, tail] = [( useb ? bufnr : filpath ), ( atl != '' ? ' +'.atl : tail )]
                            		let args = [cmd, fid, tail, 1, [useb, j2l]]
                            		cal call('s:openfile', args)
                            		let &swb = swb
                            	en
                            endf
                            
    1              0.000006 fu! s:SpecInputs(str)
                            	if a:str =~ '\v^(\.\.([\/]\.\.)*[\/]?[.\/]*)$' && s:spi
                            		let cwd = s:dyncwd
                            		cal ctrlp#setdir(a:str =~ '^\.\.\.*$' ?
                            			\ '../'.repeat('../', strlen(a:str) - 2) : a:str)
                            		if cwd != s:dyncwd | cal ctrlp#setlines() | en
                            		cal s:PrtClear()
                            		retu 1
                            	elsei a:str == s:lash && s:spi
                            		cal s:SetWD({ 'mode': 'rd' })
                            		cal ctrlp#setlines()
                            		cal s:PrtClear()
                            		retu 1
                            	elsei a:str =~ '^@.\+' && s:spi
                            		retu s:at(a:str)
                            	elsei a:str == '?'
                            		cal s:PrtExit()
                            		let hlpwin = &columns > 159 ? '| vert res 80' : ''
                            		sil! exe 'bo vert h ctrlp-mappings' hlpwin '| norm! 0'
                            		retu 1
                            	en
                            	retu 0
                            endf
                            
    1              0.000007 fu! s:AcceptSelection(action)
                            	let [md, icr] = [a:action[0], match(a:action, 'r') >= 0]
                            	let subm = icr || ( !icr && md == 'e' )
                            	if !subm && s:OpenMulti(md) != -1 | retu | en
                            	let str = s:getinput()
                            	if subm | if s:SpecInputs(str) | retu | en | en
                            	" Get the selected line
                            	let line = ctrlp#getcline()
                            	if !subm && s:curtype() != 'fil' && line == '' && line('.') > s:offset
                            		\ && str !~ '\v^(\.\.([\/]\.\.)*[\/]?[.\/]*|/|\\|\?|\@.+)$'
                            		cal s:CreateNewFile(md) | retu
                            	en
                            	if empty(line) | retu | en
                            	" Do something with it
                            	if s:openfunc != {} && has_key(s:openfunc, s:ctype)
                            		let actfunc = s:openfunc[s:ctype]
                            		let type = has_key(s:openfunc, 'arg_type') ? s:openfunc['arg_type'] : 'list'
                            	el
                            		if s:itemtype < len(s:coretypes)
                            			let [actfunc, type] = ['ctrlp#acceptfile', 'dict']
                            		el
                            			let [actfunc, exttype] = [s:getextvar('accept'), s:getextvar('act_farg')]
                            			let type = exttype == 'dict' ? exttype : 'list'
                            		en
                            	en
                            	let actargs = type == 'dict' ? [{ 'action': md, 'line': line, 'icr': icr, 'input': str}]
                            		\ : [md, line]
                            	cal call(actfunc, actargs)
                            endf
                            " - CreateNewFile() {{{1
    1              0.000005 fu! s:CreateNewFile(...)
                            	let [md, str] = ['', s:getinput('n')]
                            	if empty(str) | retu | en
                            	if s:argmap && !a:0
                            		" Get the extra argument
                            		let md = s:argmaps(md, 1)
                            		if md == 'cancel' | retu | en
                            	en
                            	let str = s:sanstail(str)
                            	let [base, fname] = s:headntail(str)
                            	if fname =~ '^[\/]$' | retu | en
                            	if exists('s:marked') && len(s:marked)
                            		" Use the first marked file's path
                            		let path = fnamemodify(values(s:marked)[0], ':p:h')
                            		let base = path.s:lash(path).base
                            		let str = fnamemodify(base.s:lash.fname, ':.')
                            	en
                            	if base != '' | if isdirectory(ctrlp#utils#mkdir(base))
                            		let optyp = str | en | el | let optyp = fname
                            	en
                            	if !exists('optyp') | retu | en
                            	let [filpath, tail] = [fnamemodify(optyp, ':p'), s:tail()]
                            	if !stridx(filpath, s:dyncwd) | cal s:insertcache(str) | en
                            	cal s:PrtExit()
                            	let cmd = md == 'r' ? ctrlp#normcmd('e') :
                            		\ s:newfop =~ '1\|t' || ( a:0 && a:1 == 't' ) || md == 't' ? 'tabe' :
                            		\ s:newfop =~ '2\|h' || ( a:0 && a:1 == 'h' ) || md == 'h' ? 'new' :
                            		\ s:newfop =~ '3\|v' || ( a:0 && a:1 == 'v' ) || md == 'v' ? 'vne' :
                            		\ ctrlp#normcmd('e')
                            	cal s:openfile(cmd, filpath, tail, 1)
                            endf
                            " * OpenMulti() {{{1
    1              0.000005 fu! s:MarkToOpen()
                            	let ct = s:curtype()
                            	if s:bufnr <= 0 || s:opmul == '0'
                            		\ || ( s:itemtype >= len(s:coretypes) && s:getextvar('opmul') != 1 )
                            		retu
                            	en
                            	let line = ctrlp#getcline()
                            
                            	" Do not allow to mark modified or current buffer
                            	let bufnr = s:bufnrfilpath(line)[0]
                            	if (ct == 'buf' && s:delbufcond(bufnr))
                            		retu
                            	en
                            
                            	if empty(line) | retu | en
                            	let filpath = s:ispath ? fnamemodify(line, ':p') : line
                            	if exists('s:marked') && s:dictindex(s:marked, filpath) > 0
                            		" Unmark and remove the file from s:marked
                            		let key = s:dictindex(s:marked, filpath)
                            		cal remove(s:marked, key)
                            		if empty(s:marked) | unl s:marked | en
                            		if has('signs')
                            			exe 'sign unplace' key 'buffer='.s:bufnr
                            		en
                            	el
                            		" Add to s:marked and place a new sign
                            		if exists('s:marked')
                            			let vac = s:vacantdict(s:marked)
                            			let key = empty(vac) ? len(s:marked) + 1 : vac[0]
                            			let s:marked = extend(s:marked, { key : filpath })
                            		el
                            			let [key, s:marked] = [1, { 1 : filpath }]
                            		en
                            		if has('signs')
                            			exe 'sign place' key 'line='.line('.').' name=ctrlpmark buffer='.s:bufnr
                            		en
                            	en
                            	sil! cal ctrlp#statusline()
                            endf
                            
    1              0.000005 fu! s:OpenMulti(...)
                            	let has_marked = exists('s:marked')
                            	if ( !has_marked && a:0 ) || s:opmul == '0' || !s:ispath
                            		\ || ( s:itemtype >= len(s:coretypes) && s:getextvar('opmul') != 1 )
                            		retu -1
                            	en
                            	" Get the options
                            	let [nr, md] = [matchstr(s:opmul, '\d\+'), matchstr(s:opmul, '[thvi]')]
                            	let [ur, jf] = [s:opmul =~ 'r', s:opmul =~ 'j']
                            	let md = a:0 ? a:1 : ( md == '' ? 'v' : md )
                            	let nopt = exists('g:ctrlp_open_multiple_files')
                            	if !has_marked
                            		let line = ctrlp#getcline()
                            		if line == '' | retu | en
                            		let marked = { 1 : fnamemodify(line, ':p') }
                            		let [nr, ur, jf, nopt] = ['1', 0, 0, 1]
                            	en
                            	if ( s:argmap || !has_marked ) && !a:0
                            		let md = s:argmaps(md, !has_marked ? 2 : 0)
                            		if md == 'c'
                            			cal s:unmarksigns()
                            			unl! s:marked
                            			cal s:BuildPrompt(0)
                            		elsei !has_marked && md =~ '[axd]'
                            			retu s:OpenNoMarks(md, line)
                            		en
                            		if md =~ '\v^c(ancel)?$' | retu | en
                            		let nr = nr == '0' ? ( nopt ? '' : '1' ) : nr
                            		let ur = !has_marked && md == 'r' ? 1 : ur
                            	en
                            	let mkd = values(has_marked ? s:marked : marked)
                            	cal s:sanstail(join(s:prompt, ''))
                            	cal s:PrtExit()
                            	if nr == '0' || md == 'i'
                            		retu map(mkd, "s:openfile('bad', v:val, '', 0)")
                            	en
                            	let tail = s:tail()
                            	let [emptytail, bufnr] = [empty(tail), bufnr('^'.mkd[0].'$')]
                            	let useb = bufnr > 0 && buflisted(bufnr) && emptytail
                            	" Move to a replaceable window
                            	let ncmd = ( useb ? ['b', 'bo vert sb'] : ['e', 'bo vne'] )
                            		\ + ( ur ? [] : ['ignruw'] )
                            	let fst = call('ctrlp#normcmd', ncmd)
                            	" Check if the current window has a replaceable buffer
                            	let repabl = !( md == 't' && !ur ) && empty(bufname('%')) && empty(&l:ft)
                            	" Commands for the rest of the files
                            	let [ic, cmds] = [1, { 'v': ['vert sb', 'vne'], 'h': ['sb', 'new'],
                            		\ 't': ['tab sb', 'tabe'] }]
                            	let [swb, &swb] = [&swb, '']
                            	if md == 't' && ctrlp#tabcount() < tabpagenr()
                            		let s:tabct = ctrlp#tabcount()
                            	en
                            	" Open the files
                            	for va in mkd
                            		let bufnr = bufnr('^'.va.'$')
                            		if bufnr < 0 && getftype(va) == '' | con | en
                            		let useb = bufnr > 0 && buflisted(bufnr) && emptytail
                            		let snd = md != '' && has_key(cmds, md) ?
                            			\ ( useb ? cmds[md][0] : cmds[md][1] ) : ( useb ? 'vert sb' : 'vne' )
                            		let cmd = ic == 1 && ( !( !ur && fst =~ '^[eb]$' ) || repabl ) ? fst : snd
                            		let conds = [( nr != '' && nr > 1 && nr < ic ) || ( nr == '' && ic > 1 ),
                            			\ nr != '' && nr < ic]
                            		if conds[nopt]
                            			if !buflisted(bufnr) | cal s:openfile('bad', va, '', 0) | en
                            		el
                            			cal s:openfile(cmd, useb ? bufnr : va, tail, ic == 1)
                            			if jf | if ic == 1
                            				let crpos = [tabpagenr(), winnr()]
                            			el
                            				let crpos[0] += tabpagenr() <= crpos[0]
                            				let crpos[1] += winnr() <= crpos[1]
                            			en | en
                            			let ic += 1
                            		en
                            	endfo
                            	if jf && exists('crpos') && ic > 2
                            		exe ( md == 't' ? 'tabn '.crpos[0] : crpos[1].'winc w' )
                            	en
                            	let &swb = swb
                            	unl! s:tabct
                            endf
                            
    1              0.000005 fu! s:YankLine(...)
                            	let @" = s:getinput()
                            	let has_marked = exists('s:marked')
                            	if !has_marked
                            		let line = ctrlp#getcline()
                            		if line == '' | retu | en
                            		let marked = { 1 : fnamemodify(line, ':p') }
                            	en
                            	let @" = join(values(has_marked ? s:marked : marked), "\n")
                            	cal s:PrtExit()
                            endf
                            
    1              0.000006 fu! s:OpenNoMarks(md, line)
                            	if a:md == 'a'
                            		let [s:marked, key] = [{}, 1]
                            		for line in s:lines
                            			let s:marked = extend(s:marked, { key : fnamemodify(line, ':p') })
                            			let key += 1
                            		endfo
                            		cal s:remarksigns()
                            		cal s:BuildPrompt(0)
                            	elsei a:md == 'x'
                            		let type = has_key(s:openfunc, 'arg_type') ? s:openfunc['arg_type'] : 'dict'
                            		let argms = type == 'dict' ? [{ 'action': a:md, 'line': a:line }]
                            			\ : [a:md, a:line]
                            		cal call(s:openfunc[s:ctype], argms, s:openfunc)
                            	elsei a:md == 'd'
                            		let dir = fnamemodify(a:line, ':h')
                            		if isdirectory(dir)
                            			cal ctrlp#setdir(dir)
                            			cal ctrlp#switchtype(0)
                            			cal ctrlp#recordhist()
                            			cal s:PrtClear()
                            		en
                            	en
                            endf
                            " ** Helper functions {{{1
                            " Sorting {{{2
    1              0.000005 fu! ctrlp#complen(...)
                            	" By length
                            	let [len1, len2] = [strlen(a:1), strlen(a:2)]
                            	retu len1 == len2 ? 0 : len1 > len2 ? 1 : -1
                            endf
                            
    1              0.000005 fu! s:compmatlen(...)
                            	" By match length
                            	let mln1 = s:shortest(s:matchlens(a:1, s:compat))
                            	let mln2 = s:shortest(s:matchlens(a:2, s:compat))
                            	retu mln1 == mln2 ? 0 : mln1 > mln2 ? 1 : -1
                            endf
                            
    1              0.000005 fu! s:comptime(...)
                            	" By last modified time
                            	let [time1, time2] = [getftime(a:1), getftime(a:2)]
                            	retu time1 == time2 ? 0 : time1 < time2 ? 1 : -1
                            endf
                            
    1              0.000005 fu! s:compmreb(...)
                            	" By last entered time (bufnr)
                            	let [id1, id2] = [index(s:mrbs, a:1), index(s:mrbs, a:2)]
                            	if id1 == id2
                            		return 0
                            	endif
                            	if id1 < 0
                            		return 1
                            	endif
                            	if id2 < 0
                            		return -1
                            	endif
                            	return id1 > id2 ? 1 : -1
                            endf
                            
    1              0.000005 fu! s:compmref(...)
                            	" By last entered time (MRU)
                            	let [id1, id2] = [index(g:ctrlp_lines, a:1), index(g:ctrlp_lines, a:2)]
                            	retu id1 == id2 ? 0 : id1 > id2 ? 1 : -1
                            endf
                            
    1              0.000005 fu! s:comparent(...)
                            	" By same parent dir
                            	if !stridx(s:crfpath, s:dyncwd)
                            		let [as1, as2] = [s:dyncwd.s:lash().a:1, s:dyncwd.s:lash().a:2]
                            		let [loc1, loc2] = [s:getparent(as1), s:getparent(as2)]
                            		if loc1 == s:crfpath && loc2 != s:crfpath | retu -1 | en
                            		if loc2 == s:crfpath && loc1 != s:crfpath | retu 1  | en
                            		retu 0
                            	en
                            	retu 0
                            endf
                            
    1              0.000005 fu! s:compfnlen(...)
                            	" By filename length
                            	let len1 = strlen(split(a:1, s:lash)[-1])
                            	let len2 = strlen(split(a:2, s:lash)[-1])
                            	retu len1 == len2 ? 0 : len1 > len2 ? 1 : -1
                            endf
                            
    1              0.000006 fu! s:matchlens(str, pat, ...)
                            	if empty(a:pat) || index(['^', '$'], a:pat) >= 0 | retu {} | en
                            	let st   = a:0 ? a:1 : 0
                            	let lens = a:0 >= 2 ? a:2 : {}
                            	let nr   = a:0 >= 3 ? a:3 : 0
                            	if nr > 20 | retu {} | en
                            	if match(a:str, a:pat, st) >= 0
                            		let [mst, mnd] = [matchstr(a:str, a:pat, st), matchend(a:str, a:pat, st)]
                            		let lens = extend(lens, { nr : [strlen(mst), mst] })
                            		let lens = s:matchlens(a:str, a:pat, mnd, lens, nr + 1)
                            	en
                            	retu lens
                            endf
                            
    1              0.000005 fu! s:shortest(lens)
                            	retu min(map(values(a:lens), 'v:val[0]'))
                            endf
                            
    1              0.000005 fu! s:mixedsort(...)
                            	let ct = s:curtype()
                            	if ct == 'buf'
                            		let pat = '[\/]\?\[\d\+\*No Name\]$'
                            		if a:1 =~# pat && a:2 =~# pat | retu 0
                            		elsei a:1 =~# pat | retu 1
                            		elsei a:2 =~# pat | retu -1 | en
                            	en
                            	let [cln, cml] = [ctrlp#complen(a:1, a:2), s:compmatlen(a:1, a:2)]
                            	if s:ispath
                            		let ms = []
                            		if s:res_count < 21
                            			let ms += [s:compfnlen(a:1, a:2)]
                            			if ct !~ '^\(buf\|mru\)$' | let ms += [s:comptime(a:1, a:2)] | en
                            			if !s:itemtype | let ms += [s:comparent(a:1, a:2)] | en
                            		en
                            		if ct =~ '^\(buf\|mru\)$'
                            			let ms += [s:compmref(a:1, a:2)]
                            			let cln = cml ? cln : 0
                            		en
                            		let ms += [cml, 0, 0, 0]
                            		let mp = call('s:multipliers', ms[:3])
                            		retu cln + ms[0] * mp[0] + ms[1] * mp[1] + ms[2] * mp[2] + ms[3] * mp[3]
                            	en
                            	retu cln + cml * 2
                            endf
                            
    1              0.000005 fu! s:multipliers(...)
                            	let mp0 = !a:1 ? 0 : 2
                            	let mp1 = !a:2 ? 0 : 1 + ( !mp0 ? 1 : mp0 )
                            	let mp2 = !a:3 ? 0 : 1 + ( !( mp0 + mp1 ) ? 1 : ( mp0 + mp1 ) )
                            	let mp3 = !a:4 ? 0 : 1 + ( !( mp0 + mp1 + mp2 ) ? 1 : ( mp0 + mp1 + mp2 ) )
                            	retu [mp0, mp1, mp2, mp3]
                            endf
                            
    1              0.000005 fu! s:compval(...)
                            	retu a:1 - a:2
                            endf
                            " Statusline {{{2
    1              0.000004 fu! ctrlp#statusline()
                            	if !exists('s:statypes')
                            		let s:statypes = copy(s:coretypes)
                            		if !empty(g:ctrlp_ext_vars)
                            			cal map(copy(g:ctrlp_ext_vars),
                            				\ 'add(s:statypes, [ v:val["lname"], v:val["sname"] ])')
                            		en
                            	en
                            	let tps = s:statypes
                            	let max = len(tps) - 1
                            	let nxt = tps[s:walker(max, s:itemtype,  1)][1]
                            	let prv = tps[s:walker(max, s:itemtype, -1)][1]
                            	let s:ctype = tps[s:itemtype][0]
                            	let focus   = s:focus ? 'prt'  : 'win'
                            	let byfname = s:ispath ? s:byfname ? 'file' : 'path' : 'line'
                            	let marked  = s:opmul != '0' ?
                            		\ exists('s:marked') ? ' <'.s:dismrk().'>' : ' <->' : ''
                            	if s:status != {}
                            		let argms =
                            			\ has_key(s:status, 'arg_type') && s:status['arg_type'] == 'dict' ? [{
                            			\ 'focus':   focus,
                            			\ 'byfname': byfname,
                            			\ 'regex':   s:regexp,
                            			\ 'prev':    prv,
                            			\ 'item':    s:ctype,
                            			\ 'next':    nxt,
                            			\ 'marked':  marked,
                            			\ }] : [focus, byfname, s:regexp, prv, s:ctype, nxt, marked]
                            		let &l:stl = call(s:status['main'], argms, s:status)
                            	el
                            		let item    = '%#CtrlPMode1# '.s:ctype.' %*'
                            		let focus   = '%#CtrlPMode2# '.focus.' %*'
                            		let byfname = '%#CtrlPMode1# '.byfname.' %*'
                            		let regex   = s:regexp  ? '%#CtrlPMode2# regex %*' : ''
                            		let slider  = ' <'.prv.'>={'.item.'}=<'.nxt.'>'
                            		let dir     = ' %=%<%#CtrlPMode2# %{getcwd()} %*'
                            		let &l:stl  = focus.byfname.regex.slider.marked.dir
                            	en
                            endf
                            
    1              0.000005 fu! s:dismrk()
                            	retu has('signs') ? len(s:marked) :
                            		\ '%<'.join(values(map(copy(s:marked), 'split(v:val, "[\\/]")[-1]')), ', ')
                            endf
                            
    1              0.000005 fu! ctrlp#progress(enum, ...)
                            	if has('macunix') || has('mac') | sl 1m | en
                            	let txt = a:0 ? '(press ctrl-c to abort)' : ''
                            	if s:status != {}
                            		let argms = has_key(s:status, 'arg_type') && s:status['arg_type'] == 'dict'
                            			\ ? [{ 'str': a:enum }] : [a:enum]
                            		let &l:stl = call(s:status['prog'], argms, s:status)
                            	el
                            		let &l:stl = '%#CtrlPStats# '.a:enum.' %* '.txt.'%=%<%#CtrlPMode2# %{getcwd()} %*'
                            	en
                            	redraws
                            endf
                            " *** Paths {{{2
                            " Line formatting {{{3
    1              0.000005 fu! s:formatline(str)
                            	let str = a:str
                            	let ct = s:curtype()
                            	if ct == 'buf'
                            		let bufnr = s:bufnrfilpath(str)[0]
                            		let parts = s:bufparts(bufnr)
                            		let str = printf('%'.s:bufnr_width.'s', bufnr)
                            		if s:has_conceal
                            			let str .= printf(' %-13s %s%-36s',
                            				\ '<bi>'.parts[0].'</bi>',
                            				\ '<bn>'.parts[1], '{'.parts[2].'}</bn>')
                            			if (!empty(s:bufpath_mod))
                            				let str .= printf('  %s', '<bp>'.parts[3].'</bp>')
                            			en
                            		el
                            			let str .= printf(' %-5s %-30s',
                            				\ parts[0],
                            				\ parts[2])
                            			if (!empty(s:bufpath_mod))
                            				let str .= printf('  %s', parts[3])
                            			en
                            		en
                            	en
                            	let cond = ct != 'buf' &&s:ispath && ( s:winw - 4 ) < s:strwidth(str)
                            	retu s:lineprefix.( cond ? s:pathshorten(str) : str )
                            endf
                            
    1              0.000006 fu! s:pathshorten(str)
                            	retu matchstr(a:str, '^.\{9}').'...'
                            		\ .matchstr(a:str, '.\{'.( s:winw - 16 ).'}$')
                            endf
                            
    1              0.000006 fu! s:offset(lines, height)
                            	let s:offset = s:mw_order == 'btt' ? ( a:height - s:res_count ) : 0
                            	retu s:offset > 0 ? ( repeat([''], s:offset) + a:lines ) : a:lines
                            endf
                            " Directory completion {{{3
    1              0.000005 fu! s:dircompl(be, sd)
                            	if a:sd == '' | retu [] | en
                            	if a:be == ''
                            		let [be, sd] = [s:dyncwd, a:sd]
                            	el
                            		let be = a:be.s:lash(a:be)
                            		let sd = be.a:sd
                            	en
                            	let dirs = split(globpath(s:fnesc(be, 'g', ','), a:sd.'*/'), "\n")
                            	if a:be == ''
                            		let dirs = ctrlp#rmbasedir(dirs)
                            	en
                            	cal filter(dirs, '!match(v:val, escape(sd, ''~$.\''))'
                            		\ . ' && v:val !~ ''\v(^|[\/])\.{1,2}[\/]$''')
                            	retu dirs
                            endf
                            
    1              0.000008 fu! s:findcommon(items, seed)
                            	let [items, id, cmn, ic] = [copy(a:items), strlen(a:seed), '', 0]
                            	cal map(items, 'strpart(v:val, id)')
                            	for char in split(items[0], '\zs')
                            		for item in items[1:]
                            			if item[ic] != char | let brk = 1 | brea | en
                            		endfo
                            		if exists('brk') | brea | en
                            		let cmn .= char
                            		let ic += 1
                            	endfo
                            	retu cmn
                            endf
                            " Misc {{{3
    1              0.000005 fu! s:headntail(str)
                            	let parts = split(a:str, '[\/]\ze[^\/]\+[\/:]\?$')
                            	retu len(parts) == 1 ? ['', parts[0]] : len(parts) == 2 ? parts : []
                            endf
                            
    1              0.000004 fu! s:lash(...)
                            	retu ( a:0 ? a:1 : s:dyncwd ) !~ '[\/]$' ? s:lash : ''
                            endf
                            
    1              0.000004 fu! s:ispathitem()
                            	retu s:itemtype < len(s:coretypes) || s:getextvar('type') == 'path'
                            endf
                            
    1              0.000005 fu! ctrlp#igncwd(cwd)
                            	retu ctrlp#utils#glob(a:cwd, 0) == '' ||
                            		\ ( s:igntype >= 0 && s:usrign(a:cwd, getftype(a:cwd)) )
                            endf
                            
    1              0.000005 fu! ctrlp#dirnfile(entries)
                            	let [items, cwd] = [[[], []], s:dyncwd.s:lash()]
                            	for each in a:entries
                            		let etype = getftype(each)
                            		if s:igntype >= 0 && s:usrign(each, etype) | con | en
                            		if etype == 'dir'
                            			if s:showhidden | if each !~ '[\/]\.\{1,2}$'
                            				cal add(items[0], each)
                            			en | el
                            				cal add(items[0], each)
                            			en
                            		elsei etype == 'link'
                            			if s:folsym
                            				let isfile = !isdirectory(each)
                            				if s:folsym == 2 || !s:samerootsyml(each, isfile, cwd)
                            					cal add(items[isfile], each)
                            				en
                            			en
                            		elsei etype == 'file'
                            			cal add(items[1], each)
                            		en
                            	endfo
                            	retu items
                            endf
                            
    1              0.000006 fu! s:usrign(item, type)
                            	if s:igntype == 1 | retu a:item =~ s:usrign | en
                            	if s:igntype == 2
                            		if call(s:usrign, [a:item, a:type])
                            			retu 1
                            		en
                            	elsei s:igntype == 4
                            		if has_key(s:usrign, a:type) && s:usrign[a:type] != ''
                            					\ && a:item =~ s:usrign[a:type]
                            			retu 1
                            		elsei has_key(s:usrign, 'func') && s:usrign['func'] != ''
                            					\ && call(s:usrign['func'], [a:item, a:type])
                            			retu 1
                            		en
                            	en
                            	retu 0
                            endf
                            
    1              0.000012 fu! s:samerootsyml(each, isfile, cwd)
                            	let resolve = fnamemodify(resolve(a:each), ':p:h')
                            	let resolve .= s:lash(resolve)
                            	retu !( stridx(resolve, a:cwd) && ( stridx(a:cwd, resolve) || a:isfile ) )
                            endf
                            
    1              0.000005 fu! ctrlp#rmbasedir(items)
                            	if a:items == []
                            		retu a:items
                            	en
                            	let cwd = s:dyncwd.s:lash()
                            	let first = a:items[0]
                            	if has('win32') || has('win64')
                            		let cwd = tr(cwd, '\', '/')
                            		let first = tr(first, '\', '/')
                            	en
                            	if !stridx(first, cwd)
                            		let idx = strlen(cwd)
                            		retu map(a:items, 'strpart(v:val, idx)')
                            	en
                            	retu a:items
                            endf
                            " Working directory {{{3
    1              0.000006 fu! s:getparent(item)
                            	let parent = substitute(a:item, '[\/][^\/]\+[\/:]\?$', '', '')
                            	if parent == '' || parent !~ '[\/]'
                            		let parent .= s:lash
                            	en
                            	retu parent
                            endf
                            
    1              0.000007 fu! s:findroot(curr, mark, depth, type)
                            	let [depth, fnd] = [a:depth + 1, 0]
                            	if type(a:mark) == 1
                            		let fnd = s:glbpath(s:fnesc(a:curr, 'g', ','), a:mark, 1) != ''
                            	elsei type(a:mark) == 3
                            		for markr in a:mark
                            			if s:glbpath(s:fnesc(a:curr, 'g', ','), markr, 1) != ''
                            				let fnd = 1
                            				brea
                            			en
                            		endfo
                            	en
                            	if fnd
                            		if !a:type | cal ctrlp#setdir(a:curr) | en
                            		retu [exists('markr') ? markr : a:mark, a:curr]
                            	elsei depth > s:maxdepth
                            		cal ctrlp#setdir(s:cwd)
                            	el
                            		let parent = s:getparent(a:curr)
                            		if parent != a:curr
                            			retu s:findroot(parent, a:mark, depth, a:type)
                            		en
                            	en
                            	retu []
                            endf
                            
    1              0.000005 fu! ctrlp#setpathmode(pmode, ...)
                            	if a:pmode == 'c' || ( a:pmode == 'a' && stridx(s:crfpath, s:cwd) < 0 )
                            		if exists('+acd') | let [s:glb_acd, &acd] = [&acd, 0] | en
                            		cal ctrlp#setdir(s:crfpath)
                            		retu 1
                            	elsei a:pmode == 'r'
                            		let spath = a:0 ? a:1 : s:crfpath
                            		let markers = ['.git', '.hg', '.svn', '.bzr', '_darcs']
                            		if type(s:rmarkers) == 3 && !empty(s:rmarkers)
                            			if s:findroot(spath, s:rmarkers, 0, 0) != [] | retu 1 | en
                            			cal filter(markers, 'index(s:rmarkers, v:val) < 0')
                            			let markers = s:rmarkers + markers
                            		en
                            		if s:findroot(spath, markers, 0, 0) != [] | retu 1 | en
                            	en
                            	retu 0
                            endf
                            
    1              0.000005 fu! ctrlp#setdir(path, ...)
                            	let cmd = a:0 ? a:1 : 'lc!'
                            	sil! exe cmd s:fnesc(a:path, 'c')
                            	let [s:crfilerel, s:dyncwd] = [fnamemodify(s:crfile, ':.'), getcwd()]
                            endf
                            " Fallbacks {{{3
    1              0.000005 fu! s:glbpath(...)
                            	retu call('ctrlp#utils#globpath', a:000)
                            endf
                            
    1              0.000005 fu! s:fnesc(...)
                            	retu call('ctrlp#utils#fnesc', a:000)
                            endf
                            
    1              0.000004 fu! ctrlp#setlcdir()
                            	if exists('*haslocaldir')
                            		cal ctrlp#setdir(getcwd(), haslocaldir() ? 'lc!' : 'cd!')
                            	en
                            endf
                            " Highlighting {{{2
    1              0.000004 fu! ctrlp#syntax()
                            	if ctrlp#nosy() | retu | en
                            	for [ke, va] in items(s:hlgrps) | cal ctrlp#hicheck('CtrlP'.ke, va) | endfo
                            	let bgColor=synIDattr(synIDtrans(hlID('Normal')), 'bg')
                            	if bgColor !~ '^-1$\|^$'
                            		sil! exe 'hi CtrlPLinePre guifg='.bgColor.' ctermfg='.bgColor
                            	en
                            	sy match CtrlPNoEntries '^ == NO ENTRIES ==$'
                            	if hlexists('CtrlPLinePre')
                            		exe "sy match CtrlPLinePre '^".escape(get(g:, 'ctrlp_line_prefix', '>'),'^$.*~\')."'"
                            	en
                            
                            	if s:curtype() == 'buf' && s:has_conceal
                            		sy region CtrlPBufferNr     matchgroup=CtrlPLinePre start='^>\s\+' end='\s'
                            		sy region CtrlPBufferInd    concealends matchgroup=Ignore start='<bi>' end='</bi>'
                            		sy region CtrlPBufferRegion concealends matchgroup=Ignore start='<bn>' end='</bn>'
                            			\ contains=CtrlPBufferHid,CtrlPBufferHidMod,CtrlPBufferVis,CtrlPBufferVisMod,CtrlPBufferCur,CtrlPBufferCurMod
                            		sy region CtrlPBufferHid    concealends matchgroup=Ignore     start='\s*{' end='}' contained
                            		sy region CtrlPBufferHidMod concealends matchgroup=Ignore    start='+\s*{' end='}' contained
                            		sy region CtrlPBufferVis    concealends matchgroup=Ignore   start='\*\s*{' end='}' contained
                            		sy region CtrlPBufferVisMod concealends matchgroup=Ignore  start='\*+\s*{' end='}' contained
                            		sy region CtrlPBufferCur    concealends matchgroup=Ignore  start='\*!\s*{' end='}' contained
                            		sy region CtrlPBufferCurMod concealends matchgroup=Ignore start='\*+!\s*{' end='}' contained
                            		sy region CtrlPBufferPath   concealends matchgroup=Ignore start='<bp>' end='</bp>'
                            	en
                            endf
                            
    1              0.000005 fu! s:highlight(pat, grp)
                            	if s:matcher != {} | retu | en
                            	cal clearmatches()
                            	if !empty(a:pat) && s:ispath
                            		if s:regexp
                            			let pat = substitute(a:pat, '\\\@<!\^', '^> \\zs', 'g')
                            			cal matchadd(a:grp, ( s:martcs == '' ? '\c' : '\C' ).pat)
                            		el
                            			let pat = a:pat
                            
                            			" get original characters so we can rebuild pat
                            			let chars = split(pat, '\[\^\\\?.\]\\{-}')
                            
                            			" Build a pattern like /a.*b.*c/ from abc (but with .\{-} non-greedy
                            			" matchers instead)
                            			let pat = join(chars, '.\{-}')
                            			" Ensure we match the last version of our pattern
                            			let ending = '\(.*'.pat.'\)\@!'
                            			" Case sensitive?
                            			let beginning = ( s:martcs == '' ? '\c' : '\C' ).'^.*'
                            			if s:byfname()
                            				" Make sure there are no slashes in our match
                            				let beginning = beginning.'\([^\/]*$\)\@='
                            			en
                            
                            			for i in range(len(chars))
                            				" Surround our current target letter with \zs and \ze so it only
                            				" actually matches that one letter, but has all preceding and trailing
                            				" letters as well.
                            				" \zsa.*b.*c
                            				" a\(\zsb\|.*\zsb)\ze.*c
                            				let charcopy = copy(chars)
                            				if i == 0
                            					let charcopy[i] = '\zs'.charcopy[i].'\ze'
                            					let middle = join(charcopy, '.\{-}')
                            				el
                            					let before = join(charcopy[0:i-1], '.\{-}')
                            					let after = join(charcopy[i+1:-1], '.\{-}')
                            					let c = charcopy[i]
                            					" for abc, match either ab.\{-}c or a.*b.\{-}c in that order
                            					let cpat = '\(\zs'.c.'\|'.'.*\zs'.c.'\)\ze.*'
                            					let middle = before.cpat.after
                            				en
                            
                            				" Now we matchadd for each letter, the basic form being:
                            				" ^.*\zsx\ze.*$, but with our pattern we built above for the letter,
                            				" and a negative lookahead ensuring that we only highlight the last
                            				" occurrence of our letters. We also ensure that our matcher is case
                            				" insensitive or sensitive depending.
                            				cal matchadd(a:grp, beginning.middle.ending)
                            			endfo
                            		en
                            
                            		cal matchadd('CtrlPLinePre', '^>')
                            	elseif !empty(a:pat) && s:regexp &&
                            				\ exists('g:ctrlp_regex_always_higlight') &&
                            				\ g:ctrlp_regex_always_higlight
                            		let pat = substitute(a:pat, '\\\@<!\^', '^> \\zs', 'g')
                            		cal matchadd(a:grp, ( s:martcs == '' ? '\c' : '\C').pat)
                            	en
                            endf
                            
    1              0.000005 fu! s:dohighlight()
                            	retu s:mathi[0] && exists('*clearmatches') && !ctrlp#nosy()
                            endf
                            " Prompt history {{{2
    1              0.000004 fu! s:gethistloc()
                            	let utilcadir = ctrlp#utils#cachedir()
                            	let cache_dir = utilcadir.s:lash(utilcadir).'hist'
                            	retu [cache_dir, cache_dir.s:lash(cache_dir).'cache.txt']
                            endf
                            
    1              0.000005 fu! s:gethistdata()
                            	retu ctrlp#utils#readfile(s:gethistloc()[1])
                            endf
                            
    1              0.000005 fu! ctrlp#recordhist()
                            	let str = join(s:prompt, '')
                            	if empty(str) || !s:maxhst | retu | en
                            	let hst = s:hstry
                            	if len(hst) > 1 && hst[1] == str | retu | en
                            	cal extend(hst, [str], 1)
                            	if len(hst) > s:maxhst | cal remove(hst, s:maxhst, -1) | en
                            	cal ctrlp#utils#writecache(hst, s:gethistloc()[0], s:gethistloc()[1])
                            endf
                            " Signs {{{2
    1              0.000004 fu! s:unmarksigns()
                            	if !s:dosigns() | retu | en
                            	for key in keys(s:marked)
                            		exe 'sign unplace' key 'buffer='.s:bufnr
                            	endfo
                            endf
                            
    1              0.000004 fu! s:remarksigns()
                            	if !s:dosigns() | retu | en
                            	for ic in range(1, len(s:lines))
                            		let line = s:ispath ? fnamemodify(s:lines[ic - 1], ':p') : s:lines[ic - 1]
                            		let key = s:dictindex(s:marked, line)
                            		if key > 0
                            			exe 'sign place' key 'line='.ic.' name=ctrlpmark buffer='.s:bufnr
                            		en
                            	endfo
                            endf
                            
    1              0.000005 fu! s:dosigns()
                            	retu exists('s:marked') && s:bufnr > 0 && s:opmul != '0' && has('signs')
                            endf
                            " Lists & Dictionaries {{{2
    1              0.000006 fu! s:ifilter(list, str)
                            	let [rlist, estr] = [[], substitute(a:str, 'v:val', 'each', 'g')]
                            	for each in a:list
                            		try
                            			if eval(estr)
                            				cal add(rlist, each)
                            			en
                            		cat | con | endt
                            	endfo
                            	retu rlist
                            endf
                            
    1              0.000006 fu! s:dictindex(dict, expr)
                            	for key in keys(a:dict)
                            		if a:dict[key] ==# a:expr | retu key | en
                            	endfo
                            	retu -1
                            endf
                            
    1              0.000005 fu! s:vacantdict(dict)
                            	retu filter(range(1, max(keys(a:dict))), '!has_key(a:dict, v:val)')
                            endf
                            
    1              0.000005 fu! s:sublist(l, s, e)
                            	retu v:version > 701 ? a:l[(a:s):(a:e)] : s:sublist7071(a:l, a:s, a:e)
                            endf
                            
    1              0.000006 fu! s:sublist7071(l, s, e)
                            	let [newlist, id, ae] = [[], a:s, a:e == -1 ? len(a:l) - 1 : a:e]
                            	wh id <= ae
                            		cal add(newlist, get(a:l, id))
                            		let id += 1
                            	endw
                            	retu newlist
                            endf
                            " Buffers {{{2
    1              0.000005 fu! s:buftab(bufnr, md)
                            	for tabnr in range(1, tabpagenr('$'))
                            		if tabpagenr() == tabnr && a:md == 't' | con | en
                            		let buflist = tabpagebuflist(tabnr)
                            		if index(buflist, a:bufnr) >= 0
                            			for winnr in range(1, tabpagewinnr(tabnr, '$'))
                            				if buflist[winnr - 1] == a:bufnr | retu [tabnr, winnr] | en
                            			endfo
                            		en
                            	endfo
                            	retu [0, 0]
                            endf
                            
    1              0.000005 fu! s:bufwins(bufnr)
                            	let winns = 0
                            	for tabnr in range(1, tabpagenr('$'))
                            		let winns += count(tabpagebuflist(tabnr), a:bufnr)
                            	endfo
                            	retu winns
                            endf
                            
    1              0.000005 fu! s:isabs(path)
                            	if (has('win32') || has('win64'))
                            		return a:path =~ '^\([a-zA-Z]:\)\{-}[/\\]'
                            	el
                            		return a:path =~ '^[/\\]'
                            	en
                            endf
                            
    1              0.000005 fu! s:bufnrfilpath(line)
                              if s:isabs(a:line) || a:line =~ '^\~[/\\]' || a:line =~ '^\w\+:\/\/'
                            		let filpath = a:line
                            	el
                            		let filpath = s:dyncwd.s:lash().a:line
                            	en
                            	let filpath = fnamemodify(filpath, ':p')
                            	let bufnr = bufnr('^'.filpath.'$')
                            	if (!filereadable(filpath) && bufnr < 1)
                            		if (a:line =~ '[\/]\?\[\d\+\*No Name\]$')
                            			let bufnr = str2nr(matchstr(a:line, '[\/]\?\[\zs\d\+\ze\*No Name\]$'))
                            			let filpath = bufnr
                            		els
                            			let bufnr = bufnr(a:line)
                            			retu [bufnr, a:line]
                            		en
                            	en
                            	retu [bufnr, filpath]
                            endf
                            
    1              0.000005 fu! ctrlp#normcmd(cmd, ...)
                            	let buftypes = [ 'quickfix', 'help', 'nofile' ]
                            	if a:0 < 2 && s:nosplit() | retu a:cmd | en
                            	let norwins = filter(range(1, winnr('$')),
                            		\ 'index(buftypes, getbufvar(winbufnr(v:val), "&bt")) == -1 || s:isterminal(winbufnr(v:val))')
                            	for each in norwins
                            		let bufnr = winbufnr(each)
                            		if empty(bufname(bufnr)) && empty(getbufvar(bufnr, '&ft'))
                            			let fstemp = each | brea
                            		en
                            	endfo
                            	let norwin = empty(norwins) ? 0 : norwins[0]
                            	if norwin
                            		if index(norwins, winnr()) < 0
                            			exe ( exists('fstemp') ? fstemp : norwin ).'winc w'
                            		en
                            		retu a:cmd
                            	en
                            	retu a:0 ? a:1 : 'bo vne'
                            endf
                            
    1              0.000005 fu! ctrlp#modfilecond(w)
                            	retu &mod && !&hid && &bh != 'hide' && s:bufwins(bufnr('%')) == 1 && !&cf &&
                            		\ ( ( !&awa && a:w ) || filewritable(fnamemodify(bufname('%'), ':p')) != 1 )
                            endf
                            
    1              0.000004 fu! s:nosplit()
                            	retu !empty(s:nosplit) && match([bufname('%'), &l:ft, &l:bt], s:nosplit) >= 0
                            endf
                            
    1              0.000005 fu! s:setupblank()
                            	setl noswf nonu nobl nowrap nolist nospell nocuc wfh
                            	setl fdc=0 fdl=99 tw=0 bt=nofile bh=unload
                            	if v:version > 702
                            		setl nornu noudf cc=0
                            	en
                            	if s:has_conceal
                            		setl cole=2 cocu=nc
                            	en
                            endf
                            
    1              0.000005 fu! s:leavepre()
                            	if exists('s:bufnr') && s:bufnr == bufnr('%') | bw! | en
                            	if !( exists(s:ccex) && !{s:ccex} )
                            		\ && !( has('clientserver') && len(split(serverlist(), "\n")) > 1 )
                            		cal ctrlp#clra()
                            	en
                            endf
                            
    1              0.000005 fu! s:checkbuf()
                            	if !exists('s:init') && exists('s:bufnr') && s:bufnr > 0
                            		exe s:bufnr.'bw!'
                            	en
                            endf
                            
    1              0.000004 fu! s:iscmdwin()
                            	let [ermsg, v:errmsg] = [v:errmsg, '']
                            	sil! noa winc p
                            	sil! noa winc p
                            	let [v:errmsg, ermsg] = [ermsg, v:errmsg]
                            	retu ermsg =~ '^E11:'
                            endf
                            " Arguments {{{2
    1              0.000004 fu! s:at(str)
                            	if a:str =~ '\v^\@(cd|lc[hd]?|chd).*'
                            		let str = substitute(a:str, '\v^\@(cd|lc[hd]?|chd)\s*', '', '')
                            		if str == '' | retu 1 | en
                            		let str = str =~ '^%:.\+' ? fnamemodify(s:crfile, str[1:]) : str
                            		let path = fnamemodify(expand(str, 1), ':p')
                            		if isdirectory(path)
                            			if path != s:dyncwd
                            				cal ctrlp#setdir(path)
                            				cal ctrlp#setlines()
                            			en
                            			cal ctrlp#recordhist()
                            			cal s:PrtClear()
                            		en
                            		retu 1
                            	en
                            	retu 0
                            endf
                            
    1              0.000005 fu! s:tail()
                            	if exists('s:optail') && !empty('s:optail')
                            		let tailpref = s:optail !~ '^\s*+' ? ' +' : ' '
                            		retu tailpref.s:optail
                            	en
                            	retu ''
                            endf
                            
    1              0.000005 fu! s:sanstail(str)
                            	let str = s:spi ?
                            		\ substitute(a:str, '^\(@.*$\|\\\\\ze@\|\.\.\zs[.\/]\+$\)', '', 'g') : a:str
                            	let [str, pat] = [substitute(str, '\\\\', '\', 'g'), '\([^:]\|\\:\)*$']
                            	unl! s:optail
                            	if str =~ '\\\@<!:'.pat
                            		let s:optail = matchstr(str, '\\\@<!:\zs'.pat)
                            		let str = substitute(str, '\\\@<!:'.pat, '', '')
                            	en
                            	retu substitute(str, '\\\ze:', '', 'g')
                            endf
                            
    1              0.000005 fu! s:argmaps(md, i)
                            	let roh = [
                            		\ ['Open Multiple Files', '/h[i]dden/[c]lear', ['i', 'c']],
                            		\ ['Create a New File', '/[r]eplace', ['r']],
                            		\ ['Open Selected', '/[r]eplace', ['r', 'd', 'a']],
                            		\ ]
                            	if a:i == 2
                            		if !buflisted(bufnr('^'.fnamemodify(ctrlp#getcline(), ':p').'$'))
                            			let roh[2][1] .= '/h[i]dden'
                            			let roh[2][2] += ['i']
                            		en
                            		if s:openfunc != {} && has_key(s:openfunc, s:ctype)
                            			let roh[2][1] .= '/e[x]ternal'
                            			let roh[2][2] += ['x']
                            		en
                            	en
                            	let str = roh[a:i][0].': [t]ab/[v]ertical/[h]orizontal'.roh[a:i][1].'? '
                            	retu s:choices(str, ['t', 'v', 'h'] + roh[a:i][2], 's:argmaps', [a:md, a:i])
                            endf
                            
    1              0.000005 fu! s:insertstr()
                            	let str = 'Insert: c[w]ord/c[f]ile/[s]earch/[v]isual/[c]lipboard/[r]egister? '
                            	retu s:choices(str, ['w', 'f', 's', 'v', 'c', 'r'], 's:insertstr', [])
                            endf
                            
    1              0.000006 fu! s:textdialog(str)
                            	redr | echoh MoreMsg | echon a:str | echoh None
                            	retu nr2char(getchar())
                            endf
                            
    1              0.000007 fu! s:choices(str, choices, func, args)
                            	let char = s:textdialog(a:str)
                            	if index(a:choices, char) >= 0
                            		retu char
                            	elsei char =~# "\\v\<Esc>|\<C-c>|\<C-g>|\<C-u>|\<C-w>|\<C-[>"
                            		cal s:BuildPrompt(0)
                            		retu 'cancel'
                            	elsei char =~# "\<CR>" && a:args != []
                            		retu a:args[0]
                            	en
                            	retu call(a:func, a:args)
                            endf
                            
    1              0.000004 fu! s:getregs()
                            	let char = s:textdialog('Insert from register: ')
                            	if char =~# "\\v\<Esc>|\<C-c>|\<C-g>|\<C-u>|\<C-w>|\<C-[>"
                            		cal s:BuildPrompt(0)
                            		retu -1
                            	elsei char =~# "\<CR>"
                            		retu s:getregs()
                            	en
                            	retu s:regisfilter(char)
                            endf
                            
    1              0.000005 fu! s:regisfilter(reg)
                            	retu substitute(getreg(a:reg), "[\t\n]", ' ', 'g')
                            endf
                            " Misc {{{2
    1              0.000004 fu! s:modevar()
                            	let s:matchtype = s:mtype()
                            	let s:ispath = s:ispathitem()
                            	let s:mfunc = s:mfunc()
                            	let s:nolim = s:getextvar('nolim')
                            	let s:dosort = s:getextvar('sort')
                            	let s:spi = !s:itemtype || s:getextvar('specinput') > 0
                            endf
                            
    1              0.000005 fu! s:nosort()
                            	let ct = s:curtype()
                            	retu s:matcher != {} || s:nolim == 1 || ( ct == 'mru' && s:mrudef )
                            		\ || ( ct =~ '^\(buf\|mru\)$' && s:prompt == ['', '', ''] ) || !s:dosort
                            endf
                            
    1              0.000004 fu! s:byfname()
                            	retu s:curtype() != 'buf' && s:ispath && s:byfname
                            endf
                            
    1              0.000004 fu! s:narrowable()
                            	retu exists('s:act_add') && exists('s:matched') && s:matched != []
                            		\ && exists('s:mdata') && s:mdata[:2] == [s:dyncwd, s:itemtype, s:regexp]
                            		\ && s:matcher == {} && !exists('s:did_exp')
                            endf
                            
    1              0.000005 fu! s:getinput(...)
                            	let [prt, spi] = [s:prompt, ( a:0 ? a:1 : '' )]
                            	if s:abbrev != {}
                            		let gmd = has_key(s:abbrev, 'gmode') ? s:abbrev['gmode'] : ''
                            		let str = ( gmd =~ 't' && !a:0 ) || spi == 'c' ? prt[0] : join(prt, '')
                            		if gmd =~ 't' && gmd =~ 'k' && !a:0 && matchstr(str, '.$') =~ '\k'
                            			retu join(prt, '')
                            		en
                            		let [pf, rz] = [( s:byfname() ? 'f' : 'p' ), ( s:regexp ? 'r' : 'z' )]
                            		for dict in s:abbrev['abbrevs']
                            			let dmd = has_key(dict, 'mode') ? dict['mode'] : ''
                            			let pat = escape(dict['pattern'], '~')
                            			if ( dmd == '' || ( dmd =~ pf && dmd =~ rz && !a:0 )
                            				\ || dmd =~ '['.spi.']' ) && str =~ pat
                            				let [str, s:did_exp] = [join(split(str, pat, 1), dict['expanded']), 1]
                            			en
                            		endfo
                            		if gmd =~ 't' && !a:0
                            			let prt[0] = str
                            		el
                            			retu str
                            		en
                            	en
                            	retu spi == 'c' ? prt[0] : join(prt, '')
                            endf
                            
    1              0.000006 fu! s:strwidth(str)
                            	retu exists('*strdisplaywidth') ? strdisplaywidth(a:str) : strlen(a:str)
                            endf
                            
    1              0.000005 fu! ctrlp#j2l(nr)
                            	exe 'norm!' a:nr.'G'
                            	sil! norm! zvzz
                            endf
                            
    1              0.000004 fu! s:maxf(len)
                            	retu s:maxfiles && a:len > s:maxfiles
                            endf
                            
    1              0.000005 fu! s:regexfilter(str)
                            	let str = a:str
                            	for key in keys(s:fpats) | if str =~ key
                            		let str = substitute(str, s:fpats[key], '', 'g')
                            	en | endfo
                            	retu str
                            endf
                            
    1              0.000006 fu! s:walker(m, p, d)
                            	retu a:d >= 0 ? a:p < a:m ? a:p + a:d : 0 : a:p > 0 ? a:p + a:d : a:m
                            endf
                            
    1              0.000005 fu! s:delent(rfunc)
                            	if a:rfunc == '' | retu | en
                            	let [s:force, tbrem] = [1, []]
                            	if exists('s:marked')
                            		let tbrem = values(s:marked)
                            		cal s:unmarksigns()
                            		unl s:marked
                            	en
                            	if tbrem == [] && ( has('dialog_gui') || has('dialog_con') ) &&
                            		\ confirm("Wipe all entries?", "&OK\n&Cancel") != 1
                            		unl s:force
                            		cal s:BuildPrompt(0)
                            		retu
                            	en
                            	let g:ctrlp_lines = call(a:rfunc, [tbrem])
                            	cal s:BuildPrompt(1)
                            	unl s:force
                            endf
                            
    1              0.000006 fu! s:delbufcond(bufnr)
                            	retu getbufvar(a:bufnr, "&mod") || a:bufnr == s:crbufnr
                            endf
                            
    1              0.000004 fu! s:delbuf()
                            	let lines = []
                            	if exists('s:marked')
                            		let lines = values(s:marked)
                            		cal s:unmarksigns()
                            		unl s:marked
                            	el
                            		let lines += [ctrlp#getcline()]
                            	en
                            	for line in lines
                            		let bufnr = s:bufnrfilpath(line)[0]
                            		if (s:delbufcond(bufnr))
                            			con
                            		en
                            		exe 'bd '. bufnr
                            	endfo
                            	cal s:PrtClearCache()
                            endf
                            
    1              0.000005 fu! s:isterminal(buf)
                            	retu getbufvar(a:buf, "&bt") == "terminal"
                            endf
                            " Entering & Exiting {{{2
    1              0.000004 fu! s:getenv()
                            	let [s:cwd, s:winres] = [getcwd(), [winrestcmd(), &lines, winnr('$')]]
                            	let [s:crword, s:crnbword] = [expand('<cword>', 1), expand('<cWORD>', 1)]
                            	let [s:crgfile, s:crline] = [expand('<cfile>', 1), getline('.')]
                            	let [s:winmaxh, s:crcursor] = [min([s:mw_max, &lines]), getpos('.')]
                            	let [s:crbufnr, s:crvisual] = [bufnr('%'), s:lastvisual()]
                            	let s:crfile = bufname('%') == ''
                            		\ ? '['.s:crbufnr.'*No Name]' : expand('%:p', 1)
                            	let s:crfpath = expand('%:p:h', 1)
                            	let s:mrbs = ctrlp#mrufiles#bufs()
                            endf
                            
    1              0.000005 fu! s:lastvisual()
                            	let cview = winsaveview()
                            	let [ovreg, ovtype] = [getreg('v'), getregtype('v')]
                            	let [oureg, outype] = [getreg('"'), getregtype('"')]
                            	sil! norm! gV"vy
                            	let selected = s:regisfilter('v')
                            	cal setreg('v', ovreg, ovtype)
                            	cal setreg('"', oureg, outype)
                            	cal winrestview(cview)
                            	retu selected
                            endf
                            
    1              0.000004 fu! s:log(m)
                            	if exists('g:ctrlp_log') && g:ctrlp_log | if a:m
                            		let cadir = ctrlp#utils#cachedir()
                            		let apd = g:ctrlp_log > 1 ? '>' : ''
                            		sil! exe 'redi! >'.apd cadir.s:lash(cadir).'ctrlp.log'
                            	el
                            		sil! redi END
                            	en | en
                            endf
                            
    1              0.000004 fu! s:buffunc(e)
                            	if a:e && has_key(s:buffunc, 'enter')
                            		cal call(s:buffunc['enter'], [], s:buffunc)
                            	elsei !a:e && has_key(s:buffunc, 'exit')
                            		cal call(s:buffunc['exit'], [], s:buffunc)
                            	en
                            endf
                            
    1              0.000006 fu! s:openfile(cmd, fid, tail, chkmod, ...)
                            	let cmd = a:cmd
                            	if a:chkmod && cmd =~ '^[eb]$' && ctrlp#modfilecond(!( cmd == 'b' && &aw ))
                            		let cmd = cmd == 'b' ? 'sb' : 'sp'
                            	en
                            	let cmd = cmd =~ '^tab' ? ctrlp#tabcount().cmd : cmd
                            	let j2l = a:0 && a:1[0] ? a:1[1] : 0
                            	exe cmd.( a:0 && a:1[0] ? '' : a:tail ) s:fnesc(a:fid, 'f')
                            	if j2l
                            		cal ctrlp#j2l(j2l)
                            	en
                            	if !empty(a:tail)
                            		sil! norm! zvzz
                            	en
                            	if cmd != 'bad'
                            		cal ctrlp#setlcdir()
                            	en
                            endf
                            
    1              0.000004 fu! ctrlp#tabcount()
                            	if exists('s:tabct')
                            		let tabct = s:tabct
                            		let s:tabct += 1
                            	elsei !type(s:tabpage)
                            		let tabct = s:tabpage
                            	elsei type(s:tabpage) == 1
                            		let tabpos =
                            			\ s:tabpage =~ 'c' ? tabpagenr() :
                            			\ s:tabpage =~ 'f' ? 1 :
                            			\ s:tabpage =~ 'l' ? tabpagenr('$') :
                            			\ tabpagenr()
                            		let tabct =
                            			\ s:tabpage =~ 'a' ? tabpos :
                            			\ s:tabpage =~ 'b' ? tabpos - 1 :
                            			\ tabpos
                            	en
                            	retu tabct < 0 ? 0 : tabct
                            endf
                            
    1              0.000005 fu! s:settype(type)
                            	retu a:type < 0 ? exists('s:itemtype') ? s:itemtype : 0 : a:type
                            endf
                            " Matching {{{2
    1              0.000005 fu! s:matchfname(item, pat)
                            	let parts = split(a:item, '[\/]\ze[^\/]\+$')
                            	let mfn = match(parts[-1], a:pat[0])
                            	retu len(a:pat) == 1 ? mfn : len(a:pat) == 2 ?
                            		\ ( mfn >= 0 && ( len(parts) == 2 ? match(parts[0], a:pat[1]) : -1 ) >= 0
                            		\ ? 0 : -1 ) : -1
                            endf
                            
    1              0.000005 fu! s:matchbuf(item, pat)
                            	let bufnr = s:bufnrfilpath(a:item)[0]
                            	let parts = s:bufparts(bufnr)
                            	let item = s:byfname ? parts[2] : bufnr.parts[0].parts[2].s:lash().parts[3]
                            	retu match(item, a:pat)
                            endf
                            
    1              0.000004 fu! s:matchtabs(item, pat)
                            	retu match(split(a:item, '\t\+')[0], a:pat)
                            endf
                            
    1              0.000005 fu! s:matchtabe(item, pat)
                            	retu match(split(a:item, '\t\+[^\t]\+$')[0], a:pat)
                            endf
                            
    1              0.000004 fu! s:buildpat(lst)
                            	let pat = a:lst[0]
                            	if s:matchnatural == 1
                            		for item in range(1, len(a:lst) - 1)
                            			let c = a:lst[item - 1]
                            			let pat .= (c == '/' ? '[^/]\{-}' : '[^'.c.'/]\{-}').a:lst[item]
                            		endfo
                            	els
                            		for item in range(1, len(a:lst) - 1)
                            			let pat .= '[^'.a:lst[item - 1].']\{-}'.a:lst[item]
                            		endfo
                            	en
                            	retu pat
                            endf
                            
    1              0.000004 fu! s:curtype()
                            	return s:CurTypeName()[1]
                            endf
                            
    1              0.000004 fu! s:mfunc()
                            	let mfunc = 'match'
                            	if s:byfname()
                            		let mfunc = 's:matchfname'
                            	elsei s:curtype() == 'buf'
                            		let mfunc = 's:matchbuf'
                            	elsei s:itemtype >= len(s:coretypes)
                            		let matchtypes = { 'tabs': 's:matchtabs', 'tabe': 's:matchtabe' }
                            		if has_key(matchtypes, s:matchtype)
                            			let mfunc = matchtypes[s:matchtype]
                            		en
                            	en
                            	retu mfunc
                            endf
                            
    1              0.000004 fu! s:mmode()
                            	let matchmodes = {
                            		\ 'match': 'full-line',
                            		\ 's:matchfname': 'filename-only',
                            		\ 's:matchbuf': 'full-line',
                            		\ 's:matchtabs': 'first-non-tab',
                            		\ 's:matchtabe': 'until-last-tab',
                            		\ }
                            	retu matchmodes[s:mfunc]
                            endf
                            " Cache {{{2
    1              0.000004 fu! s:writecache(cafile)
                            	if ( g:ctrlp_newcache || !filereadable(a:cafile) ) && !s:nocache()
                            		cal ctrlp#utils#writecache(g:ctrlp_allfiles)
                            		let g:ctrlp_newcache = 0
                            	en
                            endf
                            
    1              0.000003 fu! s:nocache(...)
                            	if !s:caching
                            		retu 1
                            	elsei s:caching > 1
                            		if !( exists(s:ccex) && !{s:ccex} ) || has_key(s:ficounts, s:dyncwd)
                            			retu get(s:ficounts, s:dyncwd, [0, 0])[0] < s:caching
                            		elsei a:0 && filereadable(a:1)
                            			retu len(ctrlp#utils#readfile(a:1)) < s:caching
                            		en
                            		retu 1
                            	en
                            	retu 0
                            endf
                            
    1              0.000005 fu! s:insertcache(str)
                            	let [data, g:ctrlp_newcache, str] = [g:ctrlp_allfiles, 1, a:str]
                            	if data == [] || strlen(str) <= strlen(data[0])
                            		let pos = 0
                            	elsei strlen(str) >= strlen(data[-1])
                            		let pos = len(data) - 1
                            	el
                            		let pos = 0
                            		for each in data
                            			if strlen(each) > strlen(str) | brea | en
                            			let pos += 1
                            		endfo
                            	en
                            	cal insert(data, str, pos)
                            	cal s:writecache(ctrlp#utils#cachefile())
                            endf
                            " Extensions {{{2
    1              0.000007 fu! s:mtype()
                            	retu s:itemtype >= len(s:coretypes) ? s:getextvar('type') : 'path'
                            endf
                            
    1              0.000006 fu! s:execextvar(key)
                            	if !empty(g:ctrlp_ext_vars)
                            		cal map(filter(copy(g:ctrlp_ext_vars),
                            			\ 'has_key(v:val, a:key)'), 'eval(v:val[a:key])')
                            	en
                            endf
                            
    1              0.000008 fu! s:getextvar(key)
                            	if s:itemtype >= len(s:coretypes) && len(g:ctrlp_ext_vars) > 0
                            		let vars = g:ctrlp_ext_vars[s:itemtype - len(s:coretypes)]
                            		if has_key(vars, a:key)
                            			retu vars[a:key]
                            		en
                            	en
                            	retu get(g:, 'ctrlp_' . s:matchtype . '_' . a:key, -1)
                            endf
                            
    1              0.000007 fu! ctrlp#getcline()
                            	let [linenr, offset] = [line('.'), ( s:offset > 0 ? s:offset : 0 )]
                            	retu !empty(s:lines) && !( offset && linenr <= offset )
                            		\ ? s:lines[linenr - 1 - offset] : ''
                            endf
                            
    1              0.000007 fu! ctrlp#getmarkedlist()
                            	retu exists('s:marked') ? values(s:marked) : []
                            endf
                            
    1              0.000004 fu! ctrlp#clearmarkedlist()
                            	let s:marked = {}
                            endf
                            
    1              0.000004 fu! ctrlp#exit()
                            	cal s:PrtExit()
                            endf
                            
    1              0.000003 fu! ctrlp#prtclear()
                            	cal s:PrtClear()
                            endf
                            
    1              0.000004 fu! ctrlp#switchtype(id)
                            	cal s:ToggleType(a:id - s:itemtype)
                            endf
                            
    1              0.000003 fu! ctrlp#nosy()
                            	retu !( has('syntax') && exists('g:syntax_on') )
                            endf
                            
    1              0.000005 fu! ctrlp#hicheck(grp, defgrp)
                            	if !hlexists(a:grp)
                            		exe 'hi link' a:grp a:defgrp
                            	en
                            endf
                            
    1              0.000004 fu! ctrlp#call(func, ...)
                            	retu call(a:func, a:000)
                            endf
                            
    1              0.000003 fu! ctrlp#getvar(var)
                            	retu {a:var}
                            endf
                            "}}}1
                            " * Initialization {{{1
    1              0.000003 fu! ctrlp#setlines(...)
                            	if a:0 | let s:itemtype = a:1 | en
                            	cal s:modevar()
                            	let inits = {'fil': 'ctrlp#files()', 'buf': 'ctrlp#buffers()', 'mru': 'ctrlp#mrufiles#list()'}
                            	let types = map(copy(g:ctrlp_types), 'inits[v:val]')
                            	if !empty(g:ctrlp_ext_vars)
                            		cal map(copy(g:ctrlp_ext_vars), 'add(types, v:val["init"])')
                            	en
                            	let g:ctrlp_lines = eval(types[s:itemtype])
                            endf
                            
                            " Returns [lname, sname]
    1              0.000005 fu! s:CurTypeName()
                            	if s:itemtype < len(s:coretypes)
                            		return filter(copy(s:coretypes), 'v:val[1]==g:ctrlp_types[s:itemtype]')[0]
                            	el
                            		return [s:getextvar("lname"), s:getextvar('sname')]
                            	en
                            endfu
                            
    1              0.000005 fu! s:ExitIfSingleCandidate()
                            	if len(s:Update(s:prompt[0])) == 1
                            		call s:AcceptSelection('e')
                            		call ctrlp#exit()
                            		return 1
                            	en
                            	return 0
                            endfu
                            
    1              0.000005 fu! ctrlp#init(type, ...)
                            	if exists('s:init') || s:iscmdwin() | retu | en
                            	let [s:ermsg, v:errmsg] = [v:errmsg, '']
                            	let [s:matches, s:init] = [1, 1]
                            	cal s:Reset(a:0 ? a:1 : {})
                            	noa cal s:Open()
                            	cal s:SetWD(a:0 ? a:1 : {})
                            	cal s:MapNorms()
                            	cal s:MapSpecs()
                            	if empty(g:ctrlp_types) && empty(g:ctrlp_ext_vars)
                            		call ctrlp#exit()
                            		retu
                            	en
                            	if type(a:type) == 0
                            		let type = a:type
                            	el
                            		let type = index(g:ctrlp_types, a:type)
                            		if type == -1
                            			call ctrlp#exit()
                            			retu
                            		en
                            	en
                            	cal ctrlp#setlines(s:settype(type))
                            	cal ctrlp#syntax()
                            	cal s:SetDefTxt()
                            	let curName = s:CurTypeName()
                            	let shouldExitSingle = index(s:opensingle, curName[0])>=0 || index(s:opensingle, curName[1])>=0
                            	if shouldExitSingle && s:ExitIfSingleCandidate()
                            		return 0
                            	en
                            	cal s:BuildPrompt(1)
                            	if s:keyloop | cal s:KeyLoop() | en
                            	return 1
                            endf
                            " - Autocmds {{{1
    1              0.000012 if has('autocmd')
    1              0.000009 	aug CtrlPAug
    1              0.000339 		au!
    1              0.000034 		au BufEnter ControlP cal s:checkbuf()
    1              0.000014 		au BufLeave ControlP noa cal s:Close()
    1              0.000022 		au VimLeavePre * cal s:leavepre()
    1              0.000003 	aug END
    1              0.000003 en
                            
    1              0.000006 fu! s:autocmds()
                            	if !has('autocmd') | retu | en
                            	if exists('#CtrlPLazy')
                            		au! CtrlPLazy
                            	en
                            	if s:lazy
                            		aug CtrlPLazy
                            			au!
                            			au CursorHold ControlP cal s:ForceUpdate()
                            		aug END
                            	en
                            endf
                            "}}}
                            
                            " vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2

SCRIPT  /usr/share/vim/vim80/ftplugin/qf.vim
Sourced 1 time
Total time:   0.000219
 Self time:   0.000219

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:     Vim's quickfix window
                            " Maintainer:   Lech Lorens <Lech.Lorens@gmail.com>
                            " Last Changed: 30 Apr 2012
                            
    1              0.000007 if exists("b:did_ftplugin")
                              finish
                            endif
                            
                            " Don't load another plugin for this buffer
    1              0.000003 let b:did_ftplugin = 1
                            
    1              0.000003 let b:undo_ftplugin = "set stl<"
                            
                            " Display the command that produced the list in the quickfix window:
    1              0.000014 setlocal stl=%t%{exists('w:quickfix_title')?\ '\ '.w:quickfix_title\ :\ ''}\ %=%-15(%l,%c%V%)\ %P

SCRIPT  /usr/share/vim/vim80/syntax/qf.vim
Sourced 1 time
Total time:   0.000307
 Self time:   0.000307

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Quickfix window
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2001 Jan 15
                            
                            " Quit when a syntax file was already loaded
    1              0.000010 if exists("b:current_syntax")
                              finish
                            endif
                            
                            " A bunch of useful C keywords
    1              0.000056 syn match	qfFileName	"^[^|]*" nextgroup=qfSeparator
    1              0.000014 syn match	qfSeparator	"|" nextgroup=qfLineNr contained
    1              0.000013 syn match	qfLineNr	"[^|]*" contained contains=qfError
    1              0.000004 syn match	qfError		"error" contained
                            
                            " The default highlighting.
    1              0.000014 hi def link qfFileName	Directory
    1              0.000008 hi def link qfLineNr	LineNr
    1              0.000006 hi def link qfError	Error
                            
    1              0.000005 let b:current_syntax = "qf"
                            
                            " vim: ts=8

FUNCTION  <SNR>143_add_snr()
Called 56 times
Total time:   0.000263
 Self time:   0.000263

count  total (s)   self (s)
   56              0.000073     if !exists("s:snr")
                                    let s:snr = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeget_snr$')
                                endif
   56              0.000077     return s:snr . a:funcname

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
Called 13 times
Total time:   0.000297
 Self time:   0.000294

count  total (s)   self (s)
   13   0.000188   0.000185   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
    1              0.000003     call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
    1              0.000001   endif

FUNCTION  <SNR>47_filename()
Called 1 time
Total time:   0.000021
 Self time:   0.000004

count  total (s)   self (s)
    1   0.000021   0.000004   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  <SNR>135_get_transitioned_seperator()
Called 195 times
Total time:   0.320696
 Self time:   0.012751

count  total (s)   self (s)
  195              0.000445   let line = ''
  195   0.158812   0.001976   call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
  195              0.001747   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
                              else
  195   0.153190   0.002081     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
  195              0.001354     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
  195              0.001232     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
  195              0.000642     let line .= '%#'.a:group.'#'
  195              0.000208   endif
  195              0.000382   return line

FUNCTION  <SNR>179_narrowable()
Called 5 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
    5              0.000138 	retu exists('s:act_add') && exists('s:matched') && s:matched != [] && exists('s:mdata') && s:mdata[:2] == [s:dyncwd, s:itemtype, s:regexp] && s:matcher == {} && !exists('s:did_exp')

FUNCTION  <SNR>138_HighlightTag()
Called 8 times
Total time:   0.076389
 Self time:   0.074918

count  total (s)   self (s)
    8              0.000025     let tagline = 0
                            
    8              0.000033     let force = a:0 > 0 ? a:1 : 0
                            
    8              0.000014     if a:0 > 1
                                    let tag = s:GetNearbyTag(1, 0, a:2)
                                else
    8   0.001199   0.000074         let tag = s:GetNearbyTag(1, 0)
    8              0.000009     endif
    8              0.000025     if !empty(tag)
    3              0.000005         let tagline = tag.tline
    3              0.000001     endif
                            
                                " Don't highlight the tag again if it's the same one as last time.
                                " This prevents the Tagbar window from jumping back after scrolling with
                                " the mouse.
    8              0.000035     if !force && tagline == s:last_highlight_tline
    5              0.000011         return
                                else
    3              0.000006         let s:last_highlight_tline = tagline
    3              0.000001     endif
                            
    3   0.000102   0.000082     let tagbarwinnr = bufwinnr(s:TagbarBufName())
    3              0.000003     if tagbarwinnr == -1
    1              0.000001         return
                                endif
                            
    2              0.000003     if tagbarwinnr == winnr()
                                    let in_tagbar = 1
                                else
    2              0.000002         let in_tagbar = 0
    2              0.000002         let prevwinnr = winnr()
    2   0.000081   0.000007         call s:goto_win('p', 1)
    2              0.000004         let pprevwinnr = winnr()
    2   0.000060   0.000008         call s:goto_win(tagbarwinnr, 1)
    2              0.000002     endif
                            
    2              0.000002     try
    2              0.000004         match none
                            
                                    " No tag above cursor position so don't do anything
    2              0.000002         if tagline == 0
                                        return
                                    endif
                            
    2              0.000004         if g:tagbar_autoshowtag == 1 || a:openfolds
                                        call s:OpenParents(tag)
                                    endif
                            
                                    " Check whether the tag is inside a closed fold and highlight the parent
                                    " instead in that case
    2   0.000093   0.000015         let tagline = tag.getClosedParentTline()
                            
                                    " Parent tag line number is invalid, better don't do anything
    2              0.000002         if tagline <= 0
                                        return
                                    endif
                            
                                    " Go to the line containing the tag
    2              0.000007         execute tagline
                            
                                    " Make sure the tag is visible in the window
    2              0.000006         call winline()
                            
    2              0.000007         let foldpat = '[' . g:tagbar#icon_open . g:tagbar#icon_closed . ' ]'
    2              0.000006         let pattern = '/^\%' . tagline . 'l\s*' . foldpat . '[-+# ]\?\zs[^( ]\+\ze/'
    2   0.000019   0.000009         call tagbar#debug#log("Highlight pattern: '" . pattern . "'")
    2              0.000010         if hlexists('TagbarHighlight') " Safeguard in case syntax highlighting is disabled
    2              0.000025             execute 'match TagbarHighlight ' . pattern
    2              0.000002         else
                                        execute 'match Search ' . pattern
                                    endif
    2              0.000002     finally
    2              0.000002         if !in_tagbar
    2   0.000072   0.000008             call s:goto_win(pprevwinnr, 1)
    2   0.000057   0.000009             call s:goto_win(prevwinnr, 1)
    2              0.000001         endif
    2              0.074244         redraw
    2              0.000041     endtry

FUNCTION  syntastic#log#debug()
Called 57 times
Total time:   0.000653
 Self time:   0.000439

count  total (s)   self (s)
   57   0.000541   0.000327     if !s:_isDebugEnabled(a:level)
   57              0.000051         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  airline#util#exec_funcrefs()
Called 22 times
Total time:   0.026776
 Self time:   0.002887

count  total (s)   self (s)
  134              0.000347     for Fn in a:list
  134   0.025531   0.001642       let code = call(Fn, a:000)
  134              0.000261       if code != 0
   22              0.000048         return code
                                  endif
  112              0.000139     endfor
                                return 0

FUNCTION  <SNR>179_SpecInputs()
Called 1 time
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
    1              0.000035 	if a:str =~ '\v^(\.\.([\/]\.\.)*[\/]?[.\/]*)$' && s:spi
                            		let cwd = s:dyncwd
                            		cal ctrlp#setdir(a:str =~ '^\.\.\.*$' ? '../'.repeat('../', strlen(a:str) - 2) : a:str)
                            		if cwd != s:dyncwd | cal ctrlp#setlines() | en
                            		cal s:PrtClear()
                            		retu 1
                            	elsei a:str == s:lash && s:spi
                            		cal s:SetWD({ 'mode': 'rd' })
                            		cal ctrlp#setlines()
                            		cal s:PrtClear()
                            		retu 1
                            	elsei a:str =~ '^@.\+' && s:spi
                            		retu s:at(a:str)
                            	elsei a:str == '?'
                            		cal s:PrtExit()
                            		let hlpwin = &columns > 159 ? '| vert res 80' : ''
                            		sil! exe 'bo vert h ctrlp-mappings' hlpwin '| norm! 0'
                            		retu 1
                            	en
    1              0.000004 	retu 0

FUNCTION  <SNR>158_is_modified_and_removed()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return a:from_count > 0 && a:to_count > 0 && a:from_count > a:to_count

FUNCTION  <SNR>17_SynSet()
Called 2 times
Total time:   0.003608
 Self time:   0.002172

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    2              0.000007   syn clear
    2              0.000005   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
    2              0.000006   let s = expand("<amatch>")
    2              0.000003   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
    2              0.000002   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    4              0.000017     for name in split(s, '\.')
    2   0.003530   0.002094       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    2              0.000002     endfor
    2              0.000002   endif

FUNCTION  <SNR>135_section_is_empty()
Called 306 times
Total time:   0.005383
 Self time:   0.005383

count  total (s)   self (s)
  306              0.000741   let start=1
                            
                              " do not check for inactive windows or the tabline
  306              0.000879   if a:self._context.active == 0
   63              0.000134     return 0
                              elseif get(a:self._context, 'tabline', 0)
  101              0.000131     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
  142              0.000629   if get(g:, 'airline_skip_empty_sections', 0) == 0
  142              0.000243     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  <SNR>175_obsolete_gitgutter_signs_to_remove()
Called 2 times
Total time:   0.000278
 Self time:   0.000259

count  total (s)   self (s)
    2              0.000006   let signs_to_remove = []  " list of [<id (number)>, ...]
    2              0.000003   let remove_all_signs = 1
    2   0.000031   0.000012   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
   18              0.000027   for line_number in keys(old_gitgutter_signs)
   16              0.000065     if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
   16              0.000027       let remove_all_signs = 0
   16              0.000014     endif
   16              0.000013   endfor
    2              0.000005   let s:remove_all_old_signs = remove_all_signs
    2              0.000004   return signs_to_remove

FUNCTION  <SNR>179_lash()
Called 116 times
Total time:   0.002845
 Self time:   0.002845

count  total (s)   self (s)
  116              0.002779 	retu ( a:0 ? a:1 : s:dyncwd ) !~ '[\/]$' ? s:lash : ''

FUNCTION  AirlineWebDevIcons()
Called 9 times
Total time:   0.000870
 Self time:   0.000383

count  total (s)   self (s)
    9              0.000109   let w:airline_section_x = get(w:, 'airline_section_x', get(g:, 'airline_section_x', ''))
    9              0.000051   let w:airline_section_x .= ' %{WebDevIconsGetFileTypeSymbol()} '
    9   0.000586   0.000099   let hasFileFormatEncodingPart = airline#parts#ffenc() != ''
    9              0.000047   if g:webdevicons_enable_airline_statusline_fileformat_symbols && hasFileFormatEncodingPart
    9              0.000039     let w:airline_section_y = ' %{&fenc . " " . WebDevIconsGetFileFormatSymbol()} '
    9              0.000015   endif

FUNCTION  <SNR>55_guess()
Called 2 times
Total time:   0.011428
 Self time:   0.011428

count  total (s)   self (s)
    2              0.000005   let options = {}
    2              0.000006   let heuristics = {'spaces': 0, 'hard': 0, 'soft': 0}
    2              0.000002   let ccomment = 0
    2              0.000002   let podcomment = 0
    2              0.000002   let triplequote = 0
    2              0.000002   let backtick = 0
    2              0.000002   let xmlcomment = 0
    2              0.000004   let softtab = repeat(' ', 8)
                            
  193              0.000139   for line in a:lines
  191              0.000583     if !len(line) || line =~# '^\s*$'
   39              0.000027       continue
                                endif
                            
  152              0.000450     if line =~# '^\s*/\*'
                                  let ccomment = 1
                                endif
  152              0.000101     if ccomment
                                  if line =~# '\*/'
                                    let ccomment = 0
                                  endif
                                  continue
                                endif
                            
  152              0.000259     if line =~# '^=\w'
                                  let podcomment = 1
                                endif
  152              0.000088     if podcomment
                                  if line =~# '^=\%(end\|cut\)\>'
                                    let podcomment = 0
                                  endif
                                  continue
                                endif
                            
  152              0.000089     if triplequote
    2              0.000010       if line =~# '^[^"]*"""[^"]*$'
    1              0.000001         let triplequote = 0
    1              0.000001       endif
    2              0.000001       continue
                                elseif line =~# '^[^"]*"""[^"]*$'
    1              0.000001       let triplequote = 1
    1              0.000001     endif
                            
  150              0.000080     if backtick
                                  if line =~# '^[^`]*`[^`]*$'
                                    let backtick = 0
                                  endif
                                  continue
                                elseif line =~# '^[^`]*`[^`]*$'
                                  let backtick = 1
                                endif
                            
  150              0.000476     if line =~# '^\s*<\!--'
                                  let xmlcomment = 1
                                endif
  150              0.000099     if xmlcomment
                                  if line =~# '-->'
                                    let xmlcomment = 0
                                  endif
                                  continue
                                endif
                            
  150              0.000220     if line =~# '^\t'
                                  let heuristics.hard += 1
                                elseif line =~# '^' . softtab
  103              0.000114       let heuristics.soft += 1
  103              0.000040     endif
  150              0.000279     if line =~# '^  '
  113              0.000133       let heuristics.spaces += 1
  113              0.000055     endif
  150              0.000911     let indent = len(matchstr(substitute(line, '\t', softtab, 'g'), '^ *'))
  150              0.000294     if indent > 1 && get(options, 'shiftwidth', 99) > indent
    1              0.000001       let options.shiftwidth = indent
    1              0.000000     endif
  150              0.000080   endfor
                            
    2              0.000004   if heuristics.hard && !heuristics.spaces
                                return {'expandtab': 0, 'shiftwidth': &tabstop}
                              elseif heuristics.soft != heuristics.hard
    1              0.000003     let options.expandtab = heuristics.soft > heuristics.hard
    1              0.000001     if heuristics.hard
                                  let options.tabstop = 8
                                endif
    1              0.000001   endif
                            
    2              0.000003   return options

FUNCTION  <SNR>117_display_git_branch()
Called 1 time
Total time:   0.000184
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000003   let name = b:buffer_vcs_config['git'].branch
    1              0.000002   try
    1   0.000158   0.000012     let commit = fugitive#buffer().commit()
                            
    1              0.000002     if has_key(s:names, commit)
                                  let name = get(s:names, commit)."(".name.")"
                                elseif !empty(commit)
                                  let ref = fugitive#repo().git_chomp('describe', '--all', '--exact-match', commit)
                                  if ref !~ "^fatal: no tag exactly matches"
                                    let name = s:format_name(substitute(ref, '\v\C^%(heads/|remotes/|tags/)=','',''))."(".name.")"
                                  else
                                    let name = matchstr(commit, '.\{'.s:sha1size.'}')."(".name.")"
                                  endif
                                endif
    1              0.000001   catch
                              endtry
                            
    1              0.000001   return name

FUNCTION  <SNR>179_findroot()
Called 2 times
Total time:   0.001814
 Self time:   0.000396

count  total (s)   self (s)
    2              0.000036 	let [depth, fnd] = [a:depth + 1, 0]
    2              0.000017 	if type(a:mark) == 1
    1   0.000403   0.000046 		let fnd = s:glbpath(s:fnesc(a:curr, 'g', ','), a:mark, 1) != ''
    1              0.000008 	elsei type(a:mark) == 3
    1              0.000007 		for markr in a:mark
    1   0.000593   0.000093 			if s:glbpath(s:fnesc(a:curr, 'g', ','), markr, 1) != ''
    1              0.000009 				let fnd = 1
    1              0.000003 				brea
                            			en
                            		endfo
    1              0.000003 	en
    2              0.000008 	if fnd
    2   0.000617   0.000056 		if !a:type | cal ctrlp#setdir(a:curr) | en
    2              0.000028 		retu [exists('markr') ? markr : a:mark, a:curr]
                            	elsei depth > s:maxdepth
                            		cal ctrlp#setdir(s:cwd)
                            	el
                            		let parent = s:getparent(a:curr)
                            		if parent != a:curr
                            			retu s:findroot(parent, a:mark, depth, a:type)
                            		en
                            	en
                            	retu []

FUNCTION  <SNR>179_autocmds()
Called 1 time
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    1              0.000019 	if !has('autocmd') | retu | en
    1              0.000019 	if exists('#CtrlPLazy')
                            		au! CtrlPLazy
                            	en
    1              0.000004 	if s:lazy
                            		aug CtrlPLazy
                            			au!
                            			au CursorHold ControlP cal s:ForceUpdate()
                            		aug END
                            	en

FUNCTION  <SNR>179_match_window_opts()
Called 1 time
Total time:   0.000413
 Self time:   0.000413

count  total (s)   self (s)
    1              0.000079 	let s:mw_pos = s:mw =~ 'top\|bottom' ? matchstr(s:mw, 'top\|bottom') : exists('g:ctrlp_match_window_bottom') ? ( s:mwbottom ? 'bottom' : 'top' ) : 'bottom'
    1              0.000088 	let s:mw_order = s:mw =~ 'order:[^,]\+' ? matchstr(s:mw, 'order:\zs[^,]\+') : exists('g:ctrlp_match_window_reversed') ? ( s:mwreverse ? 'btt' : 'ttb' ) : 'btt'
    1              0.000064 	let s:mw_max = s:mw =~ 'max:[^,]\+' ? str2nr(matchstr(s:mw, 'max:\zs\d\+')) : exists('g:ctrlp_max_height') ? s:mxheight : 10
    1              0.000069 	let s:mw_min = s:mw =~ 'min:[^,]\+' ? str2nr(matchstr(s:mw, 'min:\zs\d\+')) : 1
    1              0.000026 	let [s:mw_max, s:mw_min] = [max([s:mw_max, 1]), max([s:mw_min, 1])]
    1              0.000012 	let s:mw_min = min([s:mw_min, s:mw_max])
    1              0.000068 	let s:mw_res = s:mw =~ 'results:[^,]\+' ? str2nr(matchstr(s:mw, 'results:\zs\d\+')) : min([s:mw_max, &lines])

FUNCTION  412()
Called 3 times
Total time:   0.000225
 Self time:   0.000097

count  total (s)   self (s)
    3              0.000015     let bufnum = get(self.buffers, a:i, -1)
    3              0.000007     if bufnum == -1
                                  return ''
                                endif
    3   0.000157   0.000029     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    3              0.000012     if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
    3              0.000006     return group

FUNCTION  xolox#easytags#session_is_loading()
Called 2 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    2              0.000029   return exists('g:SessionLoad')

FUNCTION  <SNR>150_tabline_evaluated_length()
Called 57 times
Total time:   0.009173
 Self time:   0.000545

count  total (s)   self (s)
   57   0.009151   0.000523   return airline#util#strchars(s:evaluate_tabline(a:tabline))

FUNCTION  <SNR>179_UserCmd()
Called 1 time
Total time:   0.008079
 Self time:   0.000219

count  total (s)   self (s)
    1              0.000004 	let [path, lscmd] = [s:dyncwd, a:lscmd]
    1              0.000006 	let do_ign = type(s:usrcmd) == 4 && has_key(s:usrcmd, 'ignore') && s:usrcmd['ignore']
    1              0.000004 	if do_ign && ctrlp#igncwd(s:cwd) | retu | en
    1              0.000005 	if exists('+ssl') && &ssl && &shell !~ 'sh'
                            		let [ssl, &ssl, path] = [&ssl, 0, tr(path, '/', '\')]
                            	en
    1              0.000007 	if (has('win32') || has('win64')) && match(&shellcmdflag, "/") != -1
                            		let lscmd = substitute(lscmd, '\v(^|\&\&\s*)\zscd (/d)@!', 'cd /d ', '')
                            	en
    1              0.000006 	let path = exists('*shellescape') ? shellescape(path) : path
    1              0.000004 	if (has('win32') || has('win64')) && match(&shell, 'sh') != -1
                            		let path = tr(path, '\', '/')
                            	en
    1              0.000002 	if s:usrcmdasync && v:version >= 800 && exists('*job_start')
                            		if exists('s:job')
                            			call job_stop(s:job)
                            		en
                            		let g:ctrlp_allfiles = []
                            		let s:job = job_start([&shell, &shellcmdflag, printf(lscmd, path)], {'callback': 'ctrlp#addfile'})
                            	elsei has('patch-7.4-597') && !(has('win32') || has('win64'))
    1   0.007974   0.000114 		let g:ctrlp_allfiles = systemlist(s:safe_printf(lscmd, path))
    1              0.000004 	el
                            		let g:ctrlp_allfiles = split(system(s:safe_printf(lscmd, path)), "\n")
                            	en
    1              0.000013 	if exists('+ssl') && exists('ssl')
                            		let &ssl = ssl
                            		cal map(g:ctrlp_allfiles, 'tr(v:val, "\\", "/")')
                            	en
    1              0.000002 	if exists('s:vcscmd') && s:vcscmd
                            		cal map(g:ctrlp_allfiles, 'tr(v:val, "/", "\\")')
                            	en
    1              0.000001 	if do_ign
                            		if !empty(s:usrign)
                            			let g:ctrlp_allfiles = ctrlp#dirnfile(g:ctrlp_allfiles)[1]
                            		en
                            		if &wig != ''
                            			cal filter(g:ctrlp_allfiles, 'glob(v:val) != ""')
                            		en
                            	en

FUNCTION  ctrlp#acceptfile()
Called 1 time
Total time:   0.770131
 Self time:   0.000654

count  total (s)   self (s)
    1              0.000006 	let useb = 0
    1              0.000011 	if a:0 == 1 && type(a:1) == 4
    1              0.000018 		let [md, line] = [a:1['action'], a:1['line']]
    1              0.000012 		let atl = has_key(a:1, 'tail') ? a:1['tail'] : ''
    1              0.000002 	el
                            		let [md, line] = [a:1, a:2]
                            		let atl = a:0 > 2 ? a:3 : ''
                            	en
    1              0.000006 	if !type(line)
                            		let [filpath, bufnr, useb] = [line, line, 1]
                            	el
    1   0.000798   0.000062 		let [bufnr, filpath] = s:bufnrfilpath(line)
    1              0.000006 		if bufnr == filpath
                            			let useb = 1
                            		en
    1              0.000003 	en
    1   0.015895   0.000039 	cal s:PrtExit()
    1   0.000094   0.000051 	let tail = s:tail()
    1              0.000042 	let j2l = atl != '' ? atl : matchstr(tail, '^ +\zs\d\+$')
    1              0.000017 	if bufnr > 0 && ( !empty(s:jmptobuf) && s:jmptobuf =~ md ) && !( md == 'e' && bufnr == bufnr('%') )
                            		let [jmpb, bufwinnr] = [1, bufwinnr(bufnr)]
                            		let buftab = ( s:jmptobuf =~# '[tTVH]' || s:jmptobuf > 1 ) ? s:buftab(bufnr, md) : [0, 0]
                            	en
                            	" Switch to existing buffer or open new one
    1              0.000017 	if exists('jmpb') && bufwinnr > 0 && !( md == 't' && ( s:jmptobuf !~# toupper(md) || buftab[0] ) )
                            		exe bufwinnr.'winc w'
                            		if j2l | cal ctrlp#j2l(j2l) | en
                            	elsei exists('jmpb') && buftab[0] && !( md =~ '[evh]' && s:jmptobuf !~# toupper(md) )
                            		exe 'tabn' buftab[0]
                            		exe buftab[1].'winc w'
                            		if j2l | cal ctrlp#j2l(j2l) | en
                            	el
                            		" Determine the command to use
    1              0.000014 		let useb = bufnr > 0 && buflisted(bufnr) && ( empty(tail) || useb )
    1   0.000522   0.000072 		let cmd = md == 't' || s:splitwin == 1 ? ( useb ? 'tab sb' : 'tabe' ) : md == 'h' || s:splitwin == 2 ? ( useb ? 'sb' : 'new' ) : md == 'v' || s:splitwin == 3 ? ( useb ? 'vert sb' : 'vne' ) : call('ctrlp#normcmd', useb ? ['b', 'bo vert sb'] : ['e'])
                            		" Reset &switchbuf option
    1   0.000047   0.000035 		let [swb, &swb] = [&swb, '']
                            		" Open new window/buffer
    1              0.000018 		let [fid, tail] = [( useb ? bufnr : filpath ), ( atl != '' ? ' +'.atl : tail )]
    1              0.000013 		let args = [cmd, fid, tail, 1, [useb, j2l]]
    1   0.752427   0.000059 		cal call('s:openfile', args)
    1   0.000032   0.000020 		let &swb = swb
    1              0.000002 	en

FUNCTION  <SNR>68__is_quitting()
Called 2 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    2              0.000004     let quitting = 0
    2              0.000007     if exists('w:syntastic_wid')
                                    let key = a:buf . '_' . getbufvar(a:buf, 'changetick') . '_' . w:syntastic_wid
                                    let idx = index(s:_quit_pre, key)
                                    if idx >= 0
                                        call remove(s:_quit_pre, idx)
                                        let quitting = 1
                                    endif
                                endif
                            
    2              0.000003     return quitting

FUNCTION  airline#extensions#tagbar#currenttag()
Called 225 times
Total time:   0.039811
 Self time:   0.016629

count  total (s)   self (s)
  225              0.001968   if get(w:, 'airline_active', 0)
  223              0.000814     if !s:init
                                  try
                                    " try to load the plugin, if filetypes are disabled,
                                    " this will cause an error, so try only once
                                    let a=tagbar#currenttag('%', '', '')
                                  catch
                                  endtry
                                  unlet! a
                                  let s:init=1
                                endif
                                " function tagbar#currenttag does not exist, if filetype is not enabled
  223              0.002574     if s:airline_tagbar_last_lookup_time != localtime() && exists("*tagbar#currenttag")
   35   0.023967   0.000785       let s:airline_tagbar_last_lookup_val = tagbar#currenttag('%s', '', s:flags)
   35              0.000329       let s:airline_tagbar_last_lookup_time = localtime()
   35              0.000066     endif
  223              0.001345     return s:airline_tagbar_last_lookup_val
                              endif
    2              0.000002   return ''

FUNCTION  airline#async#vim_vcs_untracked()
Called 4 times
Total time:   0.002248
 Self time:   0.002248

count  total (s)   self (s)
    4              0.000007     if g:airline#init#is_windows && &shell =~ 'cmd'
                                  let cmd = a:config['cmd'] . shellescape(a:file)
                                else
    4              0.000053       let cmd = ['sh', '-c', a:config['cmd'] . shellescape(a:file)]
    4              0.000003     endif
                            
    4              0.000042     let options = {'cfg': a:config, 'buf': '', 'file': a:file}
    4              0.000012     if has_key(s:untracked_jobs, a:file)
    3              0.000027       if job_status(get(s:untracked_jobs, a:file)) == 'run'
    2              0.000003         return
                                  elseif has_key(s:untracked_jobs, a:file)
    1              0.000003         call remove(s:untracked_jobs, a:file)
    1              0.000001       endif
    1              0.000000     endif
    2              0.002019     let id = job_start(cmd, { 'err_io':   'out', 'out_cb':   function('s:on_stdout', options), 'close_cb': function('s:on_exit_untracked', options)})
    2              0.000030     let s:untracked_jobs[a:file] = id

FUNCTION  syntastic#log#debugShowOptions()
Called 1 time
Total time:   0.000010
 Self time:   0.000006

count  total (s)   self (s)
    1   0.000009   0.000005     if !s:_isDebugEnabled(a:level)
    1              0.000001         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type('') ? [a:names] : a:names)
                                let add_shell = index(vlist, 'shell') >= 0 && &shell !=# syntastic#util#var('shell')
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val))) . (s:_is_modified(v:val) ? ' (!)' : '')")
                                    if add_shell
                                        call add(vlist, 'u:shell = ' . strtrans(string(syntastic#util#var('shell'))) . ' (!)')
                                    endif
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)

FUNCTION  airline#statusline()
Called 226 times
Total time:   0.010878
 Self time:   0.010878

count  total (s)   self (s)
  226              0.004728   if has_key(s:contexts, a:winnr)
  226              0.005262     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  airline#check_mode()
Called 226 times
Total time:   0.321796
 Self time:   0.056612

count  total (s)   self (s)
  226              0.002406   let context = s:contexts[a:winnr]
                            
  226              0.002317   if get(w:, 'airline_active', 1)
  223              0.001908     let l:m = mode()
  223              0.001234     if l:m ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
  223              0.001439       let l:mode = ['normal']
  223              0.000537     endif
  223              0.003072     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
  223              0.000492   else
    3              0.000007     let l:mode = ['inactive']
    3              0.000015     let w:airline_current_mode = get(g:airline_mode_map, '__')
    3              0.000002   endif
                            
  226              0.001913   if g:airline_detect_modified && &modified
   70              0.000699     call add(l:mode, 'modified')
   70              0.000131   endif
                            
  226              0.001111   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
  226              0.002714   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
  226              0.001167   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
  226              0.000966   if &readonly || ! &modifiable
    1              0.000004     call add(l:mode, 'readonly')
    1              0.000000   endif
                            
  226              0.002947   let mode_string = join(l:mode)
  226              0.002385   if get(w:, 'airline_lastmode', '') != mode_string
    7   0.002357   0.000058     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    7   0.262966   0.000081     call airline#highlighter#highlight(l:mode, context.bufnr)
    7              0.000028     let w:airline_lastmode = mode_string
    7              0.000006   endif
                            
  226              0.000885   return ''

FUNCTION  ctrlp#init()
Called 1 time
Total time:   0.110525
 Self time:   0.000540

count  total (s)   self (s)
    1   0.000167   0.000060 	if exists('s:init') || s:iscmdwin() | retu | en
    1              0.000009 	let [s:ermsg, v:errmsg] = [v:errmsg, '']
    1              0.000007 	let [s:matches, s:init] = [1, 1]
    1   0.003121   0.000036 	cal s:Reset(a:0 ? a:1 : {})
    1   0.005181   0.000066 	noa cal s:Open()
    1   0.001815   0.000055 	cal s:SetWD(a:0 ? a:1 : {})
    1   0.004496   0.000036 	cal s:MapNorms()
    1   0.002777   0.000054 	cal s:MapSpecs()
    1              0.000012 	if empty(g:ctrlp_types) && empty(g:ctrlp_ext_vars)
                            		call ctrlp#exit()
                            		retu
                            	en
    1              0.000008 	if type(a:type) == 0
    1              0.000005 		let type = a:type
    1              0.000002 	el
                            		let type = index(g:ctrlp_types, a:type)
                            		if type == -1
                            			call ctrlp#exit()
                            			retu
                            		en
                            	en
    1   0.052703   0.000069 	cal ctrlp#setlines(s:settype(type))
    1   0.000548   0.000030 	cal ctrlp#syntax()
    1   0.000021   0.000016 	cal s:SetDefTxt()
    1   0.000016   0.000004 	let curName = s:CurTypeName()
    1              0.000006 	let shouldExitSingle = index(s:opensingle, curName[0])>=0 || index(s:opensingle, curName[1])>=0
    1              0.000003 	if shouldExitSingle && s:ExitIfSingleCandidate()
                            		return 0
                            	en
    1   0.039577   0.000011 	cal s:BuildPrompt(1)
    1              0.000004 	if s:keyloop | cal s:KeyLoop() | en
    1              0.000004 	return 1

FUNCTION  airline#util#append()
Called 1561 times
Total time:   0.046090
 Self time:   0.046090

count  total (s)   self (s)
 1561              0.009535   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 1561              0.014540   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
 1561              0.012862   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  airline#extensions#vimtex#apply()
Called 9 times
Total time:   0.000136
 Self time:   0.000136

count  total (s)   self (s)
    9              0.000043   if exists("b:vimtex")
                                let w:airline_section_x = get(w:, 'airline_section_x', g:airline_section_x)
                                let w:airline_section_x.=s:spc.g:airline_left_alt_sep.s:spc.'%{airline#extensions#vimtex#get_scope()}'
                              endif

FUNCTION  <SNR>179_bufwins()
Called 1 time
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    1              0.000007 	let winns = 0
    2              0.000019 	for tabnr in range(1, tabpagenr('$'))
    1              0.000019 		let winns += count(tabpagebuflist(tabnr), a:bufnr)
    1              0.000003 	endfo
    1              0.000004 	retu winns

FUNCTION  <SNR>179_getparent()
Called 106 times
Total time:   0.007404
 Self time:   0.007404

count  total (s)   self (s)
  106              0.005833 	let parent = substitute(a:item, '[\/][^\/]\+[\/:]\?$', '', '')
  106              0.000816 	if parent == '' || parent !~ '[\/]'
                            		let parent .= s:lash
                            	en
  106              0.000227 	retu parent

FUNCTION  airline#extensions#branch#update_untracked_config()
Called 221 times
Total time:   0.008935
 Self time:   0.008935

count  total (s)   self (s)
  221              0.002408   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
                              elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
                              endif

FUNCTION  ctrlp#utils#writecache()
Called 3 times
Total time:   0.033183
 Self time:   0.033052

count  total (s)   self (s)
    3   0.000117   0.000040 	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
    3   0.033026   0.032972 		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
    3              0.000027 	en

FUNCTION  <SNR>179_comptime()
Called 53 times
Total time:   0.001180
 Self time:   0.001180

count  total (s)   self (s)
                            	" By last modified time
   53              0.000866 	let [time1, time2] = [getftime(a:1), getftime(a:2)]
   53              0.000246 	retu time1 == time2 ? 0 : time1 < time2 ? 1 : -1

FUNCTION  <SNR>179_regisfilter()
Called 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000035 	retu substitute(getreg(a:reg), "[\t\n]", ' ', 'g')

FUNCTION  airline#themes#get_highlight()
Called 1212 times
Total time:   0.196394
 Self time:   0.010541

count  total (s)   self (s)
 1212   0.195907   0.010054   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>179_sublist()
Called 5 times
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
    5              0.000095 	retu v:version > 701 ? a:l[(a:s):(a:e)] : s:sublist7071(a:l, a:s, a:e)

FUNCTION  <SNR>145_isFolded()
Called 2 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    2              0.000003     return self.fileinfo.kindfolds[self.short]

FUNCTION  <SNR>179_buildpat()
Called 4 times
Total time:   0.000425
 Self time:   0.000425

count  total (s)   self (s)
    4              0.000028 	let pat = a:lst[0]
    4              0.000020 	if s:matchnatural == 1
                            		for item in range(1, len(a:lst) - 1)
                            			let c = a:lst[item - 1]
                            			let pat .= (c == '/' ? '[^/]\{-}' : '[^'.c.'/]\{-}').a:lst[item]
                            		endfo
                            	els
   10              0.000071 		for item in range(1, len(a:lst) - 1)
    6              0.000084 			let pat .= '[^'.a:lst[item - 1].']\{-}'.a:lst[item]
    6              0.000013 		endfo
    4              0.000009 	en
    4              0.000015 	retu pat

FUNCTION  tagbar#prototypes#kindheadertag#new()
Called 1 time
Total time:   0.000250
 Self time:   0.000036

count  total (s)   self (s)
    1   0.000185   0.000003     let newobj = tagbar#prototypes#basetag#new(a:name)
                            
    1   0.000013   0.000008     let newobj.isKindheader = function(s:add_snr('s:isKindheader'))
    1   0.000009   0.000004     let newobj.getPrototype = function(s:add_snr('s:getPrototype'))
    1   0.000008   0.000004     let newobj.isFoldable = function(s:add_snr('s:isFoldable'))
    1   0.000008   0.000004     let newobj.isFolded = function(s:add_snr('s:isFolded'))
    1   0.000008   0.000003     let newobj.openFold = function(s:add_snr('s:openFold'))
    1   0.000008   0.000003     let newobj.closeFold = function(s:add_snr('s:closeFold'))
    1   0.000008   0.000004     let newobj.toggleFold = function(s:add_snr('s:toggleFold'))
                            
    1              0.000001     return newobj

FUNCTION  <SNR>68__ignore_file()
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    2              0.000018     let fname = fnamemodify(a:filename, ':p')
    2              0.000006     for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
                                endfor
    2              0.000001     return 0

FUNCTION  airline#extensions#fugitiveline#bufname()
Called 225 times
Total time:   0.018394
 Self time:   0.018173

count  total (s)   self (s)
  225              0.002160   if !exists('b:fugitive_name')
    1              0.000001     let b:fugitive_name = ''
    1              0.000001     try
    1   0.000032   0.000004       let buffer = fugitive#buffer()
    1   0.000197   0.000004       if buffer.type('blob')
                                    let b:fugitive_name = buffer.repo().translate(buffer.path())
                                  endif
    1              0.000001     catch
                                endtry
    1              0.000001   endif
                            
  225              0.001339   if empty(b:fugitive_name)
  225              0.005911     return fnamemodify(bufname('%'), s:fmod)
                              else
                                return fnamemodify(b:fugitive_name, s:fmod)
                              endif

FUNCTION  <SNR>138_AutoUpdate()
Called 10 times
Total time:   0.163342
 Self time:   0.003907

count  total (s)   self (s)
   10   0.000345   0.000176     call tagbar#debug#log('AutoUpdate called [' . a:fname . ']')
                            
                                " Whether we want to skip actually displaying the tags in Tagbar and only
                                " update the fileinfo
   10              0.000061     let no_display = a:0 > 0 ? a:1 : 0
                            
                                " This file is being loaded due to a quickfix command like vimgrep, so
                                " don't process it
   10              0.000052     if exists('s:tagbar_qf_active')
                                    return
                                elseif exists('s:window_opening')
                                    " This can happen if another plugin causes the active window to change
                                    " with an autocmd during the initial Tagbar window creation. In that
                                    " case InitWindow() hasn't had a chance to run yet and things can
                                    " break. MiniBufExplorer does this, for example. Completely disabling
                                    " autocmds at that point is also not ideal since for example
                                    " statusline plugins won't be able to update.
                                    call tagbar#debug#log('Still opening window, stopping processing')
                                    return
                                endif
                            
                                " Get the filetype of the file we're about to process
   10              0.000660     let bufnr = bufnr(a:fname)
   10              0.000081     let ftype = getbufvar(bufnr, '&filetype')
                            
                                " Don't do anything if we're in the tagbar window
   10              0.000032     if ftype == 'tagbar'
    2   0.000068   0.000027         call tagbar#debug#log('In Tagbar window, stopping processing')
    2              0.000004         return
                                endif
                            
                                " Only consider the main filetype in cases like 'python.django'
    8              0.000088     let sftype = get(split(ftype, '\.'), 0, '')
    8   0.000200   0.000097     call tagbar#debug#log("Vim filetype: '" . ftype . "', " . "sanitized filetype: '" . sftype . "'")
                            
                                " Don't do anything if the file isn't supported
    8   0.001412   0.000117     if !s:IsValidFile(a:fname, sftype)
    1   0.000007   0.000003         call tagbar#debug#log('Not a valid file, stopping processing')
    1              0.000002         let s:nearby_disabled = 1
    1              0.000001         return
                                endif
                            
    7              0.000034     let updated = 0
                            
                                " Process the file if it's unknown or the information is outdated.
                                " Testing the mtime of the file is necessary in case it got changed
                                " outside of Vim, for example by checking out a different version from a
                                " VCS.
    7   0.000138   0.000084     if s:known_files.has(a:fname)
    6   0.000114   0.000065         let curfile = s:known_files.get(a:fname)
                                    " if a:force || getbufvar(curfile.bufnr, '&modified') ||
    6              0.000180         if a:force || empty(curfile) || curfile.ftype != sftype || (filereadable(a:fname) && getftime(a:fname) > curfile.mtime)
                                        call tagbar#debug#log('File data outdated, updating [' . a:fname . ']')
                                        call s:ProcessFile(a:fname, sftype)
                                        let updated = 1
                                    else
    6   0.000155   0.000068             call tagbar#debug#log('File data seems up to date [' . a:fname . ']')
    6              0.000010         endif
    6              0.000024     elseif !s:known_files.has(a:fname)
    1   0.000008   0.000003         call tagbar#debug#log('New file, processing [' . a:fname . ']')
    1   0.020938   0.000071         call s:ProcessFile(a:fname, sftype)
    1              0.000001         let updated = 1
    1              0.000001     endif
                            
    7              0.000016     if no_display
                                    return
                                endif
                            
    7   0.000109   0.000067     let fileinfo = s:known_files.get(a:fname)
                            
                                " If we don't have an entry for the file by now something must have gone
                                " wrong, so don't change the tagbar content
    7              0.000024     if empty(fileinfo)
                                    call tagbar#debug#log('fileinfo empty after processing [' . a:fname . ']')
                                    return
                                endif
                            
                                " Display the tagbar content if the tags have been updated or a different
                                " file is being displayed
    7   0.001198   0.000597     if bufwinnr(s:TagbarBufName()) != -1 && !s:paused && (s:new_window || updated || (!empty(tagbar#state#get_current_file(0)) && a:fname != tagbar#state#get_current_file(0).fpath))
    1   0.033089   0.000010         call s:RenderContent(fileinfo)
    1              0.000001     endif
                            
                                " Call setCurrent after rendering so RenderContent can check whether the
                                " same file is being redisplayed
    7              0.000023     if !empty(fileinfo)
    7   0.000154   0.000067         call tagbar#debug#log('Setting current file [' . a:fname . ']')
    7   0.000351   0.000109         call tagbar#state#set_current_file(fileinfo)
    7              0.000025         let s:nearby_disabled = 0
    7              0.000009     endif
                            
    7   0.059740   0.000086     call s:HighlightTag(0)
    7   0.043110   0.000121     call s:SetStatusLine()
    7   0.000123   0.000058     call tagbar#debug#log('AutoUpdate finished successfully')

FUNCTION  gitgutter#sign#update_signs()
Called 2 times
Total time:   0.002756
 Self time:   0.000174

count  total (s)   self (s)
    2   0.001463   0.000020   call s:find_current_signs(a:bufnr)
                            
    2              0.000028   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
    2   0.000313   0.000035   let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
    2              0.000008   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
    2              0.000002   if flicker_possible
                                call s:add_dummy_sign(a:bufnr)
                              endif
                            
    2   0.000077   0.000020   call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
    2   0.000832   0.000028   call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)
                            
    2              0.000008   if flicker_possible
                                call gitgutter#sign#remove_dummy_sign(a:bufnr, 0)
                              endif

FUNCTION  <SNR>159_Pyeval()
Called 16 times
Total time:   0.007796
 Self time:   0.007796

count  total (s)   self (s)
   16              0.000065   if s:using_python3
   16              0.007691     return py3eval( a:eval_string )
                              endif
                              return pyeval( a:eval_string )

FUNCTION  <SNR>138_CloseWindow()
Called 1 time
Total time:   0.000286
 Self time:   0.000146

count  total (s)   self (s)
    1   0.000008   0.000002     call tagbar#debug#log('CloseWindow called')
                            
    1   0.000034   0.000027     let tagbarwinnr = bufwinnr(s:TagbarBufName())
    1              0.000002     if tagbarwinnr == -1
                                    return
                                endif
                            
                                " Close the preview window if it was opened by us
    1              0.000001     if s:pwin_by_tagbar
                                    pclose
                                    let tagbarwinnr = bufwinnr(s:TagbarBufName())
                                endif
                            
    1              0.000002     if winnr() == tagbarwinnr
                                    if winbufnr(2) != -1
                                        " Other windows are open, only close the tagbar one
                            
                                        let curfile = tagbar#state#get_current_file(0)
                            
                                        close
                            
                                        " Try to jump to the correct window after closing
                                        call s:goto_win('p')
                            
                                        if !empty(curfile)
                                            let filebufnr = bufnr(curfile.fpath)
                            
                                            if bufnr('%') != filebufnr
                                                let filewinnr = bufwinnr(filebufnr)
                                                if filewinnr != -1
                                                    call s:goto_win(filewinnr)
                                                endif
                                            endif
                                        endif
                                    endif
                                else
                                    " Go to the tagbar window, close it and then come back to the original
                                    " window. Save a win-local variable in the original window so we can
                                    " jump back to it even if the window number changed.
    1   0.000007   0.000005         call s:mark_window()
    1   0.000041   0.000004         call s:goto_win(tagbarwinnr)
    1              0.000043         close
                            
    1   0.000089   0.000010         call s:goto_markedwin()
    1              0.000001     endif
                            
    1   0.000019   0.000015     call s:ShrinkIfExpanded()
                            
    1              0.000002     if s:autocommands_done && !s:statusline_in_use
                                    autocmd! TagbarAutoCmds
                                    let s:autocommands_done = 0
                                endif
                            
    1   0.000008   0.000003     call tagbar#debug#log('CloseWindow finished')

FUNCTION  <SNR>117_has_lawrencium()
Called 223 times
Total time:   0.002689
 Self time:   0.002689

count  total (s)   self (s)
  223              0.002457   return exists('*lawrencium#statusline')

FUNCTION  syntastic#util#shescape()
Called 6 times
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
    6              0.000101     return a:string =~# '\m^[A-Za-z0-9_/.-]\+$' ? a:string : shellescape(a:string)

FUNCTION  <SNR>54_SetUpForNewFiletype()
Called 8 times
Total time:   0.001080
 Self time:   0.000887

count  total (s)   self (s)
    8              0.000037     let ft = a:filetype
                            
                                "for compound filetypes, if we don't know how to handle the full filetype
                                "then break it down and use the first part that we know how to handle
    8              0.000062     if ft =~ '\.' && !has_key(s:delimiterMap, ft)
                                    let filetypes = split(a:filetype, '\.')
                                    for i in filetypes
                                        if has_key(s:delimiterMap, i)
                                            let ft = i
                                            break
                                        endif
                                    endfor
                                endif
                            
    8              0.000029     let b:NERDSexyComMarker = ''
                            
    8              0.000038     if has_key(s:delimiterMap, ft)
    5              0.000020         let b:NERDCommenterDelims = s:delimiterMap[ft]
   25              0.000040         for i in ['left', 'leftAlt', 'right', 'rightAlt']
   20              0.000047             if !has_key(b:NERDCommenterDelims, i)
                                            let b:NERDCommenterDelims[i] = ''
                                        endif
   20              0.000009         endfor
   15              0.000019         for i in ['nested', 'nestedAlt']
   10              0.000018             if !has_key(b:NERDCommenterDelims, i)
                                            let b:NERDCommenterDelims[i] = 0
                                        endif
   10              0.000004         endfor
                                    " if g:NERD_<filetype>_alt_style is defined, use the alternate style
    5              0.000032         let b:NERDCommenterFirstInit = getbufvar(1,"NERDCommenterFirstInit")
    5              0.000030         if exists('g:NERDAltDelims_'.ft) && eval('g:NERDAltDelims_'.ft) && !b:NERDCommenterFirstInit
                                        call s:SwitchToAlternativeDelimiters(0)
                                        let b:NERDCommenterFirstInit = 1
                                    endif
    5              0.000004     else
    3   0.000253   0.000060         let b:NERDCommenterDelims = s:CreateDelimMapFromCms()
    3              0.000003     endif
                            

FUNCTION  <SNR>117_update_hg_branch()
Called 223 times
Total time:   0.027963
 Self time:   0.025274

count  total (s)   self (s)
  223   0.005068   0.002379   if s:has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
                              else
  223              0.001708     let s:vcs_config['mercurial'].branch = ''
  223              0.000488   endif

FUNCTION  <SNR>159_OnCursorMovedNormalMode()
Called 192 times
Total time:   0.073671
 Self time:   0.044216

count  total (s)   self (s)
  192   0.032068   0.002613   if !s:AllowedToCompleteInCurrentBuffer()
   13              0.000026     return
                              endif
                            
  179              0.040272   exec s:python_command "ycm_state.OnCursorMoved()"

FUNCTION  <SNR>179_BuildPrompt()
Called 7 times
Total time:   0.332918
 Self time:   0.141355

count  total (s)   self (s)
    7   0.000735   0.000133 	let base = ( s:regexp ? 'r' : '>' ).( s:byfname() ? 'd' : '>' ).'> '
    7   0.001013   0.000130 	let str = escape(s:getinput(), '\')
    7              0.000121 	let lazy = str == '' || exists('s:force') || !has('autocmd') ? 0 : s:lazy
    7              0.000092 	if a:upd && !lazy && ( s:matches || s:regexp || exists('s:did_exp') || str =~ '\(\\\(<\|>\)\|[*|]\)\|\(\\\:\([^:]\|\\:\)*$\)' )
    6   0.075433   0.000112 		sil! cal s:Update(str)
    6              0.000009 	en
    7   0.114899   0.000142 	sil! cal ctrlp#statusline()
                            	" Toggling
    7              0.000100 	let [hiactive, hicursor, base] = s:focus ? ['CtrlPPrtText', 'CtrlPPrtCursor', base] : ['CtrlPPrtBase', 'CtrlPPrtBase', tr(base, '>', '-')]
    7              0.000021 	let hibase = 'CtrlPPrtBase'
                            	" Build it
    7              0.139545 	redr
    7              0.000143 	let prt = copy(s:prompt)
    7              0.000134 	cal map(prt, 'escape(v:val, ''"\'')')
    7              0.000453 	exe 'echoh' hibase '| echon "'.base.'" | echoh' hiactive '| echon "'.prt[0].'" | echoh' hicursor '| echon "'.prt[1].'" | echoh' hiactive '| echon "'.prt[2].'" | echoh None'
                            	" Append the cursor at the end
    7              0.000032 	if empty(prt[1]) && s:focus
    7              0.000125 		exe 'echoh' hibase '| echon "_" | echoh None'
    7              0.000006 	en

FUNCTION  <SNR>179_nosort()
Called 4 times
Total time:   0.000404
 Self time:   0.000188

count  total (s)   self (s)
    4   0.000257   0.000041 	let ct = s:curtype()
    4              0.000140 	retu s:matcher != {} || s:nolim == 1 || ( ct == 'mru' && s:mrudef ) || ( ct =~ '^\(buf\|mru\)$' && s:prompt == ['', '', ''] ) || !s:dosort

FUNCTION  gitgutter#utility#set_repo_path()
Called 1 time
Total time:   0.001303
 Self time:   0.000142

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                            
    1   0.000021   0.000004   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
    1   0.000136   0.000018   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' ls-files --error-unmatch --full-name '.gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
    1   0.000009   0.000006   if g:gitgutter_async && gitgutter#async#available()
    1              0.000002     if has('lambda')
    1   0.001096   0.000073       call gitgutter#async#execute(cmd, a:bufnr, {   'out': {bufnr, path -> gitgutter#utility#setbufvar(bufnr, 'path', s:strip_trailing_new_line(path))},   'err': {bufnr       -> gitgutter#utility#setbufvar(bufnr, 'path', -2)}, })
    1              0.000001     else
                                  if has('nvim') && !has('nvim-0.2.0')
                                    call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('s:set_path'),   'err': function('s:not_tracked_by_git') })
                                  else
                                    call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('s:set_path'),   'err': function('s:set_path', [-2]) })
                                  endif
                                endif
    1              0.000001   else
                                let path = gitgutter#utility#system(cmd)
                                if v:shell_error
                                  call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                                else
                                  call gitgutter#utility#setbufvar(a:bufnr, 'path', s:strip_trailing_new_line(path))
                                endif
                              endif

FUNCTION  <SNR>158_process_modified_and_removed()
Called 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    1              0.000003   let offset = 0
    2              0.000004   while offset < a:to_count
    1              0.000004     let line_number = a:to_line + offset
    1              0.000005     call add(a:modifications, [line_number, 'modified'])
    1              0.000002     let offset += 1
    1              0.000001   endwhile
    1              0.000007   let a:modifications[-1] = [a:to_line + offset - 1, 'modified_removed']

FUNCTION  <SNR>138_EscapeCtagsCmd()
Called 1 time
Total time:   0.000181
 Self time:   0.000158

count  total (s)   self (s)
    1   0.000010   0.000004     call tagbar#debug#log('EscapeCtagsCmd called')
    1   0.000008   0.000003     call tagbar#debug#log('ctags_bin: ' . a:ctags_bin)
    1              0.000003     if type(a:args)==type('')
                                    call tagbar#debug#log('ctags_args (is a string): ' . a:args)
                                elseif type(a:args)==type([])
    1   0.000014   0.000009         call tagbar#debug#log('ctags_args (is a list): ' . string(a:args))
    1              0.000001     endif
                            
    1              0.000002     if exists('+shellslash')
                                    let shellslash_save = &shellslash
                                    set noshellslash
                                endif
                            
                                "Set up 0th argument of ctags_cmd
                                "a:ctags_bin may have special characters that require escaping.
    1              0.000005     if &shell =~ 'cmd\.exe$' && a:ctags_bin !~ '\s'
                                    "For windows cmd.exe, escaping the 0th argument can cause
                                    "problems if it references a batch file and the batch file uses %~dp0.
                                    "So for windows cmd.exe, only escape the 0th argument iff necessary.
                                    "Only known necessary case is when ctags_bin executable filename has
                                    "whitespace character(s).
                            
                                    "  Example: If 0th argument is wrapped in double quotes AND it is not
                                    "  an absolute path to ctags_bin, but rather an executable in %PATH%,
                                    "  then %~dp0 resolves to the current working directory rather than
                                    "  the batch file's directory. Batch files like this generally exepect
                                    "  and depend on %~dp0 to resolve the batch file's directory.
                                    "  Note: Documentation such as `help cmd.exe` and
                                    "  http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx?mfr=true
                                    "  suggest other special characters that require escaping for command
                                    "  line completion.  But tagbar.vim does not use the command line
                                    "  completion feature of cmd.exe and testing shows that the only special
                                    "  character that needs to be escaped for tagbar.vim is <space> for
                                    "  windows cmd.exe.
                                    let ctags_cmd = a:ctags_bin
                                else
    1              0.000004         let ctags_cmd = shellescape(a:ctags_bin)
    1              0.000000     endif
                            
                                "Add additional arguments to ctags_cmd
    1              0.000002     if type(a:args)==type('')
                                    "When a:args is a string, append the arguments
                                    "Note: In this case, do not attempt to shell escape a:args string.
                                    "This function expects the string to already be escaped properly for
                                    "the shell type. Why not escape? Because it could be ambiguous about
                                    "whether a space is an argument separator or included in the argument.
                                    "Since escaping rules vary from shell to shell, it is better to pass a
                                    "list of arguments to a:args. With a list, each argument is clearly
                                    "separated, so shellescape() can calculate the appropriate escaping
                                    "for each argument for the current &shell.
                                    let ctags_cmd .= ' ' . a:args
                                elseif type(a:args)==type([])
                                    "When a:args is a list, shellescape() each argument and append ctags_cmd
                                    "Note: It's a better practice to shellescape() each argument separately so that
                                    "spaces used as a separator between arguments can be distinguished with
                                    "spaces used inside a single argument.
   12              0.000009         for arg in a:args
   11              0.000025             let ctags_cmd .= ' ' . shellescape(arg)
   11              0.000005         endfor
    1              0.000000     endif
                            
                                "if a filename was specified, add filename as final argument to ctags_cmd.
    1              0.000001     if a:0 == 1
    1              0.000003         let ctags_cmd .= ' ' . shellescape(a:1)
    1              0.000000     endif
                            
    1              0.000001     if exists('+shellslash')
                                    let &shellslash = shellslash_save
                                endif
                            
                                " Needed for cases where 'encoding' is different from the system's
                                " encoding
    1              0.000004     if has('multi_byte')
    1              0.000002         if g:tagbar_systemenc != &encoding
                                        let ctags_cmd = iconv(ctags_cmd, &encoding, g:tagbar_systemenc)
                                    elseif $LANG != ''
    1              0.000014             let ctags_cmd = iconv(ctags_cmd, &encoding, $LANG)
    1              0.000000         endif
    1              0.000000     endif
                            
    1   0.000026   0.000019     call tagbar#debug#log('Escaped ctags command: ' . ctags_cmd)
                            
    1              0.000002     if ctags_cmd == ''
                                    if !s:warnings.encoding
                                        call s:warning('Tagbar: Ctags command encoding conversion failed!' . ' Please read ":h g:tagbar_systemenc".')
                                        let s:warnings.encoding = 1
                                    endif
                                endif
                            
    1              0.000001     return ctags_cmd

FUNCTION  <SNR>120_check_mixed_indent_file()
Called 1 time
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
    1              0.000005   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    1              0.000004   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
                              else
    1              0.000001     let head_spc = '\v(^ +)'
    1              0.000001   endif
    1              0.000038   let indent_tabs = search('\v(^\t+)', 'nw')
    1              0.000012   let indent_spc  = search(head_spc, 'nw')
    1              0.000002   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
                              else
    1              0.000000     return ''
                              endif

FUNCTION  airline#extensions#tabline#buffers#get()
Called 14 times
Total time:   0.133834
 Self time:   0.003770

count  total (s)   self (s)
   14              0.000038   try
   14   0.004320   0.000169     call <sid>map_keys()
   14              0.000032   catch
                                " no-op
                              endtry
   14              0.000124   let cur = bufnr('%')
   14              0.000095   if cur == s:current_bufnr && &columns == s:column_width
    9              0.000109     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
    3              0.000017       return s:current_tabline
                                endif
    6              0.000008   endif
                            
   11   0.001728   0.000121   let b = airline#extensions#tabline#new_builder()
   11              0.000081   let tab_bufs = tabpagebuflist(tabpagenr())
   11              0.000040   let show_buf_label_first = 0
                            
   11              0.000055   if get(g:, 'airline#extensions#tabline#buf_label_first', 0)
                                let show_buf_label_first = 1
                              endif
   11              0.000029   if show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers')
                              endif
                            
   11              0.000087   let b.tab_bufs = tabpagebuflist(tabpagenr())
                            
   11              0.000038   let b.overflow_group = 'airline_tabhid'
   11   0.001245   0.000115   let b.buffers = airline#extensions#tabline#buflist#list()
   11              0.000051   if get(g:, 'airline#extensions#tabline#current_first', 0)
                                if index(b.buffers, cur) > -1
                                  call remove(b.buffers, index(b.buffers, cur))
                                endif
                                let b.buffers = [cur] + b.buffers
                              endif
                            
   11              0.000050   function! b.get_group(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                if bufnum == -1
                                  return ''
                                endif
                                let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
                                if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
   11              0.000105   if has("tablineat")
                                function! b.get_pretitle(i) dict
                                  let bufnum = get(self.buffers, a:i, -1)
                                  return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'
                                endfunction
                            
                                function b.get_posttitle(i) dict
                                  return '%X'
                                endfunction
                              endif
                            
   11              0.000025   function! b.get_title(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                let group = self.get_group(a:i)
                                let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
                                if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
                                  let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
                                if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. get(s:number_map, a:i+1, '') . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
                                  return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif
                              endfunction
                            
   11              0.000118   let current_buffer = max([index(b.buffers, cur), 0])
   11              0.000086   let last_buffer = len(b.buffers) - 1
   11   0.000557   0.000125   call b.insert_titles(current_buffer, 0, last_buffer)
                            
   11   0.000188   0.000084   call b.add_section('airline_tabfill', '')
   11   0.000152   0.000064   call b.split()
   11   0.000143   0.000068   call b.add_section('airline_tabfill', '')
   11              0.000030   if !show_buf_label_first
   11   0.000713   0.000111     call airline#extensions#tabline#add_label(b, 'buffers')
   11              0.000011   endif
                            
   11              0.000046   if tabpagenr('$') > 1
                                call b.add_section_spaced('airline_tabmod', printf('%s %d/%d', "tab", tabpagenr(), tabpagenr('$')))
                              endif
                            
   11              0.000039   let s:current_bufnr = cur
   11              0.000046   let s:column_width = &columns
   11   0.121981   0.000106   let s:current_tabline = b.build()
   11              0.000061   let s:current_visible_buffers = copy(b.buffers)
   11              0.000022   if b._right_title <= last_buffer
                                call remove(s:current_visible_buffers, b._right_title, last_buffer)
                              endif
   11              0.000013   if b._left_title > 0
                                call remove(s:current_visible_buffers, 0, b._left_title)
                              endif
   11              0.000024   return s:current_tabline

FUNCTION  <SNR>179_gethistloc()
Called 4 times
Total time:   0.000603
 Self time:   0.000272

count  total (s)   self (s)
    4   0.000103   0.000074 	let utilcadir = ctrlp#utils#cachedir()
    4   0.000266   0.000084 	let cache_dir = utilcadir.s:lash(utilcadir).'hist'
    4   0.000228   0.000108 	retu [cache_dir, cache_dir.s:lash(cache_dir).'cache.txt']

FUNCTION  <SNR>179_getinput()
Called 8 times
Total time:   0.001058
 Self time:   0.001058

count  total (s)   self (s)
    8              0.000098 	let [prt, spi] = [s:prompt, ( a:0 ? a:1 : '' )]
    8              0.000052 	if s:abbrev != {}
                            		let gmd = has_key(s:abbrev, 'gmode') ? s:abbrev['gmode'] : ''
                            		let str = ( gmd =~ 't' && !a:0 ) || spi == 'c' ? prt[0] : join(prt, '')
                            		if gmd =~ 't' && gmd =~ 'k' && !a:0 && matchstr(str, '.$') =~ '\k'
                            			retu join(prt, '')
                            		en
                            		let [pf, rz] = [( s:byfname() ? 'f' : 'p' ), ( s:regexp ? 'r' : 'z' )]
                            		for dict in s:abbrev['abbrevs']
                            			let dmd = has_key(dict, 'mode') ? dict['mode'] : ''
                            			let pat = escape(dict['pattern'], '~')
                            			if ( dmd == '' || ( dmd =~ pf && dmd =~ rz && !a:0 ) || dmd =~ '['.spi.']' ) && str =~ pat
                            				let [str, s:did_exp] = [join(split(str, pat, 1), dict['expanded']), 1]
                            			en
                            		endfo
                            		if gmd =~ 't' && !a:0
                            			let prt[0] = str
                            		el
                            			retu str
                            		en
                            	en
    8              0.000118 	retu spi == 'c' ? prt[0] : join(prt, '')

FUNCTION  airline#highlighter#highlight()
Called 7 times
Total time:   0.262885
 Self time:   0.029299

count  total (s)   self (s)
    7              0.000019   let bufnr = a:0 ? a:1 : ''
    7              0.000021   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    7              0.000076   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    7              0.000020   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   20              0.000033   for mode in mapped
   13              0.000031     if mode == 'inactive' && winnr('$') == 1
                                  " there exist no inactive windows, don't need to create all those
                                  " highlighting groups
                                  continue
                                endif
   13              0.000078     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   12              0.000034       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  244              0.000529       for kvp in items(dict)
  232              0.000566         let mode_colors = kvp[1]
  232              0.000398         let name = kvp[0]
  232              0.000616         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
    5              0.000009           let name = 'airline_c'.bufnr
    5              0.000003         endif
  232   0.047108   0.001440         call airline#highlighter#exec(name.suffix, mode_colors)
                            
  696              0.001203         for accent in keys(s:accents)
  464              0.001060           if !has_key(p.accents, accent)
                                        continue
                                      endif
  464              0.001396           let colors = copy(mode_colors)
  464              0.001230           if p.accents[accent][0] != ''
  232              0.000606             let colors[0] = p.accents[accent][0]
  232              0.000135           endif
  464              0.000838           if p.accents[accent][2] != ''
  232              0.000515             let colors[2] = p.accents[accent][2]
  232              0.000125           endif
  464              0.000819           if len(colors) >= 5
  464              0.001423             let colors[4] = get(p.accents[accent], 4, '')
  464              0.000306           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
  464   0.096776   0.003107           call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  464              0.000411         endfor
  232              0.000177       endfor
                            
                                  " TODO: optimize this
  228              0.000462       for sep in items(s:separators)
  216   0.096268   0.002019         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  216              0.000190       endfor
   12              0.000009     endif
   13              0.000008   endfor

FUNCTION  <SNR>138_goto_win()
Called 42 times
Total time:   0.125175
 Self time:   0.014559

count  total (s)   self (s)
   42              0.000341     let cmd = type(a:winnr) == type(0) ? a:winnr . 'wincmd w' : 'wincmd ' . a:winnr
   42              0.000138     let noauto = a:0 > 0 ? a:1 : 0
                            
   42   0.000817   0.000360     call tagbar#debug#log("goto_win(): " . cmd . ", " . noauto)
                            
   42              0.000065     if noauto
   37   0.031226   0.001135         noautocmd execute cmd
   37              0.000041     else
    5   0.031124   0.004238         execute cmd
    5              0.000005     endif

FUNCTION  <SNR>117_has_fugitive()
Called 223 times
Total time:   0.002363
 Self time:   0.002363

count  total (s)   self (s)
  223              0.002094   return exists('*fugitive#head')

FUNCTION  fugitive#buffer()
Called 4 times
Total time:   0.000172
 Self time:   0.000031

count  total (s)   self (s)
    4   0.000170   0.000029   return s:buffer(a:0 ? a:1 : '%')

FUNCTION  airline#extensions#default#apply()
Called 18 times
Total time:   0.017661
 Self time:   0.001832

count  total (s)   self (s)
   18              0.000098   let winnr = a:context.winnr
   18              0.000069   let active = a:context.active
                            
   18   0.000347   0.000212   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    9   0.003711   0.000103     call s:build_sections(a:builder, a:context, s:layout[0])
    9              0.000013   else
    9   0.000885   0.000114     let text = s:get_section(winnr, 'c')
    9              0.000030     if empty(text)
                                  let text = ' %f%m '
                                endif
    9   0.000231   0.000145     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
    9              0.000013   endif
                            
   18   0.001518   0.000278   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
   18   0.000224   0.000130   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
   18   0.010140   0.000245     call s:build_sections(a:builder, a:context, s:layout[1])
   18              0.000023   endif
                            
   18              0.000032   return 1

FUNCTION  <SNR>147_get()
Called 85 times
Total time:   0.001613
 Self time:   0.001613

count  total (s)   self (s)
   85              0.000626     if !exists('t:tagbar_state')
                                    let t:tagbar_state = s:State.New()
                                endif
                            
   85              0.000298     return t:tagbar_state

FUNCTION  <SNR>115_is_branch_empty()
Called 223 times
Total time:   0.004797
 Self time:   0.004797

count  total (s)   self (s)
  223              0.004478   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  <SNR>179_MatchedItems()
Called 5 times
Total time:   0.006704
 Self time:   0.000662

count  total (s)   self (s)
    5              0.000048 	let exc = exists('s:crfilerel') ? s:crfilerel : ''
    5   0.000241   0.000095 	let items = s:narrowable() ? s:matched + s:mdata[3] : a:items
    5   0.000301   0.000060 	let matcher = s:getextvar('matcher')
    5              0.000054 	if empty(matcher) || type(matcher) != 4 || !has_key(matcher, 'match')
    5              0.000020 		unlet matcher
    5              0.000022 		let matcher = s:matcher
    5              0.000009 	en
    5              0.000017 	if matcher != {}
                            		let argms = has_key(matcher, 'arg_type') && matcher['arg_type'] == 'dict' ? [{ 'items':  items, 'str':    a:pat, 'limit':  a:limit, 'mmode':  s:mmode(), 'ispath': s:ispath, 'crfile': exc, 'regex':  s:regexp, }] : [items, a:pat, a:limit, s:mmode(), s:ispath, exc, s:regexp]
                            		let lines = call(matcher['match'], argms, matcher)
                            	el
    5   0.005741   0.000086 		let lines = s:MatchIt(items, a:pat, a:limit, exc)
    5              0.000010 	en
    5              0.000032 	let s:matches = len(lines)
    5              0.000022 	unl! s:did_exp
    5              0.000014 	retu lines

FUNCTION  <SNR>110_sync_active_winnr()
Called 192 times
Total time:   0.005188
 Self time:   0.005188

count  total (s)   self (s)
  192              0.003115   if exists('#airline') && winnr() != s:active_winnr
                                call airline#update_statusline()
                              endif

FUNCTION  <SNR>136_build_sections()
Called 27 times
Total time:   0.013503
 Self time:   0.002525

count  total (s)   self (s)
  144              0.000316   for key in a:keys
  117              0.000547     if (key == 'warning' || key == 'error') && !a:context.active
   18              0.000026       continue
                                endif
   99   0.011845   0.000867     call s:add_section(a:builder, a:context, key)
   99              0.000131   endfor

FUNCTION  airline#parts#filetype()
Called 225 times
Total time:   0.003903
 Self time:   0.003903

count  total (s)   self (s)
  225              0.003594   return winwidth(0) < 90 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
Called 9 times
Total time:   0.000341
 Self time:   0.000341

count  total (s)   self (s)
    9              0.000080   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  airline#parts#iminsert()
Called 223 times
Total time:   0.004176
 Self time:   0.004176

count  total (s)   self (s)
  223              0.001699   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
  223              0.000563   return ''

FUNCTION  425()
Called 1 time
Total time:   0.000165
 Self time:   0.000055

count  total (s)   self (s)
    1              0.000005     let bufnum = get(self.buffers, a:i, -1)
    1   0.000065   0.000006     let group = self.get_group(a:i)
    1   0.000058   0.000007     let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
    1              0.000004     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1              0.000003       let space = s:spc
    1              0.000001     else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
    1              0.000003     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. get(s:number_map, a:i+1, '') . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
    1              0.000006       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif

FUNCTION  <SNR>159_ReceiveMessages()
Called 4 times
Total time:   0.006990
 Self time:   0.000391

count  total (s)   self (s)
    4   0.006759   0.000160   let poll_again = s:Pyeval( 'ycm_state.OnPeriodicTick()' )
                            
    4              0.000039   if poll_again
    2              0.000046     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
    2              0.000004   else
                                " Don't poll again until we open another buffer
    2              0.000029     let s:pollers.receive_messages.id = -1
    2              0.000008   endif

FUNCTION  <SNR>138_PrintKinds()
Called 1 time
Total time:   0.001893
 Self time:   0.000310

count  total (s)   self (s)
    1   0.000010   0.000004     call tagbar#debug#log('PrintKinds called')
                            
                                " If the short or long help is being displayed then the line numbers don't
                                " match up with the length of the output list
    1              0.000004     let offset = g:tagbar_compact && s:short_help ? 0 : line('.')
    1              0.000001     let output = []
                            
    7              0.000005     for kind in a:typeinfo.kinds
    6   0.000060   0.000051         let curtags = filter(copy(a:fileinfo.getTags()), 'v:val.fields.kind ==# kind.short')
    6   0.000061   0.000032         call tagbar#debug#log('Printing kind: ' . kind.short . ', number of (top-level) tags: ' . len(curtags))
                            
    6              0.000008         if empty(curtags)
    4              0.000004             continue
                                    endif
                            
    2              0.000007         if has_key(get(a:typeinfo, 'kind2scope', {}), kind.short)
                                        " Scoped tags
    2              0.000002             for tag in curtags
    1   0.001548   0.000014                 call s:PrintTag(tag, 0, output, a:fileinfo, a:typeinfo)
                            
    1              0.000001                 if !g:tagbar_compact
    1              0.000002                     call add(output, "")
    1              0.000001                 endif
    1              0.000000             endfor
    1              0.000000         else
                                        " Non-scoped tags
    1              0.000002             let kindtag = curtags[0].parent
                            
    1   0.000011   0.000008             if kindtag.isFolded()
    1              0.000002                 let foldmarker = g:tagbar#icon_closed
    1              0.000001             else
                                            let foldmarker = g:tagbar#icon_open
                                        endif
                            
    1              0.000002             let padding = g:tagbar_show_visibility ? ' ' : ''
    1              0.000004             call add(output, foldmarker . padding . kind.long)
                            
    1              0.000003             let curline                   = len(output) + offset
    1              0.000002             let kindtag.tline             = curline
    1              0.000003             let a:fileinfo.tline[curline] = kindtag
                            
    1   0.000005   0.000003             if !kindtag.isFolded()
                                            for tag in curtags
                                                let str = tag.strfmt()
                                                call add(output, repeat(' ', g:tagbar_indent) . str)
                            
                                                " Save the current tagbar line in the tag for easy
                                                " highlighting access
                                                let curline                   = len(output) + offset
                                                let tag.tline                 = curline
                                                let a:fileinfo.tline[curline] = tag
                                                let tag.depth                 = 1
                                            endfor
                                        endif
                            
    1              0.000001             if !g:tagbar_compact
    1              0.000002                 call add(output, "")
    1              0.000000             endif
    1              0.000001         endif
    2              0.000001     endfor
                            
    1              0.000004     let outstr = join(output, "\n")
    1              0.000001     if g:tagbar_compact && s:short_help
                                    silent 0put =outstr
                                else
    1              0.000025         silent  put =outstr
    1              0.000001     endif

FUNCTION  airline#extensions#term#apply()
Called 9 times
Total time:   0.000246
 Self time:   0.000246

count  total (s)   self (s)
    9              0.000025   if &buftype == 'terminal'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'TERMINAL'.spc)
                                call a:1.add_section('airline_b', '')
                                call a:1.add_section('airline_c', spc.'%f')
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section('airline_z', spc.airline#section#create_right(['linenr', 'maxlinenr']))
                                return 1
                              endif

FUNCTION  <SNR>47_exists_file()
Called 8 times
Total time:   0.000734
 Self time:   0.000270

count  total (s)   self (s)
    8   0.000720   0.000256   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  tagbar#sorting#sort()
Called 2 times
Total time:   0.001141
 Self time:   0.000103

count  total (s)   self (s)
    2              0.000005     let s:compare_typeinfo = a:compare_typeinfo
                            
    2              0.000006     let comparemethod = a:compareby == 'kind' ? 's:compare_by_kind' : 's:compare_by_line'
                            
    2   0.000537   0.000059     call sort(a:tags, comparemethod)
                            
   16              0.000010     for tag in a:tags
   14   0.000053   0.000038         if !empty(tag.getChildren())
    1   0.000006   0.000005             call tagbar#sorting#sort(tag.getChildren(), a:compareby, a:compare_typeinfo)
    1              0.000001         endif
   14              0.000008     endfor

FUNCTION  <SNR>158_process_hunk()
Called 8 times
Total time:   0.001577
 Self time:   0.000777

count  total (s)   self (s)
    8              0.000019   let modifications = []
    8              0.000025   let from_line  = a:hunk[0]
    8              0.000020   let from_count = a:hunk[1]
    8              0.000022   let to_line    = a:hunk[2]
    8              0.000023   let to_count   = a:hunk[3]
                            
    8   0.000072   0.000047   if s:is_added(from_count, to_count)
    1   0.000040   0.000011     call s:process_added(modifications, from_count, to_count, to_line)
    1   0.000072   0.000018     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
    1              0.000004   elseif s:is_removed(from_count, to_count)
    4   0.000085   0.000038     call s:process_removed(modifications, from_count, to_count, to_line)
    4   0.000232   0.000029     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
    4              0.000012   elseif s:is_modified(from_count, to_count)
    2   0.000175   0.000029     call s:process_modified(modifications, from_count, to_count, to_line)
    2   0.000127   0.000018     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
    2              0.000006   elseif s:is_modified_and_added(from_count, to_count)
                                call s:process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
                              elseif s:is_modified_and_removed(from_count, to_count)
    1   0.000052   0.000019     call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
    1   0.000059   0.000007     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
    1   0.000054   0.000008     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
    1              0.000001   endif
    8              0.000016   return modifications

FUNCTION  <SNR>103_are_lines_prev_blank()
Called 3 times
Total time:   0.000501
 Self time:   0.000501

count  total (s)   self (s)
    3              0.000018     let lnum_prev = a:lnum - 1
   27              0.000063     while lnum_prev != 0
   24              0.000183         if !a:cache[lnum_prev]['is_blank'] && !a:cache[lnum_prev]['is_comment']
                                        return 0
                                    endif
   24              0.000063         let lnum_prev -= 1
   24              0.000035     endwhile
    3              0.000008     return 1

FUNCTION  <SNR>117_init_buffer()
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000002   let b:buffer_vcs_config = {}
    3              0.000006   for vcs in keys(s:vcs_config)
    2              0.000007     let b:buffer_vcs_config[vcs] = {     'branch': '',     'untracked': '',   }
    2              0.000001   endfor
    1              0.000002   unlet! b:airline_head

FUNCTION  <SNR>68_BufReadPostHook()
Called 1 time
Total time:   0.000163
 Self time:   0.000028

count  total (s)   self (s)
    1   0.000127   0.000005     let buf = syntastic#util#fname2buf(a:fname)
    1              0.000002     if g:syntastic_check_on_open && buf > 0
    1   0.000026   0.000013         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufReadPost, buffer ' . buf . ' = ' . string(a:fname))
    1              0.000003         if index(s:_check_stack, buf) == -1
    1              0.000003             call add(s:_check_stack, buf)
    1              0.000000         endif
    1              0.000000     endif

FUNCTION  <SNR>179_PrtFocusMap()
Called 5 times
Total time:   0.260185
 Self time:   0.000206

count  total (s)   self (s)
    5   0.260174   0.000195 	cal call(( s:focus ? 's:PrtAdd' : 's:PrtSelectJump' ), [a:char])

FUNCTION  ctrlp#setlcdir()
Called 1 time
Total time:   0.000239
 Self time:   0.000054

count  total (s)   self (s)
    1              0.000013 	if exists('*haslocaldir')
    1   0.000223   0.000038 		cal ctrlp#setdir(getcwd(), haslocaldir() ? 'lc!' : 'cd!')
    1              0.000001 	en

FUNCTION  gitgutter#hunk#summary()
Called 231 times
Total time:   0.013395
 Self time:   0.005336

count  total (s)   self (s)
  231   0.013104   0.005045   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  airline#extensions#ctrlp#ctrlp_airline()
Called 7 times
Total time:   0.113100
 Self time:   0.000896

count  total (s)   self (s)
    7   0.000545   0.000096   let b = airline#builder#new({'active': 1})
    7              0.000027   if a:2 == 'file'
                                call b.add_section_spaced('CtrlPlight', 'by fname')
                              endif
    7              0.000017   if a:3
                                call b.add_section_spaced('CtrlPlight', 'regex')
                              endif
    7              0.000052   if get(g:, 'airline#extensions#ctrlp#show_adjacent_modes', 1)
    7   0.000345   0.000083     call b.add_section_spaced('CtrlPlight', a:4)
    7   0.000270   0.000075     call b.add_section_spaced('CtrlPwhite', a:5)
    7   0.000224   0.000056     call b.add_section_spaced('CtrlPlight', a:6)
    7              0.000013   else
                                call b.add_section_spaced('CtrlPwhite', a:5)
                              endif
    7   0.000216   0.000053   call b.add_section_spaced('CtrlPdark', a:7)
    7   0.000110   0.000047   call b.split()
    7   0.000217   0.000048   call b.add_section_spaced('CtrlPdark', a:1)
    7   0.000207   0.000047   call b.add_section_spaced('CtrlPdark', a:2)
    7   0.000208   0.000052   call b.add_section_spaced('CtrlPlight', '%{getcwd()}')
    7   0.110491   0.000072   return b.build()

FUNCTION  <SNR>179_opts()
Called 1 time
Total time:   0.002474
 Self time:   0.002027

count  total (s)   self (s)
    1              0.000007 	unl! s:usrign s:usrcmd s:urprtmaps
    6              0.000040 	for each in ['byfname', 'regexp', 'extensions'] | if exists('s:'.each)
                            		let {each} = s:{each}
    3              0.000010 	en | endfo
   47              0.000211 	for [ke, va] in items(s:opts)
   46              0.000732 		let {va[0]} = exists(s:pref.ke) ? {s:pref.ke} : va[1]
   46              0.000085 	endfo
    1              0.000007 	unl va
    6              0.000045 	for [ke, va] in items(s:new_opts)
    5              0.000121 		let {va} = {exists(s:pref.ke) ? s:pref.ke : va}
    5              0.000014 	endfo
    1              0.000006 	unl va
    4              0.000033 	for [ke, va] in items(s:lc_opts)
    3              0.000039 		if exists(s:bpref.ke)
                            			unl {va}
                            			let {va} = {s:bpref.ke}
                            		en
    3              0.000007 	endfo
                            	" Match window options
    1   0.000520   0.000107 	cal s:match_window_opts()
                            	" One-time values
    1              0.000009 	if a:0 && a:1 != {}
                            		unl va
                            		for [ke, va] in items(a:1)
                            			let opke = substitute(ke, '\(\w:\)\?ctrlp_', '', '')
                            			if has_key(s:lc_opts, opke)
                            				let sva = s:lc_opts[opke]
                            				unl {sva}
                            				let {sva} = va
                            			en
                            		endfo
                            	en
    4              0.000041 	for each in ['byfname', 'regexp'] | if exists(each)
                            		let s:{each} = {each}
    2              0.000010 	en | endfo
    1              0.000029 	if !exists('g:ctrlp_tilde_homedir') | let g:ctrlp_tilde_homedir = 0 | en
    1              0.000018 	if !exists('g:ctrlp_newcache') | let g:ctrlp_newcache = 0 | en
    1              0.000013 	let s:maxdepth = min([s:maxdepth, 100])
    1              0.000009 	let s:glob = s:showhidden ? '.*\|*' : '*'
    1              0.000044 	let s:igntype = empty(s:usrign) ? -1 : type(s:usrign)
    1   0.000072   0.000038 	let s:lash = ctrlp#utils#lash()
    1              0.000006 	if s:keyloop
                            		let [s:lazy, s:glbs['imd']] = [0, 0]
                            	en
    1              0.000003 	if s:lazy
                            		cal extend(s:glbs, { 'ut': ( s:lazy > 1 ? s:lazy : 250 ) })
                            	en
                            	" Extensions
    1              0.000012 	if !( exists('extensions') && extensions == s:extensions )
    1              0.000008 		for each in s:extensions
                            			exe 'ru autoload/ctrlp/'.each.'.vim'
                            		endfo
    1              0.000003 	en
                            	" Keymaps
    1              0.000009 	if type(s:urprtmaps) == 4
                            		cal extend(s:prtmaps, s:urprtmaps)
                            	en

FUNCTION  <SNR>142_add_snr()
Called 9 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    9              0.000023     if !exists("s:snr")
                                    let s:snr = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeget_snr$')
                                endif
    9              0.000012     return s:snr . a:funcname

FUNCTION  SyntasticRefreshCursor()
Called 2 times
Total time:   0.000243
 Self time:   0.000204

count  total (s)   self (s)
    2              0.000022     if !exists('b:syntastic_private_messages') || empty(b:syntastic_private_messages)
                                    " file not checked
    1              0.000003         return
                                endif
                            
    1              0.000005     if !exists('b:syntastic_private_line')
                                    let b:syntastic_private_line = -1
                                endif
    1              0.000005     let l = line('.')
    1              0.000011     let current_messages = get(b:syntastic_private_messages, l, {})
                            
    1              0.000006     if !exists('b:syntastic_cursor_columns')
                                    let b:syntastic_cursor_columns = g:syntastic_cursor_columns
                                endif
                            
    1              0.000003     if b:syntastic_cursor_columns
    1              0.000005         let c = virtcol('.')
    1              0.000005         if !exists('b:syntastic_private_idx')
    1              0.000005             let b:syntastic_private_idx = -1
    1              0.000001         endif
                            
    1   0.000060   0.000021         if s:_is_same_index(l, b:syntastic_private_line, c, b:syntastic_private_idx, current_messages)
                                        return
                                    else
    1              0.000004             let b:syntastic_private_line = l
    1              0.000001         endif
                            
    1              0.000004         if !empty(current_messages)
                                        let b:syntastic_private_idx = s:_find_index(c, current_messages)
                                        call syntastic#util#wideMsg(current_messages[b:syntastic_private_idx].text)
                                    else
    1              0.000003             let b:syntastic_private_idx = -1
    1              0.000041             echo
    1              0.000002         endif
    1              0.000001     else
                                    if l == b:syntastic_private_line
                                        return
                                    endif
                                    let b:syntastic_private_line = l
                            
                                    if !empty(current_messages)
                                        call syntastic#util#wideMsg(current_messages[0].text)
                                    else
                                        echo
                                    endif
                                endif

FUNCTION  airline#extensions#wordcount#apply()
Called 9 times
Total time:   0.000485
 Self time:   0.000485

count  total (s)   self (s)
    9              0.000418   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                call airline#extensions#prepend_to_section('z', '%{get(b:, "airline_wordcount", "")}')
                              endif

FUNCTION  <SNR>45_record()
Called 2 times
Total time:   0.010943
 Self time:   0.000174

count  total (s)   self (s)
    2              0.000022 	if s:locked | retu | en
    2              0.000012 	let bufnr = a:bufnr + 0
    2              0.000017 	let bufname = bufname(bufnr)
    2              0.000014 	if bufnr > 0 && !empty(bufname)
    2              0.000050 		cal filter(s:mrbs, 'v:val != bufnr')
    2              0.000013 		cal insert(s:mrbs, bufnr)
    2   0.010804   0.000035 		cal s:addtomrufs(bufname)
    2              0.000004 	en

FUNCTION  <SNR>131_get_array()
Called 2855 times
Total time:   0.030180
 Self time:   0.030180

count  total (s)   self (s)
 2855              0.012602   let opts=empty(a:opts) ? '' : join(a:opts, ',')
 2855              0.016125   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  ctrlp#statusline()
Called 7 times
Total time:   0.114757
 Self time:   0.001412

count  total (s)   self (s)
    7              0.000042 	if !exists('s:statypes')
    1              0.000003 		let s:statypes = copy(s:coretypes)
    1              0.000002 		if !empty(g:ctrlp_ext_vars)
                            			cal map(copy(g:ctrlp_ext_vars), 'add(s:statypes, [ v:val["lname"], v:val["sname"] ])')
                            		en
    1              0.000000 	en
    7              0.000026 	let tps = s:statypes
    7              0.000048 	let max = len(tps) - 1
    7   0.000189   0.000116 	let nxt = tps[s:walker(max, s:itemtype,  1)][1]
    7   0.000131   0.000079 	let prv = tps[s:walker(max, s:itemtype, -1)][1]
    7              0.000046 	let s:ctype = tps[s:itemtype][0]
    7              0.000037 	let focus   = s:focus ? 'prt'  : 'win'
    7              0.000041 	let byfname = s:ispath ? s:byfname ? 'file' : 'path' : 'line'
    7              0.000085 	let marked  = s:opmul != '0' ? exists('s:marked') ? ' <'.s:dismrk().'>' : ' <->' : ''
    7              0.000031 	if s:status != {}
    7              0.000168 		let argms = has_key(s:status, 'arg_type') && s:status['arg_type'] == 'dict' ? [{ 'focus':   focus, 'byfname': byfname, 'regex':   s:regexp, 'prev':    prv, 'item':    s:ctype, 'next':    nxt, 'marked':  marked, }] : [focus, byfname, s:regexp, prv, s:ctype, nxt, marked]
    7   0.113588   0.000368 		let &l:stl = call(s:status['main'], argms, s:status)
    7              0.000013 	el
                            		let item    = '%#CtrlPMode1# '.s:ctype.' %*'
                            		let focus   = '%#CtrlPMode2# '.focus.' %*'
                            		let byfname = '%#CtrlPMode1# '.byfname.' %*'
                            		let regex   = s:regexp  ? '%#CtrlPMode2# regex %*' : ''
                            		let slider  = ' <'.prv.'>={'.item.'}=<'.nxt.'>'
                            		let dir     = ' %=%<%#CtrlPMode2# %{getcwd()} %*'
                            		let &l:stl  = focus.byfname.regex.slider.marked.dir
                            	en

FUNCTION  <SNR>159_DisableOnLargeFile()
Called 186 times
Total time:   0.003052
 Self time:   0.003052

count  total (s)   self (s)
  186              0.001759   if exists( 'b:ycm_largefile' )
  185              0.000899     return b:ycm_largefile
                              endif
                            
    1              0.000002   let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
    1              0.000014   let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
    1              0.000001   if b:ycm_largefile
                                exec s:python_command "vimsupport.PostVimMessage(" . "'YouCompleteMe is disabled in this buffer; " . "the file exceeded the max size (see YCM options).' )"
                              endif
    1              0.000001   return b:ycm_largefile

FUNCTION  300()
Called 1 time
Total time:   0.000036
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000001     if s:has_highlighting
    1   0.000009   0.000003         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: reset')
    1   0.000024   0.000004         call self._reset()
    1              0.000001     endif

FUNCTION  302()
Called 4 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
    8              0.000021     for match in getmatches()
    4              0.000012         if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
    4              0.000001     endfor

FUNCTION  303()
Called 4 times
Total time:   0.000269
 Self time:   0.000269

count  total (s)   self (s)
    4              0.000071     let newObj = copy(self)
                            
    4              0.000038     let llist = filter(copy(a:rawLoclist), 'v:val["valid"]')
                            
   29              0.000022     for e in llist
   25              0.000034         if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
   25              0.000011     endfor
                            
    4              0.000008     let newObj._rawLoclist = llist
    4              0.000004     let newObj._name = ''
    4              0.000009     let newObj._owner = bufnr('')
    4              0.000004     let newObj._sorted = 0
    4              0.000009     let newObj._columns = g:syntastic_cursor_columns
                            
    4              0.000003     return newObj

FUNCTION  304()
Called 450 times
Total time:   0.034255
 Self time:   0.026134

count  total (s)   self (s)
  450              0.004518     let buf = a:0 ? a:1 : bufnr('')
  450   0.016318   0.008241     let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
  450              0.005510     if type(loclist) != type({}) || empty(loclist)
    1              0.000001         unlet! loclist
    1   0.000049   0.000005         let loclist = g:SyntasticLoclist.New([])
    1              0.000001     endif
  450              0.001431     return loclist

FUNCTION  305()
Called 1 time
Total time:   0.000013
 Self time:   0.000006

count  total (s)   self (s)
    1   0.000013   0.000006     call extend(self._rawLoclist, a:other.copyRaw())

FUNCTION  307()
Called 22 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
   22              0.000049     return empty(self._rawLoclist)

FUNCTION  308()
Called 7 times
Total time:   0.000222
 Self time:   0.000076

count  total (s)   self (s)
    7              0.000019     if !exists('self._stamp')
                                    let self._stamp = []
                                    return 0
                                endif
    7   0.000180   0.000034     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  309()
Called 4 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    4              0.000012     return copy(self._rawLoclist)

FUNCTION  ctrlp#mrufiles#bufs()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000012 	retu s:mrbs

FUNCTION  fugitive#detect()
Called 1 time
Total time:   0.001608
 Self time:   0.000177

count  total (s)   self (s)
    1              0.000003   if exists('b:git_dir') && (b:git_dir ==# '' || b:git_dir =~# '/$')
                                unlet b:git_dir
                              endif
    1              0.000002   if !exists('b:git_dir')
    1   0.000204   0.000013     let dir = fugitive#extract_git_dir(a:path)
    1              0.000001     if dir !=# ''
    1              0.000001       let b:git_dir = dir
    1   0.000532   0.000017       if empty(fugitive#buffer().path())
                                    silent! exe haslocaldir() ? 'lcd .' : 'cd .'
                                  endif
    1              0.000001     endif
    1              0.000001   endif
    1              0.000002   if exists('b:git_dir')
    1              0.000006     if exists('#User#FugitiveBoot')
                                  try
                                    let [save_mls, &modelines] = [&mls, 0]
                                    doautocmd User FugitiveBoot
                                  finally
                                    let &mls = save_mls
                                  endtry
                                endif
    1              0.000001     if !exists('g:fugitive_no_maps')
    1              0.000023       cnoremap <buffer> <expr> <C-R><C-G> fnameescape(<SID>recall())
    1              0.000013       nnoremap <buffer> <silent> y<C-G> :call setreg(v:register, <SID>recall())<CR>
    1              0.000001     endif
    1   0.000030   0.000004     let buffer = fugitive#buffer()
    1              0.000007     if expand('%:p') =~# '://'
                                  call buffer.setvar('&path', s:sub(buffer.getvar('&path'), '^\.%(,|$)', ''))
                                endif
    1   0.000011   0.000008     if stridx(buffer.getvar('&tags'), escape(b:git_dir, ', ')) == -1
    1              0.000008       if filereadable(b:git_dir.'/tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/tags', ', ').','.buffer.getvar('&tags'))
                                  endif
    1              0.000005       if &filetype !=# '' && filereadable(b:git_dir.'/'.&filetype.'.tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/'.&filetype.'.tags', ', ').','.buffer.getvar('&tags'))
                                  endif
    1              0.000000     endif
    1              0.000001     try
    1              0.000009       let [save_mls, &modelines] = [&mls, 0]
    1   0.000336   0.000007       call s:define_commands()
    1   0.000373   0.000006       doautocmd User Fugitive
    1              0.000001     finally
    1              0.000007       let &mls = save_mls
    1              0.000001     endtry
    1              0.000000   endif

FUNCTION  <SNR>138_HandleOnlyWindow()
Called 5 times
Total time:   0.000577
 Self time:   0.000510

count  total (s)   self (s)
    5   0.000307   0.000240     let tagbarwinnr = bufwinnr(s:TagbarBufName())
    5              0.000011     if tagbarwinnr == -1
    1              0.000001         return
                                endif
                            
    4              0.000012     let vim_quitting = s:vim_quitting
    4              0.000012     let s:vim_quitting = 0
                            
    4              0.000015     if vim_quitting && !s:HasOpenFileWindows()
                                    call tagbar#debug#log('Closing Tagbar window due to QuitPre event')
                                    if winnr('$') >= 1
                                        call s:goto_win(tagbarwinnr, 1)
                                    endif
                            
                                    " Before quitting Vim, delete the tagbar buffer so that the '0 mark is
                                    " correctly set to the previous buffer.
                                    if tabpagenr('$') == 1
                                        noautocmd keepalt bdelete
                                    endif
                            
                                    try
                                        try
                                            quit
                                        catch /.*/ " This can be E173 and maybe others
                                            call s:OpenWindow('')
                                            echoerr v:exception
                                        endtry
                                    catch /.*/
                                        echohl ErrorMsg
                                        echo v:exception
                                        echohl None
                                    endtry
                                endif

FUNCTION  ctrlp#utils#readfile()
Called 2 times
Total time:   0.000430
 Self time:   0.000430

count  total (s)   self (s)
    2              0.000039 	if filereadable(a:file)
    2              0.000338 		let data = readfile(a:file)
    2              0.000024 		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
                            		en
    2              0.000006 		retu data
                            	en
                            	retu []

FUNCTION  <SNR>120_check_mixed_indent()
Called 1 time
Total time:   0.001032
 Self time:   0.001032

count  total (s)   self (s)
    1              0.000003   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    1              0.000001   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
    1              0.001018     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  <SNR>179_ignore()
Called 1 time
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
    1              0.000041 	let igdirs = [ '\.git', '\.hg', '\.svn', '_darcs', '\.bzr', '\.cdv', '\~\.dep', '\~\.dot', '\~\.nib', '\~\.plst', '\.pc', '_MTN', 'blib', 'CVS', 'RCS', 'SCCS', '_sgbak', 'autom4te\.cache', 'cover_db', '_build', ]
    1              0.000028 	let igfiles = [ '\~$', '#.+#$', '[._].*\.swp$', 'core\.\d+$', '\.exe$', '\.so$', '\.bak$', '\.png$', '\.jpg$', '\.gif$', '\.zip$', '\.rar$', '\.tar\.gz$', ]
    1              0.000089 	retu { 'dir': '\v[\/]('.join(igdirs, '|').')$', 'file': '\v'.join(igfiles, '|'), }

FUNCTION  <SNR>138_goto_markedwin()
Called 1 time
Total time:   0.000079
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000002     let noauto = a:0 > 0 ? a:1 : 0
    2              0.000006     for window in range(1, winnr('$'))
    2   0.000059   0.000008         call s:goto_win(window, noauto)
    2              0.000005         if exists('w:tagbar_mark')
    1              0.000001             unlet w:tagbar_mark
    1              0.000001             break
                                    endif
    1              0.000001     endfor

FUNCTION  <SNR>138_ParseTagline()
Called 14 times
Total time:   0.010097
 Self time:   0.002300

count  total (s)   self (s)
   14              0.000060     let basic_info  = split(a:part1, '\t')
   14              0.000030     let tagname  = basic_info[0]
   14              0.000025     let filename = basic_info[1]
                            
                                " the pattern can contain tabs and thus may have been split up, so join
                                " the rest of the items together again
   14              0.000049     let pattern = join(basic_info[2:], "\t")
   14              0.000025     if pattern[0] == '/'
   14              0.000015         let start   = 2 " skip the slash and the ^
   14              0.000034         let end     = strlen(pattern) - 1
   14              0.000028         if pattern[end - 1] ==# '$'
   14              0.000019             let end -= 1
   14              0.000016             let dollar = '\$'
   14              0.000010         else
                                        let dollar = ''
                                    endif
   14              0.000059         let pattern = '\V\^\C' . strpart(pattern, start, end - start) . dollar
   14              0.000008     else
                                    let pattern = ''
                                endif
                            
                                " When splitting fields make sure not to create empty keys or values in
                                " case a value illegally contains tabs
   14              0.000206     let fields = split(a:part2, '^\t\|\t\ze\w\+:')
   14              0.000018     let fielddict = {}
   14              0.000039     if fields[0] !~# ':'
   14              0.000040         let fielddict.kind = remove(fields, 0)
   14              0.000007     endif
   52              0.000049     for field in fields
                                    " can't use split() since the value can contain ':'
   38              0.000065         let delimit = stridx(field, ':')
   38              0.000079         let key = strpart(field, 0, delimit)
                                    " Remove all tabs that may illegally be in the value
   38              0.000164         let val = substitute(strpart(field, delimit + 1), '\t', '', 'g')
                                    " File-restricted scoping
   38              0.000039         if key == "file"
                                        let fielddict[key] = 'yes'
                                    endif
   38              0.000057         if len(val) > 0
   38              0.000048             if key == 'line' || key == 'column'
   14              0.000034                 let fielddict[key] = str2nr(val)
   14              0.000008             else
   24              0.000034                 let fielddict[key] = val
   24              0.000014             endif
   38              0.000015         endif
   38              0.000023     endfor
                            
                                " If the tag covers multiple scopes, split it up and create individual tags
                                " for each scope so that the hierarchy can be displayed correctly.
                                " This can happen with PHP's 'namespace' tags in uctags, for example.
   14              0.000093     if has_key(a:typeinfo, 'kind2scope') && has_key(a:typeinfo.kind2scope, fielddict.kind) && tagname =~# '\V' . escape(a:typeinfo.sro, '\')
                                    let tagparts = split(tagname, '\V' . escape(a:typeinfo.sro, '\'))
                            
                                    let scope = a:typeinfo.kind2scope[fielddict.kind]
                                    if has_key(fielddict, scope)
                                        let parent = fielddict[scope]
                                    else
                                        let parent = ''
                                    endif
                                    let curfielddict = fielddict
                            
                                    for i in range(len(tagparts))
                                        let part = tagparts[i]
                                        call s:ProcessTag(part, filename, pattern, curfielddict, i != len(tagparts) - 1, a:typeinfo, a:fileinfo)
                                        if parent != ''
                                            let parent = parent . a:typeinfo.sro . part
                                        else
                                            let parent = part
                                        endif
                                        let curfielddict = copy(fielddict)
                                        let curfielddict[scope] = parent
                                    endfor
                                else
   14   0.007905   0.000108         call s:ProcessTag(tagname, filename, pattern, fielddict, 0, a:typeinfo, a:fileinfo)
   14              0.000008     endif

FUNCTION  syntastic#util#stamp()
Called 7 times
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
    7              0.000125     return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )

FUNCTION  <SNR>131_exec_separator()
Called 606 times
Total time:   0.393005
 Self time:   0.031663

count  total (s)   self (s)
  606              0.001682   if pumvisible()
                                return
                              endif
  606   0.106657   0.004637   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  606   0.098655   0.004281   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  606              0.002483   let group = a:from.'_to_'.a:to.a:suffix
  606              0.000995   if a:inverse
  234              0.001903     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
  234              0.000426   else
  372              0.002579     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  372              0.000322   endif
  606              0.002478   let a:dict[group] = colors
  606   0.169924   0.004976   call airline#highlighter#exec(group, colors)

FUNCTION  ctrlp#setlines()
Called 1 time
Total time:   0.052621
 Self time:   0.000148

count  total (s)   self (s)
    1              0.000012 	if a:0 | let s:itemtype = a:1 | en
    1   0.000642   0.000017 	cal s:modevar()
    1              0.000018 	let inits = {'fil': 'ctrlp#files()', 'buf': 'ctrlp#buffers()', 'mru': 'ctrlp#mrufiles#list()'}
    1              0.000034 	let types = map(copy(g:ctrlp_types), 'inits[v:val]')
    1              0.000010 	if !empty(g:ctrlp_ext_vars)
                            		cal map(copy(g:ctrlp_ext_vars), 'add(types, v:val["init"])')
                            	en
    1   0.051887   0.000039 	let g:ctrlp_lines = eval(types[s:itemtype])

FUNCTION  <SNR>179_SetDefTxt()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004 	if s:deftxt == '0' || ( s:deftxt == 1 && !s:ispath ) | retu | en
                            	let txt = s:deftxt
                            	if !type(txt)
                            		let path = s:crfpath.s:lash(s:crfpath)
                            		let txt = txt && !stridx(path, s:dyncwd) ? ctrlp#rmbasedir([path])[0] : ''
                            	en
                            	let s:prompt[0] = txt

FUNCTION  gitgutter#utility#shellescape()
Called 16 times
Total time:   0.000672
 Self time:   0.000656

count  total (s)   self (s)
   16              0.000555   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   14              0.000044     return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
    2              0.000006     return shellescape(a:arg)
                              endif

FUNCTION  <SNR>179_SetWD()
Called 1 time
Total time:   0.001760
 Self time:   0.000238

count  total (s)   self (s)
    1              0.000023 	if has_key(a:args, 'args') && stridx(a:args['args'], '--dir') >= 0 && exists('s:dyncwd')
                            		cal ctrlp#setdir(s:dyncwd) | retu
                            	en
    1              0.000012 	if has_key(a:args, 'dir') && a:args['dir'] != ''
                            		cal ctrlp#setdir(a:args['dir']) | retu
                            	en
    1              0.000013 	let pmodes = has_key(a:args, 'mode') ? a:args['mode'] : s:pathmode
    1              0.000046 	let [s:crfilerel, s:dyncwd] = [fnamemodify(s:crfile, ':.'), getcwd()]
    1              0.000009 	if (!type(pmodes))
                            		let pmodes = pmodes == 0 ? '' : pmodes == 1 ? 'a' : pmodes == 2 ? 'r' : 'c'
                            	en
    1              0.000024 	let spath = pmodes =~ 'd' ? s:dyncwd : pmodes =~ 'w' ? s:cwd : s:crfpath
    1              0.000033 	for pmode in split(pmodes, '\zs')
    1   0.001558   0.000036 		if ctrlp#setpathmode(pmode, spath) | retu | en
                            	endfo

FUNCTION  310()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002     return self._rawLoclist

FUNCTION  311()
Called 2 times
Total time:   0.000270
 Self time:   0.000059

count  total (s)   self (s)
    2   0.000269   0.000058     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])

FUNCTION  312()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002     return self._columns

FUNCTION  313()
Called 446 times
Total time:   0.079397
 Self time:   0.079305

count  total (s)   self (s)
  446              0.003659     if !exists('self._stl_format')
    1              0.000002         let self._stl_format = ''
    1              0.000000     endif
  446              0.002540     if !exists('self._stl_flag')
    1              0.000001         let self._stl_flag = ''
    1              0.000000     endif
                            
  446              0.002648     if g:syntastic_stl_format !=# self._stl_format
  446              0.002884         let self._stl_format = g:syntastic_stl_format
                            
  446              0.002380         if !empty(self._rawLoclist)
    4   0.000063   0.000024             let errors = self.errors()
    4   0.000053   0.000018             let warnings = self.warnings()
                            
    4              0.000011             let num_errors = len(errors)
    4              0.000009             let num_warnings = len(warnings)
    4              0.000008             let num_issues = len(self._rawLoclist)
                            
    4              0.000006             let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
    4              0.000050             let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
    4              0.000040             let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
    4              0.000023             let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
    4              0.000210             let flags = { '%':  '%', 't':  num_issues, 'e':  num_errors, 'w':  num_warnings, 'N':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':t') : ''), 'P':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':p:~:.') : ''), 'F':  (num_issues ? self._rawLoclist[0]['lnum'] : ''), 'ne': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':t') : ''), 'pe': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':p:~:.') : ''), 'fe': (num_errors ? errors[0]['lnum'] : ''), 'nw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':t') : ''), 'pw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':p:~:.') : ''), 'fw': (num_warnings ? warnings[0]['lnum'] : '') }
    4   0.000120   0.000102             let output = substitute(output, '\v\C\%(-?\d*%(\.\d+)?)([npf][ew]|[NPFtew%])', '\=syntastic#util#wformat(submatch(1), flags[submatch(2)])', 'g')
                            
    4              0.000009             let self._stl_flag = output
    4              0.000003         else
  442              0.002039             let self._stl_flag = ''
  442              0.000966         endif
  446              0.000832     endif
                            
  446              0.001714     return self._stl_flag

FUNCTION  316()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002     let self._name = a:name

FUNCTION  318()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004     let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)

FUNCTION  319()
Called 1 time
Total time:   0.000264
 Self time:   0.000019

count  total (s)   self (s)
    1   0.000024   0.000005     let self._stamp = syntastic#util#stamp()
    2   0.000232   0.000006     for buf in self.getBuffers()
    1              0.000004         call setbufvar(buf, 'syntastic_loclist', self)
    1              0.000001     endfor

FUNCTION  airline#extensions#po#apply()
Called 9 times
Total time:   0.000149
 Self time:   0.000149

count  total (s)   self (s)
    9              0.000068   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                              endif

FUNCTION  airline#extensions#tabline#formatters#webdevicons#format()
Called 29 times
Total time:   0.010590
 Self time:   0.000729

count  total (s)   self (s)
                              " Call original formatter.
   29   0.003346   0.000375   let originalFormatter = airline#extensions#tabline#formatters#{g:_webdevicons_airline_orig_formatter}#format(a:bufnr, a:buffers)
   29   0.007204   0.000314   return originalFormatter . ' ' . WebDevIconsGetFileTypeSymbol(bufname(a:bufnr))

FUNCTION  ctrlp#modfilecond()
Called 1 time
Total time:   0.000165
 Self time:   0.000095

count  total (s)   self (s)
    1   0.000163   0.000093 	retu &mod && !&hid && &bh != 'hide' && s:bufwins(bufnr('%')) == 1 && !&cf && ( ( !&awa && a:w ) || filewritable(fnamemodify(bufname('%'), ':p')) != 1 )

FUNCTION  <SNR>158_process_removed()
Called 4 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    4              0.000007   if a:to_line == 0
                                call add(a:modifications, [1, 'removed_first_line'])
                              else
    4              0.000018     call add(a:modifications, [a:to_line, 'removed'])
    4              0.000004   endif

FUNCTION  <SNR>68_CacheErrors()
Called 1 time
Total time:   0.496729
 Self time:   0.000336

count  total (s)   self (s)
    1   0.000016   0.000007     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
    1   0.000399   0.000011     call s:ClearCache(a:buf)
    1   0.000034   0.000005     let newLoclist = g:SyntasticLoclist.New([])
    1   0.000009   0.000005     call newLoclist.setOwner(a:buf)
                            
    1   0.000071   0.000004     if !s:_skip_file(a:buf)
                                    " debug logging {{{3
    1   0.000012   0.000005         call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'aggregate_errors')
    1   0.000014   0.000006         if syntastic#util#isRunningWindows()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMP = ' . string($TMP) . ', $TEMP = ' . string($TEMP))
                                    else
    1   0.000013   0.000007             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))
    1   0.000011   0.000005             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMPDIR = ' . string($TMPDIR))
    1              0.000001         endif
    1   0.000013   0.000007         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$PATH = ' . string($PATH))
    1   0.000012   0.000007         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    " }}}3
                            
    1   0.000294   0.000010         let clist = s:registry.getCheckers(getbufvar(a:buf, '&filetype'), a:checker_names)
                            
    1   0.000075   0.000021         let aggregate_errors = syntastic#util#var('aggregate_errors') || len(syntastic#util#unique(map(copy(clist), 'v:val.getFiletype()'))) > 1
    1              0.000003         let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
    1              0.000002         let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
    1              0.000001         let names = []
    1              0.000002         let unavailable_checkers = 0
    2              0.000003         for checker in clist
    2   0.000017   0.000010             let cname = checker.getCName()
    2   0.000127   0.000009             if !checker.isAvailable()
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Checker ' . cname . ' is not available')
                                            let unavailable_checkers += 1
                                            continue
                                        endif
                            
    2   0.000024   0.000010             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Invoking checker: ' . cname)
                            
    2   0.495063   0.000024             let loclist = checker.getLocList()
                            
    2   0.000020   0.000009             if !loclist.isEmpty()
    1              0.000002                 if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
    1              0.000003                 call add(names, cname)
    1   0.000024   0.000007                 if checker.wantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', loclist)
                                            endif
                            
    1   0.000018   0.000005                 call newLoclist.extend(loclist)
                            
    1              0.000002                 if !aggregate_errors
    1              0.000000                     break
                                            endif
                                        endif
    1              0.000001         endfor
                            
                                    " set names {{{3
    1              0.000002         if !empty(names)
    1   0.000047   0.000020             if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
    1              0.000008                 let type = substitute(names[0], '\m/.*', '', '')
    1              0.000010                 let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
    1   0.000008   0.000006                 call newLoclist.setName( name . ' ('. type . ')' )
    1              0.000001             else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
    1              0.000001         endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
    1              0.000002         if len(clist) == unavailable_checkers
                                        if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
                                        else
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: no checkers available for ' . &filetype)
                                        endif
                                    endif
                                    " }}}3
                            
    1   0.000013   0.000005         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'aggregated:', newLoclist)
    1              0.000002         if sort_aggregated_errors
                                        call newLoclist.sort()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', newLoclist)
                                    endif
    1              0.000001     endif
                            
    1   0.000269   0.000005     call newLoclist.deploy()

FUNCTION  <SNR>158_is_modified()
Called 3 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    3              0.000012   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  gitgutter#utility#cd_cmd()
Called 3 times
Total time:   0.000299
 Self time:   0.000054

count  total (s)   self (s)
    3   0.000145   0.000033   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() ? 'cd /d' : 'cd')
    3   0.000150   0.000017   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  tagbar#debug#log()
Called 123 times
Total time:   0.001285
 Self time:   0.001285

count  total (s)   self (s)
  123              0.000257     if s:debug_enabled
                                    execute 'redir >> ' . s:debug_file
                                    silent echon s:gettime() . ': ' . a:msg . "\n"
                                    redir END
                                endif

FUNCTION  <SNR>72_repo_head_ref()
Called 223 times
Total time:   0.035467
 Self time:   0.027716

count  total (s)   self (s)
  223   0.017959   0.013258   if !filereadable(self.dir('HEAD'))
                                return ''
                              endif
  223   0.015837   0.012787   return readfile(self.dir('HEAD'))[0]

FUNCTION  SimpylFold#Recache()
Called 4 times
Total time:   0.000206
 Self time:   0.000206

count  total (s)   self (s)
    4              0.000026     if exists('b:SimpylFold_cache')
    3              0.000162         unlet b:SimpylFold_cache
    3              0.000005     endif

FUNCTION  320()
Called 1 time
Total time:   0.000057
 Self time:   0.000013

count  total (s)   self (s)
    2   0.000049   0.000005     for buf in self.getBuffers()
    1              0.000005         call setbufvar(buf, 'syntastic_loclist', {})
    1              0.000000     endfor

FUNCTION  322()
Called 1 time
Total time:   0.000362
 Self time:   0.000362

count  total (s)   self (s)
    1              0.000002     if !exists('self._cachedBalloons')
    1              0.000003         let sep = has('balloon_multiline') ? "\n" : ' | '
                            
    1              0.000002         let self._cachedBalloons = {}
   26              0.000014         for e in self._rawLoclist
   25              0.000027             let buf = e['bufnr']
                            
   25              0.000040             if !has_key(self._cachedBalloons, buf)
    1              0.000002                 let self._cachedBalloons[buf] = {}
    1              0.000001             endif
                            
   25              0.000057             if has_key(self._cachedBalloons[buf], e['lnum'])
    8              0.000047                 let self._cachedBalloons[buf][e['lnum']] .= sep . e['text']
    8              0.000001             else
   17              0.000048                 let self._cachedBalloons[buf][e['lnum']] = e['text']
   17              0.000008             endif
   25              0.000013         endfor
    1              0.000000     endif
                            
    1              0.000003     return get(self._cachedBalloons, bufnr(''), {})

FUNCTION  323()
Called 6 times
Total time:   0.000119
 Self time:   0.000063

count  total (s)   self (s)
    6              0.000021     if !exists('self._cachedErrors')
    1   0.000070   0.000014         let self._cachedErrors = self.filter({'type': 'E'})
    1              0.000001     endif
    6              0.000009     return self._cachedErrors

FUNCTION  324()
Called 6 times
Total time:   0.000099
 Self time:   0.000050

count  total (s)   self (s)
    6              0.000017     if !exists('self._cachedWarnings')
    1   0.000055   0.000006         let self._cachedWarnings = self.filter({'type': 'W'})
    1              0.000000     endif
    6              0.000006     return self._cachedWarnings

FUNCTION  326()
Called 1 time
Total time:   0.002012
 Self time:   0.000761

count  total (s)   self (s)
    1              0.000003     if !exists('self._cachedMessages')
    1              0.000002         let self._cachedMessages = {}
                            
    1   0.000017   0.000006         let errors = self.errors() + self.warnings()
   26              0.000016         for e in errors
   25              0.000027             let b = e['bufnr']
   25              0.000025             let l = e['lnum']
                            
   25              0.000039             if !has_key(self._cachedMessages, b)
    1              0.000003                 let self._cachedMessages[b] = {}
    1              0.000000             endif
                            
   25              0.000048             if !has_key(self._cachedMessages[b], l)
   17              0.000039                 let self._cachedMessages[b][l] = [e]
   17              0.000015             elseif self._columns
    8              0.000020                 call add(self._cachedMessages[b][l], e)
    8              0.000005             endif
   25              0.000012         endfor
                            
    1              0.000000         if self._columns
    1              0.000000             if !self._sorted
    2              0.000003                 for b in keys(self._cachedMessages)
   18              0.000014                     for l in keys(self._cachedMessages[b])
   17              0.000030                         if len(self._cachedMessages[b][l]) > 1
   18              0.000018                             for e in self._cachedMessages[b][l]
   13   0.000540   0.000053                                 call s:_set_screen_column(e)
   13              0.000005                             endfor
    5   0.000163   0.000041                             call sort(self._cachedMessages[b][l], 's:_compare_error_items_by_columns')
    5              0.000001                         endif
   17              0.000017                     endfor
    1              0.000001                 endfor
    1              0.000000             endif
                            
    2              0.000003             for b in keys(self._cachedMessages)
   18              0.000015                 for l in keys(self._cachedMessages[b])
   17   0.000704   0.000073                     call s:_remove_shadowed_items(self._cachedMessages[b][l])
   17              0.000015                 endfor
    1              0.000001             endfor
    1              0.000000         endif
    1              0.000001     endif
                            
    1              0.000003     return get(self._cachedMessages, a:buf, {})

FUNCTION  327()
Called 2 times
Total time:   0.000105
 Self time:   0.000095

count  total (s)   self (s)
    2   0.000032   0.000022     let conditions = values(map(copy(a:filters), 's:_translate(v:key, v:val)'))
    2              0.000010     let filter = len(conditions) == 1 ? conditions[0] : join(map(conditions, '"(" . v:val . ")"'), ' && ')
    2              0.000063     return filter(copy(self._rawLoclist), filter)

FUNCTION  329()
Called 1 time
Total time:   0.027779
 Self time:   0.000290

count  total (s)   self (s)
    1   0.000010   0.000004     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: show')
    1   0.000033   0.000003     call self.setloclist(0)
                            
    1   0.000004   0.000002     if !self.isEmpty()
    1              0.000002         let num = winnr()
    1   0.027591   0.000140         execute 'lopen ' . syntastic#util#var('loc_list_height')
    1              0.000003         if num != winnr()
    1              0.000008             execute num . 'wincmd w'
    1              0.000001         endif
                            
                                    " try to find the loclist window and set w:quickfix_title
    1              0.000037         let errors = getloclist(0)
    5              0.000006         for buf in tabpagebuflist()
    4              0.000017             if buflisted(buf) && bufloaded(buf) && getbufvar(buf, '&buftype') ==# 'quickfix'
    1              0.000002                 let win = bufwinnr(buf)
    1              0.000003                 let title = getwinvar(win, 'quickfix_title')
                            
                                            " TODO: try to make sure we actually own this window; sadly,
                                            " errors == getloclist(0) is the only somewhat safe way to
                                            " achieve that
    1              0.000003                 if strpart(title, 0, 16) ==# ':SyntasticCheck ' || ( (title ==# '' || title ==# ':setloclist()') && errors == getloclist(0) )
    1              0.000005                     call setwinvar(win, 'quickfix_title', ':SyntasticCheck ' . self._name)
    1              0.000003                     call setbufvar(buf, 'syntastic_owner_buffer', self._owner)
    1              0.000001                 endif
    1              0.000000             endif
    4              0.000003         endfor
    1              0.000001     endif

FUNCTION  airline#highlighter#get_highlight()
Called 2855 times
Total time:   0.406584
 Self time:   0.172355

count  total (s)   self (s)
 2855              0.013717   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                return s:hl_groups[a:group]
                              else
 2855   0.125334   0.017336     let fg = s:get_syn(a:group, 'fg')
 2855   0.111251   0.015200     let bg = s:get_syn(a:group, 'bg')
 2855              0.038523     let reverse = g:airline_gui_mode ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
 2855              0.019428     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
 2855              0.005378     let opts = a:000
 2855              0.003604     if bold
  194              0.000252       let opts = ['bold']
  194              0.000118     endif
 2855   0.054184   0.024004     let res = reverse ? s:get_array(bg, fg, opts) : s:get_array(fg, bg, opts)
 2855              0.002582   endif
 2855              0.010331   let s:hl_groups[a:group] = res
 2855              0.003491   return res

FUNCTION  <SNR>179_CurTypeName()
Called 143 times
Total time:   0.004409
 Self time:   0.004409

count  total (s)   self (s)
  143              0.000801 	if s:itemtype < len(s:coretypes)
  143              0.003455 		return filter(copy(s:coretypes), 'v:val[1]==g:ctrlp_types[s:itemtype]')[0]
                            	el
                            		return [s:getextvar("lname"), s:getextvar('sname')]
                            	en

FUNCTION  SyntaxCheckers_python_pyflakes_GetHighlightRegex()
Called 25 times
Total time:   0.000568
 Self time:   0.000568

count  total (s)   self (s)
   25              0.000286     if stridx(a:i['text'], 'is assigned to but never used') >= 0 || stridx(a:i['text'], 'imported but unused') >= 0 || stridx(a:i['text'], 'undefined name') >= 0 || stridx(a:i['text'], 'redefinition of') >= 0 || stridx(a:i['text'], 'referenced before assignment') >= 0 || stridx(a:i['text'], 'duplicate argument') >= 0 || stridx(a:i['text'], 'after other statements') >= 0 || stridx(a:i['text'], 'shadowed by loop variable') >= 0
                            
                                    " fun with Python's %r: try "..." first, then '...'
    2              0.000019         let term = matchstr(a:i['text'], '\m^.\{-}"\zs.\{-1,}\ze"')
    2              0.000002         if term !=# ''
                                        return '\V\<' . escape(term, '\') . '\>'
                                    endif
                            
    2              0.000014         let term = matchstr(a:i['text'], '\m^.\{-}''\zs.\{-1,}\ze''')
    2              0.000002         if term !=# ''
    2              0.000007             return '\V\<' . escape(term, '\') . '\>'
                                    endif
                                endif
   23              0.000011     return ''

FUNCTION  ctrlp#utils#opts()
Called 1 time
Total time:   0.000301
 Self time:   0.000188

count  total (s)   self (s)
    1   0.000047   0.000019 	let s:lash = ctrlp#utils#lash()
    1   0.000092   0.000040 	let usrhome = $HOME . s:lash( $HOME )
    1              0.000023 	let cahome = exists('$XDG_CACHE_HOME') ? $XDG_CACHE_HOME : usrhome.'.cache'
    1   0.000080   0.000047 	let cadir = isdirectory(usrhome.'.ctrlp_cache') ? usrhome.'.ctrlp_cache' : cahome.s:lash(cahome).'ctrlp'
    1              0.000011 	if exists('g:ctrlp_cache_dir')
                            		let cadir = expand(g:ctrlp_cache_dir, 1)
                            		if isdirectory(cadir.s:lash(cadir).'.ctrlp_cache')
                            			let cadir = cadir.s:lash(cadir).'.ctrlp_cache'
                            		en
                            	en
    1              0.000007 	let s:cache_dir = cadir

FUNCTION  <SNR>138_ShrinkIfExpanded()
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000004     if !s:window_expanded || &filetype == 'tagbar' || s:expand_bufnr == -1
    2              0.000002         return
                                endif
                            
                                let tablist = []
                                for i in range(tabpagenr('$'))
                                    call extend(tablist, tabpagebuflist(i + 1))
                                endfor
                            
                                if index(tablist, s:expand_bufnr) == -1
                                    let &columns -= g:tagbar_width + 1
                                    let s:window_expanded = 0
                                    let s:expand_bufnr = -1
                                    " Only restore window position if it is available and if the
                                    " window hasn't been moved manually after the expanding
                                    if getwinposx() != -1 && getwinposx() == s:window_pos.post.x && getwinposy() == s:window_pos.post.y
                                       execute 'winpos ' . s:window_pos.pre.x . ' ' . s:window_pos.pre.y
                                    endif
                                endif
                            
                                " The window sizes may have changed due to the shrinking happening after
                                " the window closing, so equalize them again.
                                if &equalalways
                                    wincmd =
                                endif

FUNCTION  <SNR>72_buffer_getline()
Called 6 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    6              0.000022   return get(getbufline(self['#'], a:lnum), 0, '')

FUNCTION  331()
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000003     if exists('g:syntastic_mode_map')
                                    let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
                                    let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
                                    let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
                                else
    1              0.000004         let self._mode = 'active'
    1              0.000005         let self._activeFiletypes = []
    1              0.000003         let self._passiveFiletypes = []
    1              0.000001     endif

FUNCTION  332()
Called 1 time
Total time:   0.000092
 Self time:   0.000030

count  total (s)   self (s)
    1   0.000021   0.000011     let registry = g:SyntasticRegistry.Instance()
    1   0.000047   0.000006     let fts = registry.resolveFiletypes(a:filetype)
                            
    1   0.000006   0.000004     if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
                                else
    1   0.000015   0.000006         return self._noFiletypesArePassive(fts)
                                endif

FUNCTION  333()
Called 1 time
Total time:   0.000108
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000004     let local_mode = getbufvar(a:buf, 'syntastic_mode')
    1              0.000002     if local_mode ==# 'active' || local_mode ==# 'passive'
                                    return local_mode ==# 'active'
                                endif
                            
    1   0.000100   0.000008     return self.allowsAutoChecking(getbufvar(a:buf, '&filetype'))

FUNCTION  334()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002     return self._mode ==# 'passive'

FUNCTION  <SNR>103_indent()
Called 223 times
Total time:   0.010210
 Self time:   0.010210

count  total (s)   self (s)
  223              0.003035     let ind = matchend(a:line, '^ *') / a:ind_spaces
  223              0.000523     if ind == 0
   36              0.000377         let ind = matchend(a:line, '^\t*')
   36              0.000075     endif
                                " Fix indent for solo def multiline endings
  223              0.003585     if a:line =~# s:multi_def_end_solo_re
                                    return ind + 1
                                endif
  223              0.000521     return ind

FUNCTION  <SNR>136_get_section()
Called 140 times
Total time:   0.007895
 Self time:   0.007148

count  total (s)   self (s)
  140              0.000659   if has_key(s:section_truncate_width, a:key)
   95              0.000482     if winwidth(a:winnr) < s:section_truncate_width[a:key]
   12              0.000024       return ''
                                endif
   83              0.000088   endif
  128              0.000421   let spc = g:airline_symbols.space
  128              0.000835   if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
  128   0.002176   0.001429   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
  128              0.001265   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
  128              0.000818   return empty(text) ? '' : prefix.text.suffix

FUNCTION  tagbar#is_paused()
Called 78 times
Total time:   0.000314
 Self time:   0.000314

count  total (s)   self (s)
   78              0.000251     return s:paused

FUNCTION  <SNR>142_addTag()
Called 4 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    4              0.000010     call add(self._taglist, a:tag)
                            
    4              0.000007     if has_key(self._tagdict, a:tag.name)
                                    call add(self._tagdict[a:tag.name], a:tag)
                                else
    4              0.000009         let self._tagdict[a:tag.name] = [a:tag]
    4              0.000004     endif

FUNCTION  <SNR>63__set_screen_column()
Called 13 times
Total time:   0.000487
 Self time:   0.000319

count  total (s)   self (s)
   13              0.000022     if !has_key(a:item, 'scol')
   13              0.000025         let col = get(a:item, 'col', 0)
   13              0.000027         if col != 0 && get(a:item, 'vcol', 0) == 0
   13              0.000028             let buf = str2nr(a:item['bufnr'])
   13              0.000011             try
   13              0.000044                 let line = getbufline(buf, a:item['lnum'])[0]
   13              0.000012             catch  /\m^Vim\%((\a\+)\)\=:E684/
                                            let line = ''
                                        endtry
   13   0.000263   0.000095             let a:item['scol'] = syntastic#util#screenWidth(strpart(line, 0, col), getbufvar(buf, '&tabstop'))
   13              0.000005         else
                                        let a:item['scol'] = col
                                    endif
   13              0.000005     endif

FUNCTION  <SNR>179_tail()
Called 1 time
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000016 	if exists('s:optail') && !empty('s:optail')
                            		let tailpref = s:optail !~ '^\s*+' ? ' +' : ' '
                            		retu tailpref.s:optail
                            	en
    1              0.000005 	retu ''

FUNCTION  <SNR>179_getextvar()
Called 7 times
Total time:   0.000357
 Self time:   0.000357

count  total (s)   self (s)
    7              0.000114 	if s:itemtype >= len(s:coretypes) && len(g:ctrlp_ext_vars) > 0
                            		let vars = g:ctrlp_ext_vars[s:itemtype - len(s:coretypes)]
                            		if has_key(vars, a:key)
                            			retu vars[a:key]
                            		en
                            	en
    7              0.000094 	retu get(g:, 'ctrlp_' . s:matchtype . '_' . a:key, -1)

FUNCTION  <SNR>111_get_text()
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000005   if exists("*win_getid") && exists("*getwininfo")
    1              0.000005     let dict = getwininfo(win_getid())
    1              0.000006     if len(dict) > 0 && get(dict[0], 'quickfix', 0) && !get(dict[0], 'loclist', 0)
                                  return g:airline#extensions#quickfix#quickfix_text
                                elseif len(dict) > 0 && get(dict[0], 'quickfix', 0) && get(dict[0], 'loclist', 0)
    1              0.000001       return g:airline#extensions#quickfix#location_text
                                endif
                              endif
                              redir => buffers
                              silent ls
                              redir END
                            
                              let nr = bufnr('%')
                              for buf in split(buffers, '\n')
                                if match(buf, '\v^\s*'.nr) > -1
                                  if match(buf, '\cQuickfix') > -1
                                    return g:airline#extensions#quickfix#quickfix_text
                                  else
                                    return g:airline#extensions#quickfix#location_text
                                  endif
                                endif
                              endfor
                              return ''

FUNCTION  341()
Called 3 times
Total time:   0.047136
 Self time:   0.000840

count  total (s)   self (s)
    3   0.000145   0.000038     if !syntastic#util#bufIsActive(bufnr('')) || (!a:loclist.isEmpty() && !a:loclist.isNewerThan([]))
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
    3   0.000037   0.000012     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
   18              0.000027     for type in self._enabled_types
   15              0.000147         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
   15   0.000354   0.000129         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
   15              0.000042             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
    6              0.000024                 if !exists('b:syntastic_private_' . type . '_stamp')
                                                let b:syntastic_private_{type}_stamp = []
                                            endif
    6   0.000247   0.000050                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
    6   0.014571   0.000034                     call self._notifier[type].refresh(a:loclist)
    6   0.000167   0.000055                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
    6              0.000006                 endif
    6              0.000003             else
    9   0.031148   0.000055                 call self._notifier[type].refresh(a:loclist)
    9              0.000006             endif
   15              0.000007         endif
   15              0.000009     endfor

FUNCTION  342()
Called 1 time
Total time:   0.000233
 Self time:   0.000141

count  total (s)   self (s)
    1   0.000012   0.000004     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: reset')
    6              0.000007     for type in self._enabled_types
    5              0.000031         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
    5              0.000021         if has_key(g:{class}, 'reset')
    3   0.000105   0.000021             call self._notifier[type].reset(a:loclist)
    3              0.000003         endif
                            
                                    " also reset stamps
    5              0.000015         if index(s:_PERSISTENT_NOTIFIERS, type) > -1
    2              0.000007             let b:syntastic_private_{type}_stamp = []
    2              0.000002         endif
    5              0.000002     endfor

FUNCTION  344()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000004     if !exists('s:SyntasticRegistryInstance')
                                    let s:SyntasticRegistryInstance = copy(self)
                                    let s:SyntasticRegistryInstance._checkerMap = {}
                                endif
                            
    1              0.000001     return s:SyntasticRegistryInstance

FUNCTION  346()
Called 1 time
Total time:   0.000284
 Self time:   0.000097

count  total (s)   self (s)
    1   0.000026   0.000004     let ftlist = self.resolveFiletypes(a:ftalias)
                            
    1              0.000005     let names = !empty(a:hints_list) ? a:hints_list : exists('b:syntastic_checkers') ? b:syntastic_checkers : []
                            
    1              0.000001     let cnames = []
    1              0.000002     if !empty(names)
                                    for name in names
                                        if name !~# '/'
                                            for ft in ftlist
                                                call add(cnames, ft . '/' . name)
                                            endfor
                                        else
                                            call add(cnames, name)
                                        endif
                                    endfor
                                else
    2              0.000003         for ft in ftlist
    1   0.000024   0.000005             call self._sanityCheck(ft)
    1              0.000008             let defs = exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers : get(s:_DEFAULT_CHECKERS, ft, [])
    1              0.000013             call extend(cnames, map(copy(defs), 'stridx(v:val, "/") < 0 ? ft . "/" . v:val : v:val' ))
    1              0.000001         endfor
    1              0.000001     endif
    1   0.000051   0.000005     let cnames = syntastic#util#unique(cnames)
                            
    2   0.000048   0.000015     for ft in syntastic#util#unique(map( copy(cnames), 'v:val[: stridx(v:val, "/")-1]' ))
    1   0.000011   0.000006         call self._loadCheckersFor(ft, 0)
    1              0.000001     endfor
                            
    1   0.000067   0.000005     return self._filterCheckersByName(cnames)

FUNCTION  <SNR>179_byfname()
Called 25 times
Total time:   0.001968
 Self time:   0.000399

count  total (s)   self (s)
   25   0.001953   0.000384 	retu s:curtype() != 'buf' && s:ispath && s:byfname

FUNCTION  <SNR>179_nocache()
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000002 	if !s:caching
                            		retu 1
                            	elsei s:caching > 1
                            		if !( exists(s:ccex) && !{s:ccex} ) || has_key(s:ficounts, s:dyncwd)
                            			retu get(s:ficounts, s:dyncwd, [0, 0])[0] < s:caching
                            		elsei a:0 && filereadable(a:1)
                            			retu len(ctrlp#utils#readfile(a:1)) < s:caching
                            		en
                            		retu 1
                            	en
    1              0.000001 	retu 0

FUNCTION  <SNR>138_get_map_str()
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000006     let def = get(g:, 'tagbar_map_' . a:map)
    1              0.000003     if type(def) == type("")
                                    return def
                                else
    1              0.000004         return join(def, ', ')
                                endif

FUNCTION  gitgutter#diff#parse_diff()
Called 2 times
Total time:   0.000488
 Self time:   0.000170

count  total (s)   self (s)
    2              0.000005   let hunks = []
   10              0.000029   for line in split(a:diff, '\n')
    8   0.000375   0.000057     let hunk_info = gitgutter#diff#parse_hunk(line)
    8              0.000017     if len(hunk_info) == 4
    8              0.000021       call add(hunks, hunk_info)
    8              0.000008     endif
    8              0.000007   endfor
    2              0.000002   return hunks

FUNCTION  <SNR>179_MapSpecs()
Called 1 time
Total time:   0.002723
 Self time:   0.002723

count  total (s)   self (s)
    1              0.000012 	if !( exists('s:smapped') && s:smapped == s:bufnr )
                            		" Correct arrow keys in terminal
    1              0.000027 		if ( has('termresponse') && v:termresponse =~ "\<ESC>" ) || &term =~? '\vxterm|<k?vt|gnome|screen|linux|ansi|tmux|st(-[-a-z0-9]*)?$'
    5              0.000020 			for each in ['\A <up>','\B <down>','\C <right>','\D <left>']
    4              0.000106 				exe s:lcmap.' <esc>['.each
    4              0.000008 			endfo
    1              0.000003 		en
    1              0.000002 	en
  123              0.000354 	for [ke, va] in items(s:prtmaps) | for kp in va
   53              0.001776 		exe s:lcmap kp ':<c-u>cal <SID>'.ke.'<cr>'
   88              0.000164 	endfo | endfo
    1              0.000007 	let s:smapped = s:bufnr

FUNCTION  <SNR>15_LoadIndent()
Called 2 times
Total time:   0.001353
 Self time:   0.001103

count  total (s)   self (s)
    2              0.000012     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
    2              0.000012     let s = expand("<amatch>")
    2              0.000005     if s != ""
    2              0.000006       if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    4              0.000077       for name in split(s, '\.')
    2   0.001208   0.000958 	exe 'runtime! indent/' . name . '.vim'
    2              0.000002       endfor
    2              0.000002     endif

FUNCTION  <SNR>45_addtomrufs()
Called 2 times
Total time:   0.010769
 Self time:   0.000606

count  total (s)   self (s)
    2              0.000060 	let fn = fnamemodify(a:fname, get(g:, 'ctrlp_tilde_homedir', 0) ? ':p:~' : ':p')
    2              0.000028 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
    2              0.000023 	let abs_fn = fnamemodify(fn,':p')
    2              0.000300 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^' . abs_fn . '$', '&bt')) || !filereadable(abs_fn)
                            		retu
                            	en
    2              0.000035 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
    2              0.000005 	if idx
    1              0.000005 		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
    1              0.000002 		cal insert(s:mrufs, fn)
    1              0.000002 		if {s:soup} && idx < 0
    1   0.010237   0.000074 			cal s:savetofile(s:mergelists())
    1              0.000003 		en
    1              0.000002 	en

FUNCTION  SimpylFold#BufferInit()
Called 1 time
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    1              0.000003     if &filetype ==# 'pyrex' || &filetype ==# 'cython'
                                    let b:SimpylFold_def_re = '\v^\s*%(%(class|%(async\s+)?def|cdef|cpdef|ctypedef)\s+\w+)|cdef\s*:'
                                else
    1              0.000003         let b:SimpylFold_def_re = '\v^\s*%(class|%(async\s+)?def)\s+\w+|if\s+__name__\s*\=\=\s*%("__main__"|''__main__'')\s*:'
    1              0.000001     endif
                            
    1              0.000004     if !exists('b:SimpylFold_fold_docstring')
    1              0.000005         let b:SimpylFold_fold_docstring = !exists('g:SimpylFold_fold_docstring') || g:SimpylFold_fold_docstring
    1              0.000001     endif
    1              0.000003     if !exists('b:SimpylFold_fold_import')
    1              0.000004         let b:SimpylFold_fold_import = !exists('g:SimpylFold_fold_import') || g:SimpylFold_fold_import
    1              0.000001     endif

FUNCTION  gitgutter#diff#process_hunks()
Called 2 times
Total time:   0.001722
 Self time:   0.000145

count  total (s)   self (s)
    2              0.000005   let modified_lines = []
   10              0.000017   for hunk in a:hunks
    8   0.001674   0.000097     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
    8              0.000009   endfor
    2              0.000003   return modified_lines

FUNCTION  351()
Called 2 times
Total time:   0.000063
 Self time:   0.000036

count  total (s)   self (s)
    2   0.000062   0.000035     return map(split( get(g:syntastic_filetype_map, a:ftalias, a:ftalias), '\m\.' ), 's:_normalise_filetype(v:val)')

FUNCTION  354()
Called 3 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    3              0.000009     let sep_idx = stridx(a:cname, '/')
    3              0.000003     if sep_idx > 0
    3              0.000008         let ft = a:cname[: sep_idx-1]
    3              0.000005         let name = a:cname[sep_idx+1 :]
    3              0.000002     else
                                    let ft = &filetype
                                    let name = a:cname
                                endif
    3              0.000010     return get(self._checkerMap[ft], name, {})

FUNCTION  355()
Called 1 time
Total time:   0.000062
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000062   0.000017     return filter( map(copy(a:cnames), 'self._findChecker(v:val)'), '!empty(v:val)' )

FUNCTION  356()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004     if !a:force && has_key(self._checkerMap, a:filetype)
    1              0.000001         return
                                endif
                            
                                execute 'runtime! syntax_checkers/' . a:filetype . '/*.vim'
                            
                                if !has_key(self._checkerMap, a:filetype)
                                    let self._checkerMap[a:filetype] = {}
                                endif

FUNCTION  357()
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000005     if exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checkers) != type([])
                            
                                    unlet! g:syntastic_{a:filetype}_checkers
                                    call syntastic#log#error('variable g:syntastic_' . a:filetype . '_checkers has to be a list of strings')
                                endif
                            
    1              0.000005     if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checker) == type('')
                            
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
                                endif

FUNCTION  359()
Called 6 times
Total time:   0.000134
 Self time:   0.000045

count  total (s)   self (s)
    6   0.000130   0.000041     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  <SNR>57_invoke_funcrefs()
Called 22 times
Total time:   0.231396
 Self time:   0.001593

count  total (s)   self (s)
   22   0.001159   0.000200   let builder = airline#builder#new(a:context)
   22   0.027203   0.000427   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
   22              0.000046   if err == 1
   18   0.202298   0.000230     let a:context.line = builder.build()
   18              0.000273     let s:contexts[a:context.winnr] = a:context
   18              0.000306     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
   18              0.000020   endif

FUNCTION  <SNR>117_update_git_branch()
Called 223 times
Total time:   0.127034
 Self time:   0.013743

count  total (s)   self (s)
  223   0.004727   0.002364   if !s:has_fugitive()
                                let s:vcs_config['git'].branch = ''
                                return
                              endif
                            
  223   0.115323   0.004395   let s:vcs_config['git'].branch = fugitive#head(s:sha1size)
  223              0.002531   if s:vcs_config['git'].branch is# 'master' && winwidth(0) < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
                              endif

FUNCTION  <SNR>72_buffer_spec()
Called 12 times
Total time:   0.000292
 Self time:   0.000139

count  total (s)   self (s)
   12              0.000035     let bufname = bufname(self['#'])
   12   0.000254   0.000101     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))

FUNCTION  <SNR>158_is_removed()
Called 7 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    7              0.000034   return a:from_count > 0 && a:to_count == 0

FUNCTION  airline#extensions#tabline#new_builder()
Called 11 times
Total time:   0.001607
 Self time:   0.000763

count  total (s)   self (s)
   11              0.000234   let builder_context = { 'active'        : 1, 'tabline'       : 1, 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep), 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep), }
   11              0.000050   if get(g:, 'airline_powerline_fonts', 0)
                                let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
                                let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
                              else
   11              0.000090     let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
   11              0.000084     let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
   11              0.000016   endif
                            
   11   0.000977   0.000133   return airline#extensions#tabline#builder#new(builder_context)

FUNCTION  airline#util#shorten()
Called 447 times
Total time:   0.021877
 Self time:   0.021877

count  total (s)   self (s)
  447              0.006282   if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return ''.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').''
                                endif
                              else
  447              0.001860     return a:text
                              endif

FUNCTION  <SNR>179_iscmdwin()
Called 1 time
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
    1              0.000017 	let [ermsg, v:errmsg] = [v:errmsg, '']
    1              0.000039 	sil! noa winc p
    1              0.000022 	sil! noa winc p
    1              0.000011 	let [v:errmsg, ermsg] = [ermsg, v:errmsg]
    1              0.000015 	retu ermsg =~ '^E11:'

FUNCTION  <SNR>63__translate()
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000010     return 'get(v:val, ' . string(a:key) . ', "") ==? ' . string(a:val)

FUNCTION  airline#extensions#tabline#add_label()
Called 11 times
Total time:   0.000602
 Self time:   0.000290

count  total (s)   self (s)
   11              0.000062   if get(g:, 'airline#extensions#tabline#show_tab_type', 1)
   11   0.000506   0.000194     call a:dict.add_section_spaced('airline_tablabel', get(g:, 'airline#extensions#tabline#'.a:type.'_label', a:type))
   11              0.000017   endif

FUNCTION  <SNR>179_compmatlen()
Called 53 times
Total time:   0.017707
 Self time:   0.002034

count  total (s)   self (s)
                            	" By match length
   53   0.008670   0.000916 	let mln1 = s:shortest(s:matchlens(a:1, s:compat))
   53   0.008719   0.000800 	let mln2 = s:shortest(s:matchlens(a:2, s:compat))
   53              0.000217 	retu mln1 == mln2 ? 0 : mln1 > mln2 ? 1 : -1

FUNCTION  <SNR>159_OnFileTypeSet()
Called 2 times
Total time:   0.006172
 Self time:   0.003218

count  total (s)   self (s)
    2   0.000095   0.000010   if !s:AllowedToCompleteInCurrentBuffer()
    1              0.000001     return
                              endif
                            
    1   0.000022   0.000006   call s:SetUpCompleteopt()
    1   0.000016   0.000011   call s:SetCompleteFunc()
    1   0.000018   0.000005   call s:StartMessagePoll()
                            
    1              0.003159   exec s:python_command "ycm_state.OnBufferVisit()"
    1   0.002857   0.000022   call s:OnFileReadyToParse( 1 )

FUNCTION  360()
Called 3 times
Total time:   0.014068
 Self time:   0.000104

count  total (s)   self (s)
    3   0.000038   0.000016     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
                            
    3   0.000042   0.000014     let old_signs = copy(self._bufSignIds())
    3   0.000058   0.000009     if self.enabled()
    3              0.000004         if !s:setup_done
                                        call self._setup()
                                        let s:setup_done = 1
                                        lockvar s:setup_done
                                    endif
                            
    3   0.013849   0.000026         call self._signErrors(a:loclist)
    3              0.000003     endif
    3   0.000056   0.000014     call self._removeSigns(old_signs)

FUNCTION  362()
Called 3 times
Total time:   0.013823
 Self time:   0.012646

count  total (s)   self (s)
    3              0.000006     let loclist = a:loclist
    3   0.000014   0.000008     if !loclist.isEmpty()
                            
    1              0.000002         let buf = bufnr('')
    1              0.000002         if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
    1   0.000082   0.000008         let issues = copy(loclist.errors())
    1   0.000065   0.000006         call extend(issues, loclist.warnings())
    1              0.000018         call filter(issues, 'v:val["bufnr"] == buf')
    1              0.000001         let seen = {}
                            
   26              0.000021         for i in issues
   25              0.000062             if i['lnum'] > 0 && !has_key(seen, i['lnum'])
   17              0.000032                 let seen[i['lnum']] = 1
                            
   17              0.000034                 let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
   17              0.000033                 let sign_subtype = get(i, 'subtype', '')
   17              0.000036                 let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
   17   0.013027   0.012092                 execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
   17   0.000168   0.000065                 call add(self._bufSignIds(), s:next_sign_id)
   17              0.000026                 let s:next_sign_id += 1
   17              0.000005             endif
   25              0.000017         endfor
    1              0.000000     endif

FUNCTION  363()
Called 3 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    3              0.000012     if has('signs')
    3              0.000011         for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
                                    endfor
    3              0.000001     endif

FUNCTION  364()
Called 20 times
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
   20              0.000053     if !exists('b:syntastic_private_sign_ids')
    1              0.000002         let b:syntastic_private_sign_ids = []
    1              0.000001     endif
   20              0.000028     return b:syntastic_private_sign_ids

FUNCTION  <SNR>72_winshell()
Called 14 times
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
   14              0.000070   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  tagbar#state#get_current_file()
Called 78 times
Total time:   0.004321
 Self time:   0.001417

count  total (s)   self (s)
   78   0.004266   0.001362     return s:get().getCurrent(a:force_current)

FUNCTION  <SNR>144_isPseudoTag()
Called 11 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
   11              0.000012     return 0

FUNCTION  <SNR>138_goto_tagbar()
Called 1 time
Total time:   0.014734
 Self time:   0.000033

count  total (s)   self (s)
    1              0.000002     let noauto = a:0 > 0 ? a:1 : 0
    1   0.014731   0.000030     call s:goto_win(bufwinnr(s:TagbarBufName()), noauto)

FUNCTION  <SNR>56_CursorHoldUpdate()
Called 2 times
Total time:   0.000251
 Self time:   0.000131

count  total (s)   self (s)
    2              0.000021   if g:NERDTreeUpdateOnCursorHold != 1
                                return
                              endif
                            
    2   0.000191   0.000071   if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
    2              0.000009     return
                              endif
                            
                              " Do not update when a special buffer is selected
                              if !empty(&l:buftype)
                                return
                              endif
                            
                              " winnr need to make focus go to opened file
                              " CursorToTreeWin needed to avoid error on opening file
                              let l:winnr = winnr()
                              let l:altwinnr = winnr('#')
                            
                              call g:NERDTree.CursorToTreeWin()
                              call b:NERDTree.root.refreshFlags()
                              call NERDTreeRender()
                            
                              exec l.altwinnr . 'wincmd w'
                              exec l:winnr . 'wincmd w'

FUNCTION  <SNR>103_matchstrpos()
Called 99 times
Total time:   0.004047
 Self time:   0.004047

count  total (s)   self (s)
   99              0.000252     if s:exists_matchstrpos
   99              0.003678         return matchstrpos(a:expr, a:pat)
                                else
                                    return [matchstr(a:expr, a:pat), match(a:expr, a:pat), matchend(a:expr, a:pat)]
                                endif

FUNCTION  <SNR>179_openfile()
Called 1 time
Total time:   0.752368
 Self time:   0.001478

count  total (s)   self (s)
    1              0.000006 	let cmd = a:cmd
    1   0.000210   0.000045 	if a:chkmod && cmd =~ '^[eb]$' && ctrlp#modfilecond(!( cmd == 'b' && &aw ))
    1              0.000008 		let cmd = cmd == 'b' ? 'sb' : 'sp'
    1              0.000003 	en
    1              0.000019 	let cmd = cmd =~ '^tab' ? ctrlp#tabcount().cmd : cmd
    1              0.000015 	let j2l = a:0 && a:1[0] ? a:1[1] : 0
    1   0.751745   0.001259 	exe cmd.( a:0 && a:1[0] ? '' : a:tail ) s:fnesc(a:fid, 'f')
    1              0.000006 	if j2l
                            		cal ctrlp#j2l(j2l)
                            	en
    1              0.000007 	if !empty(a:tail)
                            		sil! norm! zvzz
                            	en
    1              0.000005 	if cmd != 'bad'
    1   0.000286   0.000047 		cal ctrlp#setlcdir()
    1              0.000001 	en

FUNCTION  airline#highlighter#add_separator()
Called 390 times
Total time:   0.307945
 Self time:   0.009189

count  total (s)   self (s)
  390              0.003929   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
  390   0.303692   0.004936   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  <SNR>179_AcceptSelection()
Called 1 time
Total time:   0.771018
 Self time:   0.000466

count  total (s)   self (s)
    1              0.000067 	let [md, icr] = [a:action[0], match(a:action, 'r') >= 0]
    1              0.000014 	let subm = icr || ( !icr && md == 'e' )
    1              0.000024 	if !subm && s:OpenMulti(md) != -1 | retu | en
    1   0.000199   0.000024 	let str = s:getinput()
    1   0.000206   0.000042 	if subm | if s:SpecInputs(str) | retu | en | en
                            	" Get the selected line
    1   0.000105   0.000023 	let line = ctrlp#getcline()
    1              0.000016 	if !subm && s:curtype() != 'fil' && line == '' && line('.') > s:offset && str !~ '\v^(\.\.([\/]\.\.)*[\/]?[.\/]*|/|\\|\?|\@.+)$'
                            		cal s:CreateNewFile(md) | retu
                            	en
    1              0.000011 	if empty(line) | retu | en
                            	" Do something with it
    1              0.000020 	if s:openfunc != {} && has_key(s:openfunc, s:ctype)
                            		let actfunc = s:openfunc[s:ctype]
                            		let type = has_key(s:openfunc, 'arg_type') ? s:openfunc['arg_type'] : 'list'
                            	el
    1              0.000010 		if s:itemtype < len(s:coretypes)
    1              0.000011 			let [actfunc, type] = ['ctrlp#acceptfile', 'dict']
    1              0.000003 		el
                            			let [actfunc, exttype] = [s:getextvar('accept'), s:getextvar('act_farg')]
                            			let type = exttype == 'dict' ? exttype : 'list'
                            		en
    1              0.000002 	en
    1              0.000027 	let actargs = type == 'dict' ? [{ 'action': md, 'line': line, 'icr': icr, 'input': str}] : [md, line]
    1   0.770233   0.000102 	cal call(actfunc, actargs)

FUNCTION  <SNR>115_get_hunks()
Called 223 times
Total time:   0.046585
 Self time:   0.017749

count  total (s)   self (s)
  223              0.003499   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
    1              0.000002     if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
    1              0.000002       let b:source_func = 's:get_hunks_gitgutter'
    1              0.000001     elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
    1              0.000000   endif
  223   0.033207   0.004371   return {b:source_func}()

FUNCTION  airline#extensions#tagbar#inactive_apply()
Called 13 times
Total time:   0.000167
 Self time:   0.000167

count  total (s)   self (s)
   13              0.000103   if getwinvar(a:2.winnr, '&filetype') == 'tagbar'
    4              0.000010     return -1
                              endif

FUNCTION  <SNR>138_ProcessFile()
Called 1 time
Total time:   0.020867
 Self time:   0.000928

count  total (s)   self (s)
    1   0.000008   0.000004     call tagbar#debug#log('ProcessFile called [' . a:fname . ']')
                            
    1   0.000065   0.000002     if !s:IsValidFile(a:fname, a:ftype)
                                    call tagbar#debug#log('Not a valid file, returning')
                                    return
                                endif
                            
    1              0.000002     let typeinfo = s:known_types[a:ftype]
                            
                                " If the file has only been updated preserve the fold states, otherwise
                                " create a new entry
    1   0.000008   0.000006     if s:known_files.has(a:fname) && !empty(s:known_files.get(a:fname)) && s:known_files.get(a:fname).ftype == a:ftype
                                    let fileinfo = s:known_files.get(a:fname)
                                    let typeinfo = fileinfo.typeinfo
                                    call fileinfo.reset()
                                else
    1              0.000006         if exists('#TagbarProjects#User')
                                        execute 'doautocmd <nomodeline> TagbarProjects User ' . a:fname
                                        if exists('b:tagbar_type')
                                            let typeinfo = extend(copy(typeinfo), s:TransformUserTypeDef(b:tagbar_type))
                                            call typeinfo.createKinddict()
                                        endif
                                    endif
    1   0.000217   0.000018         let fileinfo = tagbar#prototypes#fileinfo#new(a:fname, a:ftype, typeinfo)
    1              0.000000     endif
                            
    1   0.000032   0.000026     call tagbar#debug#log('typeinfo for file to process: ' . string(typeinfo))
                            
                                " Use a temporary files for ctags processing instead of the original one.
                                " This allows using Tagbar for files accessed with netrw, and also doesn't
                                " slow down Tagbar for files that sit on slow network drives.
    1              0.000002     let tempfile = tempname()
    1              0.000003     let ext = fnamemodify(fileinfo.fpath, ':e')
    1              0.000002     if ext != ''
    1              0.000002         let tempfile .= '.' . ext
    1              0.000000     endif
                            
    1   0.000008   0.000003     call tagbar#debug#log('Caching file into: ' . tempfile)
    1              0.000026     let templines = getbufline(fileinfo.bufnr, 1, '$')
    1              0.000169     let res = writefile(templines, tempfile)
                            
    1              0.000002     if res != 0
                                    call tagbar#debug#log('Could not create copy '.tempfile)
                                    return
                                endif
    1              0.000004     let fileinfo.mtime = getftime(tempfile)
                            
    1   0.008617   0.000029     let ctags_output = s:ExecuteCtagsOnFile(tempfile, a:fname, typeinfo)
                            
    1   0.000007   0.000005     if !tagbar#debug#enabled()
    1              0.000010         call delete(tempfile)
    1              0.000001     endif
                            
    1              0.000002     if ctags_output == -1
                                    call tagbar#debug#log('Ctags error when processing file')
                                    " Put an empty entry into known_files so the error message is only
                                    " shown once
                                    call s:known_files.put({}, a:fname)
                                    return
                                elseif ctags_output == ''
                                    call tagbar#debug#log('Ctags output empty')
                                    " No need to go through the tag processing if there are no tags, and
                                    " preserving the old fold state isn't necessary either
                                    call s:known_files.put(tagbar#prototypes#fileinfo#new(a:fname, a:ftype, s:known_types[a:ftype]), a:fname)
                                    return
                                endif
                            
    1   0.000019   0.000013     call tagbar#debug#log('Filetype tag kinds: ' . string(keys(typeinfo.kinddict)))
                            
                                " Parse the ctags output lines
    1   0.000008   0.000004     call tagbar#debug#log('Parsing ctags output')
    1              0.000023     let rawtaglist = split(ctags_output, '\n\+')
   15              0.000020     for line in rawtaglist
                                    " skip comments
   14              0.000065         if line =~# '^!_TAG_'
                                        continue
                                    endif
                            
   14              0.000061         let parts = split(line, ';"')
   14              0.000022         if len(parts) == 2 " Is a valid tag line
   14   0.010222   0.000125             call s:ParseTagline(parts[0], parts[1], typeinfo, fileinfo)
   14              0.000012         endif
   14              0.000008     endfor
                            
                                " Create a placeholder tag for the 'kind' header for folding purposes, but
                                " only for non-scoped tags
    7              0.000008     for kind in typeinfo.kinds
    6              0.000014         if has_key(get(typeinfo, 'kind2scope', {}), kind.short)
    4              0.000008             continue
                                    endif
                            
    2   0.000049   0.000045         let curtags = filter(copy(fileinfo.getTags()), 'v:val.fields.kind ==# kind.short && ' . '!has_key(v:val, "scope")')
    2   0.000026   0.000013         call tagbar#debug#log('Processing kind: ' . kind.short . ', number of tags: ' . len(curtags))
                            
    2              0.000004         if empty(curtags)
    1              0.000000             continue
                                    endif
                            
    1   0.000259   0.000009         let kindtag          = tagbar#prototypes#kindheadertag#new(kind.long)
    1              0.000001         let kindtag.short    = kind.short
    1              0.000002         let kindtag.numtags  = len(curtags)
    1              0.000001         let kindtag.fileinfo = fileinfo
                            
    4              0.000003         for tag in curtags
    3              0.000003             let tag.parent = kindtag
    3              0.000003         endfor
    1              0.000001     endfor
                            
                                " Clear old folding information from previous file version to prevent leaks
    1   0.000010   0.000006     call fileinfo.clearOldFolds()
                            
                                " Sort the tags
    1   0.000691   0.000007     call fileinfo.sortTags(typeinfo)
                            
    1   0.000016   0.000008     call s:known_files.put(fileinfo)

FUNCTION  <SNR>179_Close()
Called 1 time
Total time:   0.015366
 Self time:   0.002046

count  total (s)   self (s)
    1   0.000084   0.000024 	cal s:buffunc(0)
    1              0.000008 	if winnr('$') == 1
                            		bw!
                            	el
    1              0.000274 		try | bun!
    1              0.000013 		cat | clo! | endt
    1   0.000073   0.000029 		cal s:unmarksigns()
    1              0.000003 	en
   34              0.000312 	for key in keys(s:glbs) | if exists('+'.key)
   17              0.000803 		sil! exe 'let &'.key.' = s:glb_'.key
   33              0.000078 	en | endfo
    1              0.000015 	if exists('s:glb_acd') | let &acd = s:glb_acd | en
    1              0.000048 	let g:ctrlp_lines = []
    1              0.000020 	if s:winres[1] >= &lines && s:winres[2] == winnr('$')
    1              0.000051 		exe s:winres[0].s:winres[0]
    1              0.000002 	en
    1              0.000027 	unl! s:focus s:hisidx s:hstgot s:marked s:statypes s:init s:savestr s:mrbs s:did_exp
    1   0.013137   0.000040 	cal ctrlp#recordhist()
    1   0.000204   0.000149 	cal s:execextvar('exit')
    1   0.000083   0.000019 	cal s:log(0)
    1              0.000012 	let v:errmsg = s:ermsg
    1              0.000062 	ec

FUNCTION  <SNR>175_find_current_signs()
Called 2 times
Total time:   0.001443
 Self time:   0.001350

count  total (s)   self (s)
    2              0.000005   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
    2              0.000003   let other_signs = []      " [<line_number (number),...]
    2              0.000004   let dummy_sign_placed = 0
                            
    2              0.000007   redir => signs
    2              0.000055     silent execute "sign place buffer=" . a:bufnr
    2              0.000006   redir END
                            
   18              0.000086   for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
   16              0.000265     let components  = split(sign_line)
   16              0.000100     let name        = split(components[2], '=')[1]
   16              0.000067     if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
   16              0.000103       let line_number = str2nr(split(components[0], '=')[1])
   16              0.000058       if name =~# 'GitGutter'
   16              0.000093         let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
   16              0.000052         if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
   16              0.000108         let gitgutter_signs[line_number] = {'id': id, 'name': name}
   16              0.000014       else
                                    call add(other_signs, line_number)
                                  endif
   16              0.000016     end
   16              0.000014   endfor
                            
    2   0.000048   0.000016   call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', dummy_sign_placed)
    2   0.000046   0.000010   call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', gitgutter_signs)
    2   0.000037   0.000012   call gitgutter#utility#setbufvar(a:bufnr, 'other_signs', other_signs)

FUNCTION  syntastic#util#system()
Called 2 times
Total time:   0.490281
 Self time:   0.000291

count  total (s)   self (s)
    2              0.000003     let old_shell = &shell
    2              0.000006     let old_lc_messages = $LC_MESSAGES
    2              0.000004     let old_lc_all = $LC_ALL
                            
    2   0.000031   0.000011     let &shell = syntastic#util#var('shell')
    2              0.000004     let $LC_MESSAGES = 'C'
    2              0.000003     let $LC_ALL = ''
                            
    2              0.000002     let crashed = 0
    2              0.000004     let cmd_start = reltime()
    2              0.000002     try
    2   0.489856   0.000078         let out = system(a:command)
    2              0.000013     catch
                                    let crashed = 1
                                    call syntastic#log#error('exception running system(' . string(a:command) . '): ' . v:exception)
                                    if syntastic#util#isRunningWindows()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMP = ' . string($TMP) . ', $TEMP = ' . string($TEMP))
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMPDIR = ' . string($TMPDIR))
                                    endif
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '$PATH = ' . string($PATH))
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
                                    let out = ''
                                endtry
    2              0.000086     let cmd_time = split(reltimestr(reltime(cmd_start)))[0]
                            
    2              0.000015     let $LC_ALL = old_lc_all
    2              0.000007     let $LC_MESSAGES = old_lc_messages
                            
    2              0.000023     let &shell = old_shell
                            
    2              0.000015     if !crashed && exists('g:_SYNTASTIC_DEBUG_TRACE')
    2   0.000089   0.000034         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'system: command run in ' . cmd_time . 's')
    2              0.000003     endif
                            
    2              0.000006     return out

FUNCTION  airline#util#wrap()
Called 1788 times
Total time:   0.029497
 Self time:   0.029497

count  total (s)   self (s)
 1788              0.012776   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 1788              0.006181   return a:text

FUNCTION  gitgutter#debug#log()
Called 5 times
Total time:   0.000203
 Self time:   0.000203

count  total (s)   self (s)
    5              0.000009   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif

FUNCTION  <SNR>47_dir()
Called 11 times
Total time:   0.001164
 Self time:   0.000223

count  total (s)   self (s)
   11   0.001154   0.000213   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  <SNR>72_repo_dir()
Called 455 times
Total time:   0.007776
 Self time:   0.007776

count  total (s)   self (s)
  455              0.007371   return join([self.git_dir]+a:000,'/')

FUNCTION  airline#extensions#quickfix#apply()
Called 9 times
Total time:   0.000180
 Self time:   0.000156

count  total (s)   self (s)
    9              0.000032   if &buftype == 'quickfix'
    1   0.000039   0.000015     let w:airline_section_a = s:get_text()
    1              0.000001     let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
    1              0.000002     let w:airline_section_c = ''
    1              0.000001     let w:airline_section_x = ''
    1              0.000001   endif

FUNCTION  <SNR>155_has_fresh_changes()
Called 5 times
Total time:   0.000239
 Self time:   0.000091

count  total (s)   self (s)
    5   0.000236   0.000088   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  387()
Called 36 times
Total time:   0.000287
 Self time:   0.000287

count  total (s)   self (s)
   36              0.000262   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  388()
Called 60 times
Total time:   0.001585
 Self time:   0.001089

count  total (s)   self (s)
   60              0.000417   let spc = empty(a:contents) ? '' : g:airline_symbols.space
   60   0.001111   0.000615   call self.add_section(a:group, spc.a:contents.spc)

FUNCTION  389()
Called 213 times
Total time:   0.001587
 Self time:   0.001587

count  total (s)   self (s)
  213              0.001475   call add(self._sections, [a:group, a:contents])

FUNCTION  ctrlp#recordhist()
Called 1 time
Total time:   0.013097
 Self time:   0.000151

count  total (s)   self (s)
    1              0.000016 	let str = join(s:prompt, '')
    1              0.000017 	if empty(str) || !s:maxhst | retu | en
    1              0.000005 	let hst = s:hstry
    1              0.000018 	if len(hst) > 1 && hst[1] == str | retu | en
    1              0.000012 	cal extend(hst, [str], 1)
    1              0.000022 	if len(hst) > s:maxhst | cal remove(hst, s:maxhst, -1) | en
    1   0.013001   0.000055 	cal ctrlp#utils#writecache(hst, s:gethistloc()[0], s:gethistloc()[1])

FUNCTION  <SNR>179_dosigns()
Called 10 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
   10              0.000105 	retu exists('s:marked') && s:bufnr > 0 && s:opmul != '0' && has('signs')

FUNCTION  xolox#misc#cursorhold#autocmd()
Called 2 times
Total time:   0.004276
 Self time:   0.000801

count  total (s)   self (s)
                              " The 'top level event handler' that's called by Vim whenever the
                              " [CursorHold][] or [CursorHoldI][] event fires. It iterates through the
                              " event handlers registered using `xolox#misc#cursorhold#register()` and
                              " calls each event handler at the appropriate interval, keeping track of
                              " the time when each event handler was last run.
    4              0.000043   for handler in g:xolox#misc#cursorhold#handlers
    2              0.000029     let function = handler['function']
    2              0.000029     let last_run = get(handler, 'last_run', 0)
    2              0.000024     let interval = get(handler, 'interval', 4)
    2   0.000238   0.000133     call xolox#misc#msg#debug("vim-misc %s: Checking handler %s with interval %i and last run %i ..", g:xolox#misc#version, function, interval, last_run)
                                " Rate limit in case &updatetime is set (very) low.
    2              0.000051     let time_until_next_run = (last_run + interval) - localtime()
    2              0.000016     if time_until_next_run > 0
                                  call xolox#misc#msg#debug("vim-misc %s: Rate limiting handler %s (time until next run: %i seconds).", g:xolox#misc#version, function, time_until_next_run)
                                else
    2   0.000139   0.000058       call xolox#misc#msg#debug("vim-misc %s: Running handler %s ..", g:xolox#misc#version, function)
    2   0.003375   0.000086       call call(function, get(handler, 'arguments', []))
    2              0.000032       let handler['last_run'] = localtime()
    2              0.000006     endif
    2              0.000007   endfor

FUNCTION  ctrlp#rmbasedir()
Called 1 time
Total time:   0.000050
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000002 	if a:items == []
                            		retu a:items
                            	en
    1   0.000024   0.000009 	let cwd = s:dyncwd.s:lash()
    1              0.000004 	let first = a:items[0]
    1              0.000007 	if has('win32') || has('win64')
                            		let cwd = tr(cwd, '\', '/')
                            		let first = tr(first, '\', '/')
                            	en
    1              0.000003 	if !stridx(first, cwd)
                            		let idx = strlen(cwd)
                            		retu map(a:items, 'strpart(v:val, idx)')
                            	en
    1              0.000001 	retu a:items

FUNCTION  syntastic#log#debugShowVariables()
Called 2 times
Total time:   0.000021
 Self time:   0.000014

count  total (s)   self (s)
    2   0.000018   0.000011     if !s:_isDebugEnabled(a:level)
    2              0.000002         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type('') ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_format_variable(name)
                                    if msg !=# ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)

FUNCTION  airline#extensions#tabline#get()
Called 14 times
Total time:   0.134978
 Self time:   0.001144

count  total (s)   self (s)
   14              0.000159   let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
   14              0.000094   let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
   14              0.000081   let curtabcnt = tabpagenr('$')
   14              0.000061   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                              endif
                            
   14              0.000103   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline()
                              endif
   14              0.000030   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
                              elseif show_buffers && curtabcnt == 1 || !show_tabs
   14   0.133996   0.000162     return airline#extensions#tabline#buffers#get()
                              else
                                return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  ctrlp#utils#fnesc()
Called 5 times
Total time:   0.001034
 Self time:   0.001034

count  total (s)   self (s)
    5              0.000071 	if exists('*fnameescape')
    5              0.000075 		if exists('+ssl')
                            			if a:type == 'c'
                            				let path = escape(a:path, '%#')
                            			elsei a:type == 'f'
                            				let path = fnameescape(a:path)
                            			elsei a:type == 'g'
                            				let path = escape(a:path, '?*')
                            			en
                            			let path = substitute(path, '[', '[[]', 'g')
                            		el
    5              0.000269 			let path = fnameescape(a:path)
    5              0.000013 		en
    5              0.000008 	el
                            		if exists('+ssl')
                            			if a:type == 'c'
                            				let path = escape(a:path, '%#')
                            			elsei a:type == 'f'
                            				let path = escape(a:path, " \t\n%#*?|<\"")
                            			elsei a:type == 'g'
                            				let path = escape(a:path, '?*')
                            			en
                            			let path = substitute(path, '[', '[[]', 'g')
                            		el
                            			let path = escape(a:path, " \t\n*?[{`$\\%#'\"|!<")
                            		en
                            	en
    5              0.000071 	retu a:0 ? escape(path, a:1) : path

FUNCTION  gitgutter#utility#extension()
Called 2 times
Total time:   0.000078
 Self time:   0.000020

count  total (s)   self (s)
    2   0.000075   0.000017   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  <SNR>72_define_commands()
Called 1 time
Total time:   0.000329
 Self time:   0.000329

count  total (s)   self (s)
   28              0.000020   for command in s:commands
   27              0.000284     exe 'command! -buffer '.command
   27              0.000018   endfor

FUNCTION  <SNR>179_setupblank()
Called 1 time
Total time:   0.000636
 Self time:   0.000636

count  total (s)   self (s)
    1              0.000215 	setl noswf nonu nobl nowrap nolist nospell nocuc wfh
    1              0.000090 	setl fdc=0 fdl=99 tw=0 bt=nofile bh=unload
    1              0.000011 	if v:version > 702
    1              0.000035 		setl nornu noudf cc=0
    1              0.000003 	en
    1              0.000005 	if s:has_conceal
    1              0.000266 		setl cole=2 cocu=nc
    1              0.000004 	en

FUNCTION  <SNR>159_AllowedToCompleteInCurrentBuffer()
Called 207 times
Total time:   0.030086
 Self time:   0.003512

count  total (s)   self (s)
  207   0.029880   0.003306   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  <SNR>158_is_modified_and_added()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  <SNR>179_Render()
Called 5 times
Total time:   0.064833
 Self time:   0.003399

count  total (s)   self (s)
    5   0.000195   0.000173 	let [&ma, lines, s:res_count] = [1, a:lines, len(a:lines)]
    5              0.000077 	let height = min([max([s:mw_min, s:res_count]), s:winmaxh])
    5   0.000452   0.000085 	let pat = s:byfname() ? split(a:pat, '^[^;]\+\\\@<!\zs;', 1)[0] : a:pat
    5              0.000056 	let cur_cmd = 'keepj norm! '.( s:mw_order == 'btt' ? 'G' : 'gg' ).'1|'
                            
                            	" Setup the match window
    5              0.000553 	sil! exe '%d _ | res' height
                            	" Print the new items
    5              0.000038 	if empty(lines)
    1              0.000009 		let [s:matched, s:lines] = [[], []]
    1              0.000005 		let lines = [' == NO ENTRIES ==']
    1   0.000048   0.000028 		cal setline(1, s:offset(lines, height - 1))
    1   0.000038   0.000035 		setl noma nocul
    1              0.000029 		exe cur_cmd
    1   0.000038   0.000013 		cal s:unmarksigns()
    1   0.000053   0.000020 		if s:dohighlight() | cal clearmatches() | en
    1              0.000003 		retu
                            	en
    4              0.000073 	let s:matched = copy(lines)
                            	" Sorting
    4   0.000459   0.000055 	if !s:nosort()
    4              0.000034 		let s:compat = s:martcs.pat
    4   0.046369   0.000495 		cal sort(lines, 's:mixedsort')
    4              0.000017 		unl s:compat
    4              0.000005 	en
    4              0.000040 	if s:mw_order == 'btt' | cal reverse(lines) | en
    4              0.000034 	let s:lines = copy(lines)
    4   0.013102   0.000719 	cal map(lines, s:flfunc)
    4   0.000217   0.000124 	cal setline(1, s:offset(lines, height))
    4   0.000143   0.000052 	cal s:unmarksigns()
    4   0.000101   0.000034 	cal s:remarksigns()
                            	" Highlighting
    4   0.000169   0.000037 	if s:dohighlight()
    4   0.001975   0.000067 		cal s:highlight(pat, s:mathi[1])
    4              0.000006 	en
    4   0.000131   0.000119 	setl noma cul
    4              0.000123 	exe cur_cmd

FUNCTION  391()
Called 13 times
Total time:   0.000086
 Self time:   0.000086

count  total (s)   self (s)
   13              0.000079   call insert(self._sections, [a:group, a:contents], a:position)

FUNCTION  394()
Called 56 times
Total time:   0.463469
 Self time:   0.048015

count  total (s)   self (s)
   56              0.000160   let side = 1
   56              0.000107   let line = ''
   56              0.000124   let i = 0
   56              0.000253   let length = len(self._sections)
   56              0.000118   let split = 0
   56              0.000138   let is_empty = 0
   56              0.000162   let prev_group = ''
                            
  362              0.000997   while i < length
  306              0.001387     let section = self._sections[i]
  306              0.001097     let group = section[0]
  306              0.000989     let contents = section[1]
  306              0.000769     let pgroup = prev_group
  306   0.009428   0.002927     let prev_group = airline#builder#get_prev_group(self._sections, i)
  306              0.001363     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
                                elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
                                elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
                                endif
  306              0.000517     if is_empty
                                  let prev_group = pgroup
                                endif
  306   0.008021   0.002638     let is_empty = s:section_is_empty(self, contents)
                            
  306              0.000472     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
                                endif
                            
  306              0.000590     if group == ''
                                  let line .= contents
                                elseif group == '|'
   47              0.000085       let side = 0
   47              0.000162       let line .= contents
   47              0.000079       let split = 1
   47              0.000050     else
  259              0.000568       if prev_group == ''
   56              0.000315         let line .= '%#'.group.'#'
   56              0.000095       elseif split
   47              0.000076         if !is_empty
   47   0.076886   0.000496           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
   47              0.000057         endif
   47              0.000104         let split = 0
   47              0.000044       else
  156              0.000264         if !is_empty
  156   0.309428   0.001777           let line .= s:get_seperator(self, prev_group, group, side)
  156              0.000218         endif
  156              0.000164       endif
  259   0.023242   0.003713       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
  259              0.000289     endif
                            
  306              0.001182     let i = i + 1
  306              0.000579   endwhile
                            
   56              0.000133   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
   15              0.001391     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
   15              0.000031   endif
   56              0.000155   return line

FUNCTION  396()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000001     if a:0 == 1
                                    let self._files[a:1] = a:fileinfo
                                else
    1              0.000002         let fname = a:fileinfo.fpath
    1              0.000002         let self._files[fname] = a:fileinfo
    1              0.000001     endif

FUNCTION  397()
Called 23 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
   23              0.000081     return has_key(self._files, a:fname)

FUNCTION  airline#util#getwinvar()
Called 187 times
Total time:   0.001164
 Self time:   0.001164

count  total (s)   self (s)
  187              0.001057     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  <SNR>179_Open()
Called 1 time
Total time:   0.005115
 Self time:   0.002898

count  total (s)   self (s)
    1   0.000092   0.000027 	cal s:log(1)
    1   0.000756   0.000024 	cal s:getenv()
    1   0.000040   0.000018 	cal s:execextvar('enter')
    1              0.000870 	sil! exe 'keepa' ( s:mw_pos == 'top' ? 'to' : 'bo' ) '1new ControlP'
    1   0.000090   0.000052 	cal s:buffunc(1)
    1              0.000020 	let [s:bufnr, s:winw] = [bufnr('%'), winwidth(0)]
    1              0.000009 	let [s:focus, s:prompt] = [1, ['', '', '']]
    1              0.000004 	abc <buffer>
    1              0.000007 	if !exists('s:hstry')
    1   0.001040   0.000316 		let hst = filereadable(s:gethistloc()[1]) ? s:gethistdata() : ['']
    1              0.000012 		let s:hstry = empty(hst) || !s:maxhst ? [''] : hst
    1              0.000003 	en
   34              0.000357 	for [ke, va] in items(s:glbs) | if exists('+'.ke)
   17              0.000828 		sil! exe 'let s:glb_'.ke.' = &'.ke.' | let &'.ke.' = '.string(va)
   33              0.000092 	en | endfo
    1              0.000023 	if s:opmul != '0' && has('signs')
    1              0.000064 		sign define ctrlpmark text=+> texthl=CtrlPMark
    1              0.000036 		hi def link CtrlPMark Search
    1              0.000004 	en
    1   0.000717   0.000081 	cal s:setupblank()

FUNCTION  <SNR>135_get_seperator()
Called 156 times
Total time:   0.307651
 Self time:   0.003331

count  total (s)   self (s)
  156   0.061398   0.001384   if airline#builder#should_change_group(a:prev_group, a:group)
  148   0.245979   0.001673     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
    8              0.000059     return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  airline#extensions#tabline#buffers#invalidate()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004   let s:current_bufnr = -1

FUNCTION  <SNR>144_initFoldState()
Called 14 times
Total time:   0.000324
 Self time:   0.000284

count  total (s)   self (s)
   14              0.000025     let fileinfo = self.fileinfo
                            
   14   0.000132   0.000092     if a:known_files.has(fileinfo.fpath) && has_key(fileinfo, '_tagfolds_old') && has_key(fileinfo._tagfolds_old[self.fields.kind], self.fullpath)
                                    " The file has been updated and the tag was there before, so copy its
                                    " old fold state
                                    let fileinfo.tagfolds[self.fields.kind][self.fullpath] = fileinfo._tagfolds_old[self.fields.kind][self.fullpath]
                                elseif self.depth >= fileinfo.foldlevel
                                    let fileinfo.tagfolds[self.fields.kind][self.fullpath] = 1
                                else
   14              0.000057         let fileinfo.tagfolds[self.fields.kind][self.fullpath] = fileinfo.kindfolds[self.fields.kind]
   14              0.000008     endif

FUNCTION  ctrlp#syntax()
Called 1 time
Total time:   0.000518
 Self time:   0.000253

count  total (s)   self (s)
    1   0.000016   0.000007 	if ctrlp#nosy() | retu | en
   50   0.000328   0.000098 	for [ke, va] in items(s:hlgrps) | cal ctrlp#hicheck('CtrlP'.ke, va) | endfo
    1              0.000008 	let bgColor=synIDattr(synIDtrans(hlID('Normal')), 'bg')
    1              0.000012 	if bgColor !~ '^-1$\|^$'
    1              0.000025 		sil! exe 'hi CtrlPLinePre guifg='.bgColor.' ctermfg='.bgColor
    1              0.000001 	en
    1              0.000013 	sy match CtrlPNoEntries '^ == NO ENTRIES ==$'
    1              0.000005 	if hlexists('CtrlPLinePre')
    1              0.000011 		exe "sy match CtrlPLinePre '^".escape(get(g:, 'ctrlp_line_prefix', '>'),'^$.*~\')."'"
    1              0.000001 	en
                            
    1   0.000032   0.000006 	if s:curtype() == 'buf' && s:has_conceal
                            		sy region CtrlPBufferNr     matchgroup=CtrlPLinePre start='^>\s\+' end='\s'
                            		sy region CtrlPBufferInd    concealends matchgroup=Ignore start='<bi>' end='</bi>'
                            		sy region CtrlPBufferRegion concealends matchgroup=Ignore start='<bn>' end='</bn>' contains=CtrlPBufferHid,CtrlPBufferHidMod,CtrlPBufferVis,CtrlPBufferVisMod,CtrlPBufferCur,CtrlPBufferCurMod
                            		sy region CtrlPBufferHid    concealends matchgroup=Ignore     start='\s*{' end='}' contained
                            		sy region CtrlPBufferHidMod concealends matchgroup=Ignore    start='+\s*{' end='}' contained
                            		sy region CtrlPBufferVis    concealends matchgroup=Ignore   start='\*\s*{' end='}' contained
                            		sy region CtrlPBufferVisMod concealends matchgroup=Ignore  start='\*+\s*{' end='}' contained
                            		sy region CtrlPBufferCur    concealends matchgroup=Ignore  start='\*!\s*{' end='}' contained
                            		sy region CtrlPBufferCurMod concealends matchgroup=Ignore start='\*+!\s*{' end='}' contained
                            		sy region CtrlPBufferPath   concealends matchgroup=Ignore start='<bp>' end='</bp>'
                            	en

FUNCTION  <SNR>47_abs_path()
Called 25 times
Total time:   0.000979
 Self time:   0.000979

count  total (s)   self (s)
   25              0.000810   let p = resolve(expand('#'.a:bufnr.':p'))
   25              0.000134   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  gitgutter#hunk#hunks()
Called 2 times
Total time:   0.000040
 Self time:   0.000017

count  total (s)   self (s)
    2   0.000037   0.000014   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  <SNR>103_indent_spaces()
Called 3 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    3              0.000017     if &softtabstop > 0
    3              0.000015         return &softtabstop
                                elseif &softtabstop < 0 && &shiftwidth > 0
                                    return &shiftwidth
                                endif
                                return &tabstop

FUNCTION  <SNR>175_highlight_name_for_change()
Called 16 times
Total time:   0.000178
 Self time:   0.000178

count  total (s)   self (s)
   16              0.000031   if a:text ==# 'added'
    1              0.000002     return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
    4              0.000006     return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
   10              0.000016     return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
    1              0.000002     return 'GitGutterLineModifiedRemoved'
                              endif

FUNCTION  syntastic#util#getbufvar()
Called 450 times
Total time:   0.008077
 Self time:   0.008077

count  total (s)   self (s)
  450              0.007520     return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)

FUNCTION  gitgutter#init_buffer()
Called 5 times
Total time:   0.002004
 Self time:   0.000158

count  total (s)   self (s)
    5   0.000505   0.000034   if gitgutter#utility#is_active(a:bufnr)
    3   0.000096   0.000024     let p = gitgutter#utility#repo_path(a:bufnr, 0)
    3              0.000010     if type(p) != s:t_string || empty(p)
    1   0.001334   0.000031       call gitgutter#utility#set_repo_path(a:bufnr)
    1              0.000001     endif
    3              0.000002   endif

FUNCTION  <SNR>135_get_accented_line()
Called 259 times
Total time:   0.019529
 Self time:   0.019529

count  total (s)   self (s)
  259              0.000743   if a:self._context.active
  205              0.000525     let contents = []
  205              0.002608     let content_parts = split(a:contents, '__accent')
  386              0.001048     for cpart in content_parts
  181              0.002378       let accent = matchstr(cpart, '_\zs[^#]*\ze')
  181              0.000851       call add(contents, cpart)
  181              0.000353     endfor
  205              0.001017     let line = join(contents, a:group)
  205              0.001929     let line = substitute(line, '__restore__', a:group, 'g')
  205              0.000230   else
   54              0.001569     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
   54              0.000651     let line = substitute(line, '%#__restore__#', '', 'g')
   54              0.000085   endif
  259              0.000516   return line

FUNCTION  syntastic#util#isRunningWindows()
Called 3 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    3              0.000024     return has('win16') || has('win32') || has('win64')

FUNCTION  <SNR>159_OnTextChangedNormalMode()
Called 9 times
Total time:   0.010514
 Self time:   0.000122

count  total (s)   self (s)
    9   0.000416   0.000069   if !s:AllowedToCompleteInCurrentBuffer()
    6              0.000004     return
                              endif
                            
    3   0.010078   0.000033   call s:OnFileReadyToParse()

FUNCTION  <SNR>144_getChildren()
Called 21 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
   21              0.000019     return self._childlist

FUNCTION  <SNR>103_cache()
Called 3 times
Total time:   0.110411
 Self time:   0.075537

count  total (s)   self (s)
    3              0.000023     let cache = [{}]  " With padding for lnum offset
    3              0.000146     let lines = getbufline(bufnr('%'), 1, '$')
    3              0.000023     let lnum_last = len(lines)
    3              0.000027     call insert(lines, '')  " Padding for lnum offset
                            
    3   0.000090   0.000050     let ind_spaces = s:indent_spaces()
                            
    3              0.000011     let defs_stack = []
    3              0.000010     let ind_def = -1
    3              0.000010     let in_string = 0
    3              0.000012     let docstring_start = -1
    3              0.000009     let in_import = 0
    3              0.000011     let was_import = 0
  294              0.000648     for lnum in range(1, lnum_last)
  291              0.001146         let line = lines[lnum]
                            
                                    " Multiline strings
  291              0.000528         if in_string
    6              0.000033             let foldlevel = len(defs_stack)
    6              0.000069             call add(cache, {'is_blank': 0, 'is_comment': 0, 'foldexpr': foldlevel})
                            
    6   0.000819   0.000092             let string_match = s:multi_string(line, string_end_re, 1)
    6              0.000025             if string_match[0]
                                            " Starting new multiline string?
    3              0.000010                 if string_match[2]
                                                let in_string_single = string_match[1]
                                                let string_end_re = string_match[3]
                                                let docstring_start = -1  " Invalid docstring
                                            elseif in_string_single && line !~# s:line_cont_re
                                                let in_string = 0
                                            endif
    3              0.000006             else
    3              0.000010                 if docstring_start != -1
    3              0.000011                     let foldlevel += 1
    3              0.000030                     let cache[docstring_start]['foldexpr'] = '>' . foldlevel
    9              0.000048                     for lnum_docstring in range((docstring_start + 1), lnum)
    6              0.000038                         let cache[lnum_docstring]['foldexpr'] = foldlevel
    6              0.000012                     endfor
    3              0.000010                     let docstring_start = -1
    3              0.000005                 endif
    3              0.000008                 let in_string = 0
    3              0.000004             endif
    6              0.000012             continue
                                    endif
                            
                                    " Blank lines
  285              0.003077         if line =~# s:blank_re
   62              0.000148             if lnum == lnum_last
                                            call add(cache, {'is_blank': 1, 'is_comment': 0, 'foldexpr': 0})
                                            call s:blanks_adj(cache, lnum, 0)
                                        else
   62              0.000582                 call add(cache, {'is_blank': 1, 'is_comment': 0, 'foldexpr': len(defs_stack)})
   62              0.000082             endif
   62              0.000107             continue
                                    endif
                            
  223   0.012183   0.001973         let ind = s:indent(line, ind_spaces)
                            
                                    " Comments
  223              0.001967         if line =~# s:comment_re
   60              0.000624             call add(cache, {'is_blank': 0, 'is_comment': 1, 'indent': ind})
   60              0.000177             let foldlevel = 0
   60              0.000295             let defs_stack_len = len(defs_stack)
   60              0.000329             for idx in range(defs_stack_len)
   39              0.000246                 if ind > cache[defs_stack[idx]]['indent']
   39              0.000179                     let foldlevel = defs_stack_len - idx
   39              0.000065                     break
                                            endif
                                        endfor
   60              0.000421             let cache[lnum]['foldexpr'] = foldlevel
   60   0.005483   0.000661             call s:blanks_adj(cache, lnum, foldlevel)
   60              0.000112             continue
                                    endif
                            
  163              0.007051         call add(cache, {'is_blank': 0, 'is_comment': 0,            'is_def': line =~# b:SimpylFold_def_re, 'indent': ind})
                            
                                    " Definitions
  163              0.000772         if cache[lnum]['is_def']
   22              0.000097             if empty(defs_stack)
    3              0.000021                 let defs_stack = [lnum]
    3              0.000009             elseif ind == ind_def
   16              0.000113                 let defs_stack[0] = lnum
   16              0.000045             elseif ind > ind_def
    3              0.000020                 call insert(defs_stack, lnum)
    3              0.000010             elseif ind < ind_def
                                            let defs_stack = [lnum] + s:defs_stack_prune(cache, defs_stack, ind)
                                        endif
   22              0.000156             let foldlevel = len(defs_stack) - 1
   22              0.000070             let ind_def = ind
   22   0.001647   0.000279             call s:blanks_adj(cache, lnum, foldlevel)
   22              0.000216             let cache[lnum]['foldexpr'] = '>' . (foldlevel + 1)
   22              0.000049             continue
                                    endif
                            
                                    " Everything else
  141              0.000442         if !empty(defs_stack)
  129              0.000249             if ind == ind_def
                                            let defs_stack = defs_stack[1:]
                                            let ind_def = cache[defs_stack[0]]['indent']
                                        elseif ind < ind_def
                                            let defs_stack = s:defs_stack_prune(cache, defs_stack, ind)
                                            if !empty(defs_stack)
                                                let ind_def = cache[defs_stack[0]]['indent']
                                            else
                                                let ind_def = -1
                                            endif
                                        endif
  129              0.000126         endif
  141              0.000538         let foldlevel = len(defs_stack)
                            
                                    " Multiline strings start
  141   0.015209   0.001448         let string_match = s:multi_string(line, s:string_start_re, 0)
  141              0.000433         if string_match[0]
    3              0.000016             let in_string = 1
    3              0.000017             let in_string_single = string_match[1]
    3              0.000016             let string_end_re = string_match[3]
                            
                                        " Docstrings
    3              0.000048             if b:SimpylFold_fold_docstring && !string_match[2] && string_match[4] =~# s:blank_re
    3              0.000016                 let lnum_prev = lnum - 1
    3   0.000576   0.000075                 if lnum == 1 || s:are_lines_prev_blank(cache, lnum) || ( !cache[lnum_prev]['is_blank'] && !cache[lnum_prev]['is_comment'] && ( cache[lnum_prev]['is_def'] || lines[lnum_prev] =~# s:multi_def_end_re ) )
    3              0.000012                     let docstring_start = lnum
    3              0.000005                 endif
    3              0.000009             endif
                            
    3              0.000023             let cache[lnum]['foldexpr'] = foldlevel
    3              0.000006             continue
                                    endif
                            
                                    " Imports
  138              0.000364         if b:SimpylFold_fold_import
  138              0.000198             if in_import
                                            if line =~# import_end_re
                                                let in_import = 0
                                            endif
                            
                                            call s:blanks_adj(cache, lnum, foldlevel + 1)
                                            let cache[lnum]['foldexpr'] = foldlevel + 1
                                            continue
                                        elseif match(line, s:import_start_re) != -1
    9              0.000405                 let import_cont_match = matchlist(line, s:import_cont_re)
    9              0.000057                 if !empty(import_cont_match)
                                                if import_cont_match[1] ==# '('
                                                    let import_end_re = s:import_end_paren_re
                                                    let in_import = 1
                                                elseif import_cont_match[2] ==# '\'
                                                    let import_end_re = s:import_end_esc_re
                                                    let in_import = 1
                                                endif
                                            endif
                            
    9              0.000029                 if was_import
    6   0.000356   0.000105                     call s:blanks_adj(cache, lnum, foldlevel + 1)
    6              0.000063                     let cache[lnum]['foldexpr'] = foldlevel + 1
    6              0.000012                 else
    3              0.000038                     let cache[lnum]['foldexpr'] = '>' . (foldlevel + 1)
    3              0.000005                 endif
    9              0.000031                 let was_import = 1
    9              0.000027                 continue
                                        else
  129              0.000283                 let was_import = 0
  129              0.000139             endif
  129              0.000123         endif
                            
                                    " Normal
  129   0.004262   0.001068         call s:blanks_adj(cache, lnum, foldlevel)
  129              0.000573         let cache[lnum]['foldexpr'] = foldlevel
  129              0.000173     endfor
                            
    3              0.000010     return cache

FUNCTION  xolox#misc#msg#debug()
Called 4 times
Total time:   0.000186
 Self time:   0.000186

count  total (s)   self (s)
                              " Show a formatted debugging message to the user, *if the user has enabled
                              " increased verbosity by setting Vim's ['verbose'] [] option to one
                              " (1) or higher*.
                              "
                              " This function has the same argument handling as the
                              " `xolox#misc#msg#info()` function.
                              "
                              " In the case of `xolox#misc#msg#debug()`, automatic string coercion
                              " provides lazy evaluation in the sense that complex data structures are
                              " only converted to strings when the user has enabled increased verbosity.
                              "
                              " ['verbose']: http://vimdoc.sourceforge.net/htmldoc/options.html#'verbose'
    4              0.000042   if &vbs >= 1
                                call s:show_message('Question', a:000)
                              endif

FUNCTION  airline#extensions#syntastic#get_error()
Called 223 times
Total time:   0.079485
 Self time:   0.003138

count  total (s)   self (s)
  223   0.079292   0.002945   return airline#extensions#syntastic#get('error')

FUNCTION  <SNR>154_lash()
Called 4 times
Total time:   0.000147
 Self time:   0.000147

count  total (s)   self (s)
    4              0.000139 	retu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''

FUNCTION  gitgutter#hunk#increment_lines_modified()
Called 3 times
Total time:   0.000161
 Self time:   0.000048

count  total (s)   self (s)
    3   0.000080   0.000017   let summary = gitgutter#hunk#summary(a:bufnr)
    3              0.000009   let summary[1] += a:count
    3   0.000070   0.000020   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  430()
Called 6 times
Total time:   0.000208
 Self time:   0.000091

count  total (s)   self (s)
    6              0.000015     let bufnum = get(self.buffers, a:i, -1)
    6              0.000005     if bufnum == -1
                                  return ''
                                endif
    6   0.000143   0.000026     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    6              0.000010     if bufnum == bufnr('%')
    3              0.000008       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
    3              0.000001     endif
    6              0.000004     return group

FUNCTION  <SNR>45_savetofile()
Called 1 time
Total time:   0.009724
 Self time:   0.000012

count  total (s)   self (s)
    1   0.009723   0.000011 	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)

FUNCTION  gitgutter#hunk#increment_lines_added()
Called 1 time
Total time:   0.000054
 Self time:   0.000016

count  total (s)   self (s)
    1   0.000027   0.000006   let summary = gitgutter#hunk#summary(a:bufnr)
    1              0.000003   let summary[0] += a:count
    1   0.000023   0.000006   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  fugitive#extract_git_dir()
Called 1 time
Total time:   0.000191
 Self time:   0.000107

count  total (s)   self (s)
    1   0.000027   0.000010   if s:shellslash(a:path) =~# '^fugitive://.*//'
                                return matchstr(s:shellslash(a:path), '\C^fugitive://\zs.\{-\}\ze//')
                              endif
    1              0.000003   if isdirectory(a:path)
                                let path = fnamemodify(a:path, ':p:s?[\/]$??')
                              else
    1              0.000018     let path = fnamemodify(a:path, ':p:h:s?[\/]$??')
    1              0.000001   endif
    1   0.000023   0.000011   let root = s:shellslash(resolve(path))
    1              0.000001   let previous = ""
    1              0.000002   while root !=# previous
    1              0.000006     if root =~# '\v^//%([^/]+/?)?$'
                                  " This is for accessing network shares from Cygwin Vim. There won't be
                                  " any git directory called //.git or //serverName/.git so let's avoid
                                  " checking for them since such checks are extremely slow.
                                  break
                                endif
    1              0.000006     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
                                  break
                                endif
    1              0.000004     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
                                  return simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??'))
                                endif
    1   0.000028   0.000007     if fugitive#is_git_dir($GIT_DIR)
                                  " Ensure that we've cached the worktree
                                  call s:configured_tree(simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??')))
                                  if has_key(s:dir_for_worktree, root)
                                    return s:dir_for_worktree[root]
                                  endif
                                endif
    1   0.000019   0.000006     let dir = s:sub(root, '[\/]$', '') . '/.git'
    1              0.000004     let type = getftype(dir)
    1   0.000026   0.000005     if type ==# 'dir' && fugitive#is_git_dir(dir)
    1              0.000001       return dir
                                elseif type ==# 'link' && fugitive#is_git_dir(dir)
                                  return resolve(dir)
                                elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
                                    return simplify(root.'/'.line[8:-1])
                                  elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
                                    return line[8:-1]
                                  endif
                                elseif fugitive#is_git_dir(root)
                                  return root
                                endif
                                let previous = root
                                let root = fnamemodify(root, ':h')
                              endwhile
                              return ''

FUNCTION  syntastic#util#var()
Called 55 times
Total time:   0.000662
 Self time:   0.000383

count  total (s)   self (s)
   55   0.000638   0.000359     return call('syntastic#util#rawVar', ['syntastic_' . a:name] + a:000)

FUNCTION  syntastic#util#compareLexi()
Called 7 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
    9              0.000043     for idx in range(max([len(a:a), len(a:b)]))
    9              0.000029         let a_element = str2nr(get(a:a, idx, 0))
    9              0.000022         let b_element = str2nr(get(a:b, idx, 0))
    9              0.000011         if a_element != b_element
    7              0.000012             return a_element > b_element ? 1 : -1
                                    endif
    2              0.000002     endfor
                                " still here, thus everything matched
                                return 0

FUNCTION  ctrlp#hicheck()
Called 17 times
Total time:   0.000230
 Self time:   0.000230

count  total (s)   self (s)
   17              0.000100 	if !hlexists(a:grp)
   10              0.000106 		exe 'hi link' a:grp a:defgrp
   10              0.000005 	en

FUNCTION  <SNR>138_Init()
Called 35 times
Total time:   0.002962
 Self time:   0.002962

count  total (s)   self (s)
   35              0.000254     if s:checked_ctags == 2 && a:silent
                                    return 0
                                elseif s:checked_ctags != 1
                                    if !s:CheckForExCtags(a:silent)
                                        return 0
                                    endif
                                endif
                            
   35              0.000163     if !s:type_init_done
                                    call s:InitTypes()
                                endif
                            
   35              0.000170     if !s:autocommands_done
                                    call s:CreateAutocommands()
                                    call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
                                endif
                            
   35              0.000188     let s:init_done = 1
   35              0.000150     return 1

FUNCTION  ctrlp#utils#mkdir()
Called 3 times
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
    3              0.000047 	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
                            	en
    3              0.000007 	retu a:dir

FUNCTION  <SNR>68_ClearCache()
Called 1 time
Total time:   0.000388
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000085   0.000007     let loclist = g:SyntasticLoclist.current(a:buf)
    1   0.000242   0.000009     call s:notifiers.reset(loclist)
    1   0.000061   0.000004     call loclist.destroy()

FUNCTION  <SNR>176_on_exit_untracked()
Called 2 times
Total time:   0.000167
 Self time:   0.000097

count  total (s)   self (s)
    2   0.000123   0.000053     call s:untracked_output(self, self.buf)
    2              0.000024     if has_key(s:untracked_jobs, self.file)
    1              0.000008       call remove(s:untracked_jobs, self.file)
    1              0.000001     endif

FUNCTION  <SNR>179_multipliers()
Called 53 times
Total time:   0.001338
 Self time:   0.001338

count  total (s)   self (s)
   53              0.000212 	let mp0 = !a:1 ? 0 : 2
   53              0.000274 	let mp1 = !a:2 ? 0 : 1 + ( !mp0 ? 1 : mp0 )
   53              0.000281 	let mp2 = !a:3 ? 0 : 1 + ( !( mp0 + mp1 ) ? 1 : ( mp0 + mp1 ) )
   53              0.000259 	let mp3 = !a:4 ? 0 : 1 + ( !( mp0 + mp1 + mp2 ) ? 1 : ( mp0 + mp1 + mp2 ) )
   53              0.000229 	retu [mp0, mp1, mp2, mp3]

FUNCTION  <SNR>131_get_syn()
Called 5710 times
Total time:   0.204049
 Self time:   0.204049

count  total (s)   self (s)
 5710              0.018774   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
 5710              0.008889   let color = ''
 5710              0.029288   if hlexists(a:group)
 5184              0.039348     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
 5184              0.004599   endif
 5710              0.015556   if empty(color) || color == -1
                                " should always exists
  566              0.005513     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
  566              0.001231     if empty(color) || color == -1
                                  let color = 'NONE'
                                endif
  566              0.000344   endif
 5710              0.007835   return color

FUNCTION  420()
Called 3 times
Total time:   0.000175
 Self time:   0.000073

count  total (s)   self (s)
    3              0.000013     let bufnum = get(self.buffers, a:i, -1)
    3              0.000006     if bufnum == -1
                                  return ''
                                endif
    3   0.000123   0.000021     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    3              0.000009     if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
    3              0.000004     return group

FUNCTION  airline#extensions#tabline#group_of_bufnr()
Called 39 times
Total time:   0.001083
 Self time:   0.001083

count  total (s)   self (s)
   39              0.000132   let cur = bufnr('%')
   39              0.000070   if cur == a:bufnr
   12              0.000042     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
    9              0.000015       let group = 'airline_tabmod'
    9              0.000002     else
    3              0.000005       let group = 'airline_tabsel'
    3              0.000002     endif
   12              0.000006   else
   27              0.000138     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
   24              0.000055       let group = 'airline_tabmod_unsel'
   24              0.000065     elseif index(a:tab_bufs, a:bufnr) > -1
                                  let group = 'airline_tab'
                                else
    3              0.000003       let group = 'airline_tabhid'
    3              0.000002     endif
   27              0.000023   endif
   39              0.000048   return group

FUNCTION  423()
Called 1 time
Total time:   0.000146
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000005     let bufnum = get(self.buffers, a:i, -1)
    1   0.000057   0.000006     let group = self.get_group(a:i)
    1   0.000049   0.000005     let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
    1              0.000003     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1              0.000003       let space = s:spc
    1              0.000001     else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
    1              0.000003     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. get(s:number_map, a:i+1, '') . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
    1              0.000005       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif

FUNCTION  <SNR>20_init()
Called 9 times
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
    9              0.000032   if s:airline_initialized
    9              0.000018     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  echom 'Could not resolve airline theme "' . g:airline_theme . '". Themes have been migrated to github.com/vim-airline/vim-airline-themes.'
                                  let g:airline_theme = 'dark'
                                endtry
                                silent call airline#switch_theme(g:airline_theme)
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              silent doautocmd User AirlineAfterInit

FUNCTION  <SNR>179_offset()
Called 5 times
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
    5              0.000043 	let s:offset = s:mw_order == 'btt' ? ( a:height - s:res_count ) : 0
    5              0.000044 	retu s:offset > 0 ? ( repeat([''], s:offset) + a:lines ) : a:lines

FUNCTION  424()
Called 3 times
Total time:   0.000216
 Self time:   0.000095

count  total (s)   self (s)
    3              0.000018     let bufnum = get(self.buffers, a:i, -1)
    3              0.000007     if bufnum == -1
                                  return ''
                                endif
    3   0.000149   0.000028     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    3              0.000011     if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
    3              0.000006     return group

FUNCTION  <SNR>179_comparent()
Called 53 times
Total time:   0.012948
 Self time:   0.003074

count  total (s)   self (s)
                            	" By same parent dir
   53              0.000275 	if !stridx(s:crfpath, s:dyncwd)
   53   0.003389   0.000919 		let [as1, as2] = [s:dyncwd.s:lash().a:1, s:dyncwd.s:lash().a:2]
   53   0.008351   0.000947 		let [loc1, loc2] = [s:getparent(as1), s:getparent(as2)]
   53              0.000470 		if loc1 == s:crfpath && loc2 != s:crfpath | retu -1 | en
   42              0.000277 		if loc2 == s:crfpath && loc1 != s:crfpath | retu 1  | en
   41              0.000075 		retu 0
                            	en
                            	retu 0

FUNCTION  <SNR>144_isFoldable()
Called 11 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
   11              0.000015     return !empty(self._childlist)

FUNCTION  fugitive#is_git_dir()
Called 2 times
Total time:   0.000042
 Self time:   0.000026

count  total (s)   self (s)
    2   0.000024   0.000008   let path = s:sub(a:path, '[\/]$', '') . '/'
    2              0.000017   return getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  <SNR>144_getChildrenByName()
Called 10 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
   10              0.000025     return get(self._childdict, a:tagname, [])

FUNCTION  ctrlp#utils#cachefile()
Called 2 times
Total time:   0.000305
 Self time:   0.000243

count  total (s)   self (s)
    2              0.000035 	let [tail, dir] = [a:0 == 1 ? '.'.a:1 : '', a:0 == 2 ? a:1 : getcwd()]
    2              0.000153 	let cache_file = substitute(dir, '\([\/]\|^\a\zs:\)', '%', 'g').tail.'.txt'
    2   0.000113   0.000051 	retu a:0 == 1 ? cache_file : s:cache_dir.s:lash(s:cache_dir).cache_file

FUNCTION  <SNR>158_is_added()
Called 8 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    8              0.000025   return a:from_count == 0 && a:to_count > 0

FUNCTION  tagbar#prototypes#basetag#new()
Called 16 times
Total time:   0.003135
 Self time:   0.001701

count  total (s)   self (s)
   16              0.000020     let newobj = {}
                            
   16              0.000029     let newobj.name          = a:name
   16              0.000020     let newobj.fields        = {}
   16              0.000019     let newobj.fields.line   = 0
   16              0.000019     let newobj.fields.column = 0
   16              0.000023     let newobj.prototype     = ''
   16              0.000019     let newobj.path          = ''
   16              0.000020     let newobj.fullpath      = a:name
   16              0.000033     let newobj.depth         = 0
   16              0.000017     let newobj.parent        = {}
   16              0.000019     let newobj.tline         = -1
   16              0.000021     let newobj.fileinfo      = {}
   16              0.000017     let newobj.typeinfo      = {}
   16              0.000019     let newobj._childlist    = []
   16              0.000020     let newobj._childdict    = {}
                            
   16   0.000226   0.000109     let newobj.isNormalTag = function(s:add_snr('s:isNormalTag'))
   16   0.000163   0.000075     let newobj.isPseudoTag = function(s:add_snr('s:isPseudoTag'))
   16   0.000180   0.000091     let newobj.isSplitTag = function(s:add_snr('s:isSplitTag'))
   16   0.000159   0.000082     let newobj.isKindheader = function(s:add_snr('s:isKindheader'))
   16   0.000139   0.000063     let newobj.getPrototype = function(s:add_snr('s:getPrototype'))
   16   0.000141   0.000066     let newobj._getPrefix = function(s:add_snr('s:_getPrefix'))
   16   0.000136   0.000059     let newobj.initFoldState = function(s:add_snr('s:initFoldState'))
   16   0.000160   0.000083     let newobj.getClosedParentTline = function(s:add_snr('s:getClosedParentTline'))
   16   0.000145   0.000071     let newobj.isFoldable = function(s:add_snr('s:isFoldable'))
   16   0.000142   0.000067     let newobj.isFolded = function(s:add_snr('s:isFolded'))
   16   0.000134   0.000064     let newobj.openFold = function(s:add_snr('s:openFold'))
   16   0.000136   0.000063     let newobj.closeFold = function(s:add_snr('s:closeFold'))
   16   0.000133   0.000059     let newobj.setFolded = function(s:add_snr('s:setFolded'))
   16   0.000146   0.000063     let newobj.openParents = function(s:add_snr('s:openParents'))
   16   0.000133   0.000061     let newobj.addChild = function(s:add_snr('s:addChild'))
   16   0.000155   0.000068     let newobj.getChildren = function(s:add_snr('s:getChildren'))
   16   0.000149   0.000075     let newobj.getChildrenByName = function(s:add_snr('s:getChildrenByName'))
   16   0.000134   0.000058     let newobj.removeChild = function(s:add_snr('s:removeChild'))
                            
   16              0.000011     return newobj

FUNCTION  <SNR>143_str()
Called 28 times
Total time:   0.001618
 Self time:   0.001618

count  total (s)   self (s)
   28              0.000150     if a:full && self.path != ''
                                    let str = self.path . self.typeinfo.sro . self.name
                                else
   28              0.000145         let str = self.name
   28              0.000065     endif
                            
   28              0.000201     if has_key(self.fields, 'signature')
   28              0.000094         if a:longsig
                                        let str .= self.fields.signature
                                    else
   28              0.000168             let str .= '()'
   28              0.000062         endif
   28              0.000052     endif
                            
   28              0.000099     return str

FUNCTION  tagbar#state#set_current_file()
Called 7 times
Total time:   0.000242
 Self time:   0.000102

count  total (s)   self (s)
    7   0.000236   0.000096     call s:get().setCurrentFile(a:fileinfo)

FUNCTION  <SNR>179_matchlens()
Called 169 times
Total time:   0.023485
 Self time:   0.012645

count  total (s)   self (s)
  169              0.002413 	if empty(a:pat) || index(['^', '$'], a:pat) >= 0 | retu {} | en
  109              0.000680 	let st   = a:0 ? a:1 : 0
  109              0.000734 	let lens = a:0 >= 2 ? a:2 : {}
  109              0.000617 	let nr   = a:0 >= 3 ? a:3 : 0
  109              0.000924 	if nr > 20 | retu {} | en
  109              0.001738 	if match(a:str, a:pat, st) >= 0
   63              0.001715 		let [mst, mnd] = [matchstr(a:str, a:pat, st), matchend(a:str, a:pat, st)]
   63              0.001327 		let lens = extend(lens, { nr : [strlen(mst), mst] })
   63              0.001382 		let lens = s:matchlens(a:str, a:pat, mnd, lens, nr + 1)
   63              0.000139 	en
  109              0.000419 	retu lens

FUNCTION  <SNR>47_winshell()
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    2              0.000014   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>179_fnesc()
Called 5 times
Total time:   0.001363
 Self time:   0.000329

count  total (s)   self (s)
    5   0.001358   0.000324 	retu call('ctrlp#utils#fnesc', a:000)

FUNCTION  ctrlp#utils#globpath()
Called 2 times
Total time:   0.000158
 Self time:   0.000158

count  total (s)   self (s)
    2              0.000154 	retu call('globpath', s:wig_cond ? a:000 : a:000[:1])

FUNCTION  <SNR>175_remove_signs()
Called 2 times
Total time:   0.000057
 Self time:   0.000044

count  total (s)   self (s)
    2   0.000018   0.000011   if a:all_signs && s:supports_star && empty(gitgutter#utility#getbufvar(a:bufnr, 'other_signs'))
    1   0.000009   0.000003     let dummy_sign_present = gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign')
    1              0.000005     execute "sign unplace * buffer=" . a:bufnr
    1              0.000001     if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . a:bufnr
                                endif
    1              0.000001   else
    1              0.000003     for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
    1              0.000001   endif

FUNCTION  airline#builder#get_next_group()
Called 11 times
Total time:   0.000381
 Self time:   0.000381

count  total (s)   self (s)
   11              0.000029   let x = a:i + 1
   11              0.000033   let l = len(a:sections)
   22              0.000039   while x < l
   22              0.000086     let group = a:sections[x][0]
   22              0.000054     if group != '' && group != '|'
   11              0.000015       return group
                                endif
   11              0.000022     let x = x + 1
   11              0.000036   endwhile
                              return ''

FUNCTION  airline#parts#ffenc()
Called 9 times
Total time:   0.000487
 Self time:   0.000487

count  total (s)   self (s)
    9              0.000053   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
    9              0.000043   let bomb     = &l:bomb ? '[BOM]' : ''
    9              0.000153   let ff       = strlen(&ff) ? '['.&ff.']' : ''
    9              0.000097   if expected is# &fenc.bomb.ff
                                return ''
                              else
    9              0.000072     return &fenc.bomb.ff
                              endif

FUNCTION  <SNR>55_apply_if_ready()
Called 2 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    2              0.000007   if !has_key(a:options, 'expandtab') || !has_key(a:options, 'shiftwidth')
    1              0.000001     return 0
                              else
    3              0.000006     for [option, value] in items(a:options)
    2              0.000018       call setbufvar('', '&'.option, value)
    2              0.000002     endfor
    1              0.000001     return 1
                              endif

FUNCTION  <SNR>150_get_separator_change()
Called 24 times
Total time:   0.004726
 Self time:   0.000242

count  total (s)   self (s)
   24   0.004712   0.000228   return s:get_separator_change_with_end(a:new_group, a:old_group, a:end_group, a:end_group, a:sep_size, a:alt_sep_size)

FUNCTION  <SNR>68__skip_file()
Called 2 times
Total time:   0.000200
 Self time:   0.000130

count  total (s)   self (s)
    2              0.000006     let fname = bufname(a:buf)
    2   0.000178   0.000108     let skip = s:_is_quitting(a:buf) || getbufvar(a:buf, 'syntastic_skip_checks') || (getbufvar(a:buf, '&buftype') !=# '') || !filereadable(fname) || getwinvar(0, '&diff') || getwinvar(0, '&previewwindow') || s:_ignore_file(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
    2              0.000002     if skip
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '_skip_file: skipping checks')
                                endif
    2              0.000002     return skip

FUNCTION  <SNR>138_ToggleWindow()
Called 1 time
Total time:   0.000344
 Self time:   0.000042

count  total (s)   self (s)
    1   0.000010   0.000002     call tagbar#debug#log('ToggleWindow called')
                            
    1   0.000034   0.000026     let tagbarwinnr = bufwinnr(s:TagbarBufName())
    1              0.000002     if tagbarwinnr != -1
    1   0.000295   0.000009         call s:CloseWindow()
    1              0.000000         return
                                endif
                            
                                call s:OpenWindow(a:flags)
                            
                                call tagbar#debug#log('ToggleWindow finished')

FUNCTION  <SNR>138_SetStatusLine()
Called 10 times
Total time:   0.057368
 Self time:   0.002536

count  total (s)   self (s)
   10   0.000694   0.000520     let tagbarwinnr = bufwinnr(s:TagbarBufName())
   10              0.000029     if tagbarwinnr == -1
    1              0.000000         return
                                endif
                            
                                " Make sure we're actually in the Tagbar window
    9              0.000034     if tagbarwinnr != winnr()
    6              0.000019         let in_tagbar = 0
    6              0.000021         let prevwinnr = winnr()
    6   0.000617   0.000088         call s:goto_win('p', 1)
    6              0.000032         let pprevwinnr = winnr()
    6   0.000467   0.000066         call s:goto_win(tagbarwinnr, 1)
    6              0.000008     else
    3              0.000006         let in_tagbar = 1
    3              0.000004     endif
                            
    9   0.000468   0.000118     if !empty(tagbar#state#get_current_file(0))
    9   0.000347   0.000064         let fileinfo = tagbar#state#get_current_file(0)
    9              0.000092         let fname = fnamemodify(fileinfo.fpath, ':t')
    9              0.000066         let sorted = get(fileinfo.typeinfo, 'sort', g:tagbar_sort)
    9              0.000011     else
                                    let fname = ''
                                    let sorted = g:tagbar_sort
                                endif
    9              0.000034     let sortstr = sorted ? 'Name' : 'Order'
                            
    9              0.000025     let flags = []
    9              0.000086     let flags += exists('w:autoclose') && w:autoclose ? ['c'] : []
    9              0.000045     let flags += g:tagbar_autoclose ? ['C'] : []
    9              0.000049     let flags += (sorted && g:tagbar_case_insensitive) ? ['i'] : []
    9              0.000034     let flags += g:tagbar_hide_nonpublic ? ['v'] : []
                            
    9              0.000050     if exists('g:tagbar_status_func')
    9              0.000059         let args = [in_tagbar, sortstr, fname, flags]
    9   0.052617   0.000357         let &l:statusline = call(g:tagbar_status_func, args)
    9              0.000013     else
                                    let colour = in_tagbar ? '%#StatusLine#' : '%#StatusLineNC#'
                                    let flagstr = join(flags, '')
                                    if flagstr != ''
                                        let flagstr = '[' . flagstr . '] '
                                    endif
                                    let text = colour . '[' . sortstr . '] ' . flagstr . fname
                                    let &l:statusline = text
                                endif
                            
    9              0.000022     if !in_tagbar
    6   0.000571   0.000099         call s:goto_win(pprevwinnr, 1)
    6   0.000422   0.000059         call s:goto_win(prevwinnr, 1)
    6              0.000006     endif

FUNCTION  <SNR>179_settype()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000011 	retu a:type < 0 ? exists('s:itemtype') ? s:itemtype : 0 : a:type

FUNCTION  <SNR>159_OnFileReadyToParse()
Called 6 times
Total time:   0.016648
 Self time:   0.016218

count  total (s)   self (s)
                              " Accepts an optional parameter that is either 0 or 1. If 1, send a
                              " FileReadyToParse event notification, whether the buffer has changed or not;
                              " effectively forcing a parse of the buffer. Default is 0.
    6              0.000033   let force_parsing = a:0 > 0 && a:1
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one, or if forced.
    6   0.000478   0.000048   if force_parsing || s:Pyeval( "ycm_state.NeedsReparse()" )
    5              0.015874     exec s:python_command "ycm_state.OnFileReadyToParse()"
                            
    5              0.000082     call timer_stop( s:pollers.file_parse_response.id )
    5              0.000102     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
    5              0.000015   endif

FUNCTION  <SNR>47_not_git_dir()
Called 8 times
Total time:   0.001366
 Self time:   0.000335

count  total (s)   self (s)
    8   0.001361   0.000330   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  <SNR>179_Update()
Called 6 times
Total time:   0.075321
 Self time:   0.000948

count  total (s)   self (s)
                            	" Get the previous string if existed
    6              0.000067 	let oldstr = exists('s:savestr') ? s:savestr : ''
                            	" Get the new string sans tail
    6   0.000912   0.000095 	let str = s:sanstail(a:str)
                            	" Stop if the string's unchanged
    6              0.000087 	if str == oldstr && !empty(str) && !exists('s:force') | retu | en
                            	" Optionally send the string to a custom validate function
    5              0.000056 	if s:validate != '' | let str = call(s:validate, [str]) | en
    5              0.000152 	let s:martcs = &scs && str =~ '\u' ? '\C' : ''
    5   0.002154   0.000135 	let pat = s:matcher == {} ? s:SplitPattern(str) : str
    5   0.006830   0.000126 	let lines = s:nolim == 1 && empty(str) ? copy(g:ctrlp_lines) : s:MatchedItems(g:ctrlp_lines, pat, s:mw_res)
    5              0.000062 	if empty(str) | cal clearmatches() | en
    5   0.064932   0.000099 	cal s:Render(lines, pat)
    5              0.000018 	return lines

FUNCTION  <SNR>138_PrintTag()
Called 11 times
Total time:   0.002449
 Self time:   0.001897

count  total (s)   self (s)
   11              0.000024     if g:tagbar_hide_nonpublic && get(a:tag.fields, 'access', 'public') !=# 'public'
                                    let a:tag.tline = -1
                                    return
                                endif
                            
                                " Print tag indented according to depth
   11   0.000491   0.000056     let tagstr = repeat(' ', a:depth * g:tagbar_indent) . a:tag.strfmt()
   11              0.000023     call add(a:output, tagstr)
                            
                                " Save the current tagbar line in the tag for easy highlighting access
   11              0.000027     let offset = g:tagbar_compact && s:short_help ? 0 : line('.')
   11              0.000025     let curline                   = len(a:output) + offset
   11              0.000016     let a:tag.tline               = curline
   11              0.000026     let a:fileinfo.tline[curline] = a:tag
                            
                                " Recursively print children
   11   0.000070   0.000045     if a:tag.isFoldable() && !a:tag.isFolded()
    7              0.000006         for ckind in a:typeinfo.kinds
    6              0.000008             let childfilter = 'v:val.fields.kind ==# ckind.short'
    6              0.000006             if g:tagbar_hide_nonpublic
                                            let childfilter .= ' && get(v:val.fields, "access", "public") ==# "public"'
                                        endif
    6   0.000083   0.000076             let childtags = filter(copy(a:tag.getChildren()), childfilter)
    6              0.000011             if len(childtags) > 0
                                            " Print 'kind' header of following children, but only if they
                                            " are not scope-defining tags (since those already have an
                                            " identifier)
    2              0.000004                 if !has_key(a:typeinfo.kind2scope, ckind.short)
    1              0.000003                     let indent  = (a:depth + 1) * g:tagbar_indent
    1              0.000001                     let indent += g:tagbar_show_visibility
    1              0.000001                     let indent += 1 " fold symbol
    1              0.000004                     call add(a:output, repeat(' ', indent) . '[' . ckind.long . ']')
                                                " Add basic tag to allow folding when on the header line
    1   0.000192   0.000003                     let headertag = tagbar#prototypes#basetag#new(ckind.long)
    1              0.000001                     let headertag.parent = a:tag
    1              0.000002                     let headertag.fileinfo = a:tag.fileinfo
    1              0.000004                     let a:fileinfo.tline[len(a:output) + offset] = headertag
    1              0.000001                 endif
   12              0.000012                 for childtag in childtags
   10              0.000046                     call s:PrintTag(childtag, a:depth + 1, a:output, a:fileinfo, a:typeinfo)
   10              0.000004                 endfor
    2              0.000002             endif
    6              0.000005         endfor
    1              0.000000     endif

FUNCTION  <SNR>179_MapNorms()
Called 1 time
Total time:   0.004460
 Self time:   0.004460

count  total (s)   self (s)
    1              0.000012 	if exists('s:nmapped') && s:nmapped == s:bufnr | retu | en
    1              0.000035 	let pcmd = "nn \<buffer> \<silent> \<k%s> :\<c-u>cal \<SID>%s(\"%s\")\<cr>"
    1              0.000043 	let cmd = substitute(pcmd, 'k%s', 'char-%d', '')
    1              0.000004 	let pfunc = 'PrtFocusMap'
    1              0.000095 	let ranges = [32, 33, 125, 126] + range(35, 91) + range(93, 123)
    4              0.000018 	for each in [34, 92, 124]
    3              0.000167 		exe printf(cmd, each, pfunc, escape(nr2char(each), '"|\'))
    3              0.000009 	endfo
   93              0.000208 	for each in ranges
   92              0.002804 		exe printf(cmd, each, pfunc, nr2char(each))
   92              0.000173 	endfo
   11              0.000037 	for each in range(0, 9)
   10              0.000439 		exe printf(pcmd, each, pfunc, each)
   10              0.000021 	endfo
    6              0.000038 	for [ke, va] in items(s:kprange)
    5              0.000190 		exe printf(pcmd, ke, pfunc, va)
    5              0.000010 	endfo
    1              0.000007 	let s:nmapped = s:bufnr

FUNCTION  ctrlp#utils#lash()
Called 2 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
    2              0.000057 	retu &ssl || !exists('+ssl') ? '/' : '\'

FUNCTION  tagbar#currenttag()
Called 35 times
Total time:   0.023182
 Self time:   0.005296

count  total (s)   self (s)
                                " Indicate that the statusline functionality is being used. This prevents
                                " the CloseWindow() function from removing the autocommands.
   35              0.000250     let s:statusline_in_use = 1
                            
   35              0.000138     if a:0 > 0
                                    " also test for non-zero value for backwards compatibility
   35              0.000771         let longsig   = a:1 =~# 's' || (type(a:1) == type(0) && a:1 != 0)
   35              0.000321         let fullpath  = a:1 =~# 'f'
   35              0.000263         let prototype = a:1 =~# 'p'
   35              0.000088     else
                                    let longsig   = 0
                                    let fullpath  = 0
                                    let prototype = 0
                                endif
                            
   35   0.003438   0.000476     if !s:Init(1)
                                    return a:default
                                endif
                            
   35   0.013869   0.000563     let tag = s:GetNearbyTag(0, 1)
                            
   35              0.000200     if !empty(tag)
   28              0.000092         if prototype
                                        return tag.getPrototype(1)
                                    else
   28   0.002293   0.000675             return printf(a:fmt, tag.str(longsig, fullpath))
                                    endif
                                else
    7              0.000032         return a:default
                                endif

FUNCTION  rainbow_parentheses#load()
Called 6 times
Total time:   0.004851
 Self time:   0.004851

count  total (s)   self (s)
    6              0.000040 	let [level, grp, type] = ['', '', s:types[a:1]]
    6              0.000101 	let alllvls = map(range(1, s:max), '"level".v:val')
    6              0.000014 	if !exists('b:loaded')
    2              0.000003 		let b:loaded = [0,0,0,0]
    2              0.000001 	endif
    6              0.000021 	let b:loaded[a:1] = s:loadtgl && b:loaded[a:1] ? 0 : 1
  102              0.000104 	for each in range(1, s:max)
   96              0.000291 		let region = 'level'. each .(b:loaded[a:1] ? '' : 'none')
   96              0.000229 		let grp = b:loaded[a:1] ? 'level'.each.'c' : 'Normal'
   96              0.000176 		let cmd = 'sy region %s matchgroup=%s start=/%s/ end=/%s/ contains=TOP,%s,NoInParens'
   96              0.003488 		exe printf(cmd, region, grp, type[0], type[1], join(alllvls, ','))
   96              0.000195 		cal remove(alllvls, 0)
   96              0.000062 	endfor

FUNCTION  gitgutter#async#available()
Called 3 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    3              0.000006   return s:available

FUNCTION  <SNR>20_on_window_changed()
Called 9 times
Total time:   0.234496
 Self time:   0.000879

count  total (s)   self (s)
    9              0.000095   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
                              endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
    9              0.000217   let l:key = [bufnr('%'), winnr(), winnr('$'), tabpagenr(), &ft]
    9              0.000130   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.winnr().')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
                                return
                              endif
    9              0.000086   let g:airline_last_window_changed = l:key
    9   0.000191   0.000107   call s:init()
    9   0.233616   0.000083   call airline#update_statusline()

FUNCTION  ctrlp#setdir()
Called 2 times
Total time:   0.000746
 Self time:   0.000188

count  total (s)   self (s)
    2              0.000015 	let cmd = a:0 ? a:1 : 'lc!'
    2   0.000678   0.000120 	sil! exe cmd s:fnesc(a:path, 'c')
    2              0.000046 	let [s:crfilerel, s:dyncwd] = [fnamemodify(s:crfile, ':.'), getcwd()]

FUNCTION  gitgutter#diff#parse_hunk()
Called 8 times
Total time:   0.000318
 Self time:   0.000318

count  total (s)   self (s)
    8              0.000130   let matches = matchlist(a:line, s:hunk_re)
    8              0.000020   if len(matches) > 0
    8              0.000032     let from_line  = str2nr(matches[1])
    8              0.000038     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
    8              0.000027     let to_line    = str2nr(matches[3])
    8              0.000034     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
    8              0.000031     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  <SNR>56_isDarwin()
Called 226 times
Total time:   0.003416
 Self time:   0.003416

count  total (s)   self (s)
  226              0.001875   if exists('s:is_darwin')
  226              0.001015     return s:is_darwin
                              endif
                            
                              if exists('g:WebDevIconsOS')
                                let s:is_darwin = g:WebDevIconsOS ==? 'Darwin'
                                return s:is_darwin
                              endif
                            
                              if has('macunix')
                                let s:is_darwin = 1
                                return s:is_darwin
                              endif
                            
                              if ! has('unix')
                                let s:is_darwin = 0
                                return s:is_darwin
                              endif
                            
                              if system('uname -s') ==# "Darwin\n"
                                let s:is_darwin = 1
                              else
                                let s:is_darwin = 0
                              endif
                            
                              return s:is_darwin

FUNCTION  airline#builder#get_prev_group()
Called 317 times
Total time:   0.006684
 Self time:   0.006684

count  total (s)   self (s)
  317              0.001142   let x = a:i - 1
  364              0.000835   while x >= 0
  297              0.001340     let group = a:sections[x][0]
  297              0.001011     if group != '' && group != '|'
  250              0.000524       return group
                                endif
   47              0.000106     let x = x - 1
   47              0.000071   endwhile
   67              0.000109   return ''

FUNCTION  WebDevIconsGetFileTypeSymbol()
Called 283 times
Total time:   0.141154
 Self time:   0.141154

count  total (s)   self (s)
  283              0.001908   let appendArtifactFix = g:DevIconsAppendArtifactFix
  283              0.000896   if a:0 == 0
  225              0.002231     let fileNodeExtension = expand('%:e')
  225              0.001669     let fileNode = expand('%:t')
  225              0.000898     let isDirectory = 0
  225              0.000471   else
   58              0.000290     let fileNodeExtension = fnamemodify(a:1, ':e')
   58              0.000209     let fileNode = fnamemodify(a:1, ':t')
   58              0.000095     if a:0 > 1
                                  let isDirectory = a:2
                                else
   58              0.000121       let isDirectory = 0
   58              0.000056     endif
                            
   58              0.000077     if a:0 == 3
                                  let appendArtifactFix = a:3
                                endif
   58              0.000054   endif
                            
  283              0.001448   if isDirectory == 0 || g:DevIconsEnableFolderPatternMatching
                            
  283              0.001595     let symbol = g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
  283              0.002335     let fileNodeExtension = tolower(fileNodeExtension)
  283              0.001753     let fileNode = tolower(fileNode)
                            
 2830              0.016150     for [pattern, glyph] in items(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols)
 2547              0.049662       if match(fileNode, pattern) != -1
                                    let symbol = glyph
                                    break
                                  endif
 2547              0.004800     endfor
                            
  283              0.001880     if symbol == g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
  283              0.002279       if has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, fileNode)
    2              0.000004         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[fileNode]
    2              0.000007       elseif ((isDirectory == 1 && g:DevIconsEnableFolderExtensionPatternMatching) || isDirectory == 0) && has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, fileNodeExtension)
  279              0.002173         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[fileNodeExtension]
  279              0.000819       elseif isDirectory == 1
                                    let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
                                  endif
  283              0.000466     endif
                            
  283              0.000459   else
                                let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
                              endif
                            
                              " Temporary (hopefully) fix for glyph issues in gvim (proper fix is with the
                              " actual font patcher)
  283              0.000978   if appendArtifactFix == 1
                                let artifactFix = g:DevIconsArtifactFixChar
                              else
  283              0.001213     let artifactFix = ''
  283              0.000577   endif
                            
  283              0.001681   return symbol . artifactFix
                            

FUNCTION  <SNR>179_mtype()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000015 	retu s:itemtype >= len(s:coretypes) ? s:getextvar('type') : 'path'

FUNCTION  <SNR>72_buffer_type()
Called 2 times
Total time:   0.000360
 Self time:   0.000199

count  total (s)   self (s)
    2   0.000013   0.000007   if self.getvar('fugitive_type') != ''
                                let type = self.getvar('fugitive_type')
                              elseif fnamemodify(self.spec(),':p') =~# '.\git/refs/\|\.git/\w*HEAD$'
                                let type = 'head'
                              elseif self.getline(1) =~ '^tree \x\{40\}$' && self.getline(2) == ''
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \w\{4\} \x\{40\}\>\t'
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \x\{40\}\> \d\t'
                                let type = 'index'
                              elseif isdirectory(self.spec())
                                let type = 'directory'
                              elseif self.spec() == ''
                                let type = 'null'
                              else
    2              0.000002     let type = 'file'
    2              0.000001   endif
    2              0.000002   if a:0
    2              0.000016     return !empty(filter(copy(a:000),'v:val ==# type'))
                              else
                                return type
                              endif

FUNCTION  <SNR>138_ExecuteCtags()
Called 1 time
Total time:   0.008162
 Self time:   0.000141

count  total (s)   self (s)
    1   0.000014   0.000006     call tagbar#debug#log('Executing ctags command: ' . a:ctags_cmd)
                            
    1              0.000005     if &shell =~# 'fish$'
                                    " Reset shell since fish isn't really compatible
                                    let shell_save = &shell
                                    set shell=sh
                                endif
                            
    1              0.000002     if exists('+shellslash')
                                    let shellslash_save = &shellslash
                                    set noshellslash
                                endif
                            
    1              0.000004     if &shell =~ 'cmd\.exe'
                                    let shellxquote_save = &shellxquote
                                    set shellxquote=\"
                                    let shellcmdflag_save = &shellcmdflag
                                    set shellcmdflag=/s\ /c
                                endif
                            
    1   0.000006   0.000004     if tagbar#debug#enabled()
                                    silent 5verbose let ctags_output = system(a:ctags_cmd)
                                    call tagbar#debug#log(v:statusmsg)
                                    call tagbar#debug#log('Exit code: ' . v:shell_error)
                                    redraw!
                                else
    1   0.008067   0.000056         silent let ctags_output = system(a:ctags_cmd)
    1              0.000005     endif
                            
    1              0.000013     if &shell =~ 'cmd\.exe'
                                    let &shellxquote  = shellxquote_save
                                    let &shellcmdflag = shellcmdflag_save
                                endif
                            
    1              0.000004     if exists('+shellslash')
                                    let &shellslash = shellslash_save
                                endif
                            
    1              0.000002     if exists('shell_save')
                                    let &shell = shell_save
                                endif
                            
    1              0.000004     return ctags_output

FUNCTION  328()
Called 2 times
Total time:   0.000114
 Self time:   0.000099

count  total (s)   self (s)
    2              0.000006     if !exists('w:syntastic_loclist_set')
    1              0.000003         let w:syntastic_loclist_set = []
    1              0.000001     endif
    2              0.000011     if a:new || empty(w:syntastic_loclist_set) || w:syntastic_loclist_set != [self._owner, getbufvar(self._owner, 'changedtick')]
    1              0.000003         let replace = !a:new && g:syntastic_reuse_loc_lists && !empty(w:syntastic_loclist_set)
    1   0.000013   0.000005         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: setloclist ' . (replace ? '(replace)' : '(new)'))
    1   0.000032   0.000030         call setloclist(0, self.getRaw(), replace ? 'r' : ' ')
    1              0.000001         try
                                        " Vim 7.4.2200 or later
    1              0.000005             call setloclist(0, [], 'r', { 'title': ':SyntasticCheck ' . self._name })
    1              0.000002         catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                        " do nothing
                                    endtry
    1   0.000009   0.000004         call syntastic#util#setLastTick(self._owner)
    1              0.000004         let w:syntastic_loclist_set = [self._owner, getbufvar(self._owner, 'syntastic_lasttick')]
    1              0.000001     endif

FUNCTION  <SNR>138_PrintHelp()
Called 1 time
Total time:   0.000109
 Self time:   0.000095

count  total (s)   self (s)
    1              0.000003     if !g:tagbar_compact && s:short_help
    1   0.000060   0.000046         silent 0put ='\" Press ' . s:get_map_str('help') . ' for help'
    1              0.000012         silent  put _
    1              0.000001     elseif !s:short_help
                                    silent 0put ='\" Tagbar keybindings'
                                    silent  put ='\"'
                                    silent  put ='\" --------- General ---------'
                                    silent  put ='\" ' . s:get_map_str('jump') . ': Jump to tag definition'
                                    silent  put ='\" ' . s:get_map_str('preview') . ': As above, but stay in'
                                    silent  put ='\"    Tagbar window'
                                    silent  put ='\" ' . s:get_map_str('previewwin') . ': Show tag in preview window'
                                    silent  put ='\" ' . s:get_map_str('nexttag') . ': Go to next top-level tag'
                                    silent  put ='\" ' . s:get_map_str('prevtag') . ': Go to previous top-level tag'
                                    silent  put ='\" ' . s:get_map_str('showproto') . ': Display tag prototype'
                                    silent  put ='\" ' . s:get_map_str('hidenonpublic') . ': Hide non-public tags'
                                    silent  put ='\"'
                                    silent  put ='\" ---------- Folds ----------'
                                    silent  put ='\" ' . s:get_map_str('openfold') . ': Open fold'
                                    silent  put ='\" ' . s:get_map_str('closefold') . ': Close fold'
                                    silent  put ='\" ' . s:get_map_str('togglefold') . ': Toggle fold'
                                    silent  put ='\" ' . s:get_map_str('openallfolds') . ': Open all folds'
                                    silent  put ='\" ' . s:get_map_str('closeallfolds') . ': Close all folds'
                                    silent  put ='\" ' . s:get_map_str('incrementfolds') . ': Increment fold level by 1'
                                    silent  put ='\" ' . s:get_map_str('decrementfolds') . ': Decrement fold level by 1'
                                    silent  put ='\" ' . s:get_map_str('nextfold') . ': Go to next fold'
                                    silent  put ='\" ' . s:get_map_str('prevfold') . ': Go to previous fold'
                                    silent  put ='\"'
                                    silent  put ='\" ---------- Misc -----------'
                                    silent  put ='\" ' . s:get_map_str('togglesort') . ': Toggle sort'
                                    silent  put ='\" ' . s:get_map_str('togglecaseinsensitive') . ': Toggle case insensitive sort option'
                                    silent  put ='\" ' . s:get_map_str('toggleautoclose') . ': Toggle autoclose option'
                                    silent  put ='\" ' . s:get_map_str('zoomwin') . ': Zoom window in/out'
                                    silent  put ='\" ' . s:get_map_str('close') . ': Close window'
                                    silent  put ='\" ' . s:get_map_str('help') . ': Toggle help'
                                    silent  put _
                                endif

FUNCTION  airline#parts#paste()
Called 223 times
Total time:   0.002000
 Self time:   0.002000

count  total (s)   self (s)
  223              0.001773   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>142_clearOldFolds()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000002     if exists('self._tagfolds_old')
                                    unlet self._tagfolds_old
                                endif

FUNCTION  <SNR>159_SetUpCompleteopt()
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
                              " Some plugins (I'm looking at you, vim-notes) change completeopt by for
                              " instance adding 'longest'. This breaks YCM. So we force our settings.
                              " There's no two ways about this: if you want to use YCM then you have to
                              " have these completeopt settings, otherwise YCM won't work at all.
                            
                              " We need menuone in completeopt, otherwise when there's only one candidate
                              " for completion, the menu doesn't show up.
    2              0.000013   set completeopt-=menu
    2              0.000006   set completeopt+=menuone
                            
                              " This is unnecessary with our features. People use this option to insert
                              " the common prefix of all the matches and then add more differentiating chars
                              " so that they can select a more specific match. With our features, they
                              " don't need to insert the prefix; they just type the differentiating chars.
                              " Also, having this option set breaks the plugin.
    2              0.000004   set completeopt-=longest
                            
    2              0.000004   if g:ycm_add_preview_to_completeopt
                                set completeopt+=preview
                              endif

FUNCTION  <SNR>47_unc_path()
Called 3 times
Total time:   0.000079
 Self time:   0.000023

count  total (s)   self (s)
    3   0.000075   0.000019   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  airline#update_statusline()
Called 9 times
Total time:   0.233533
 Self time:   0.001952

count  total (s)   self (s)
    9   0.000289   0.000189   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
   22              0.000184   for nr in filter(range(1, winnr('$')), 'v:val != winnr()')
   13   0.000201   0.000116     if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
   13              0.000104     call setwinvar(nr, 'airline_active', 0)
   13              0.000115     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
   13   0.087388   0.000229     call s:invoke_funcrefs(context, s:inactive_funcrefs)
   13              0.000021   endfor
                            
    9              0.000050   unlet! w:airline_render_left w:airline_render_right
    9              0.000296   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
    9              0.000034   let w:airline_active = 1
    9              0.000090   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    9   0.144441   0.000204   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  <SNR>158_write_buffer()
Called 2 times
Total time:   0.000352
 Self time:   0.000352

count  total (s)   self (s)
    2              0.000063   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
    2              0.000008   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
                              endif
                            
    2              0.000006   let fenc = getbufvar(a:bufnr, '&fileencoding')
    2              0.000003   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
                              endif
                            
    2              0.000004   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]=''.bufcontents[0]
                              endif
                            
    2              0.000246   call writefile(bufcontents, a:file)

FUNCTION  <SNR>159_AllowedToCompleteInBuffer()
Called 208 times
Total time:   0.026655
 Self time:   0.023603

count  total (s)   self (s)
  208              0.003525   let buffer_filetype = getbufvar( a:buffer, '&filetype' )
                            
  208              0.003522   if empty( buffer_filetype ) || getbufvar( a:buffer, '&buftype' ) ==# 'nofile' || buffer_filetype ==# 'qf'
   22              0.000052     return 0
                              endif
                            
  186   0.005718   0.002666   if s:DisableOnLargeFile( a:buffer )
                                return 0
                              endif
                            
  186              0.003131   let whitelist_allows = has_key( g:ycm_filetype_whitelist, '*' ) || has_key( g:ycm_filetype_whitelist, buffer_filetype )
  186              0.001958   let blacklist_allows = !has_key( g:ycm_filetype_blacklist, buffer_filetype )
                            
  186              0.001248   let allowed = whitelist_allows && blacklist_allows
  186              0.000572   if allowed
  186              0.002244     let s:previous_allowed_buffer_number = bufnr( a:buffer )
  186              0.000403   endif
  186              0.000695   return allowed

FUNCTION  ctrlp#utils#cachedir()
Called 4 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    4              0.000023 	retu s:cache_dir

FUNCTION  SyntasticLoclistHide()
Called 1 time
Total time:   0.001085
 Self time:   0.001049

count  total (s)   self (s)
    1   0.000058   0.000022     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: hide')
    1              0.001025     silent! lclose

FUNCTION  ctrlp#complen()
Called 150 times
Total time:   0.001233
 Self time:   0.001233

count  total (s)   self (s)
                            	" By length
  150              0.000689 	let [len1, len2] = [strlen(a:1), strlen(a:2)]
  150              0.000408 	retu len1 == len2 ? 0 : len1 > len2 ? 1 : -1

FUNCTION  syntastic#util#wformat()
Called 4 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    4              0.000009     if a:format ==# ''
    4              0.000005         return a:str
                                endif
                            
                             echomsg string(a:format) . ', ' . string(a:str)
                                let specs = matchlist(a:format, '\v^(-?)(0?)(%([1-9]\d*))?%(\.(\d+))?$')
                                if len(specs) < 5
                                    return a:str
                                endif
                            
                                let flushleft = specs[1] ==# '-'
                                let lpad = specs[2] ==# '0' ? '0' : ' '
                                let minlen = str2nr(specs[3])
                                let maxlen = str2nr(specs[4])
                                let out = substitute(a:str, "\t", ' ', 'g')
                            
                                if maxlen && s:_width(out) > maxlen
                                    let chars = filter(split(out, '\zs\ze', 1), 'v:val !=# ""')
                                    let out = ''
                            
                                    if flushleft
                                        for c in chars
                                            if s:_width(out . c) < maxlen
                                                let out .= c
                                            else
                                                let out .= &encoding ==# 'utf-8' && &termencoding ==# 'utf-8' ? "\u2026" : '>'
                                                break
                                            endif
                                        endfor
                                    else
                                        call reverse(chars)
                                        for c in chars
                                            if s:_width(c . out) < maxlen
                                                let out = c . out
                                            else
                                                let out = (&encoding ==# 'utf-8' && &termencoding ==# 'utf-8' ? "\u2026" : '<') . out
                                                break
                                            endif
                                        endfor
                                    endif
                                endif
                            
                                if minlen && s:_width(out) < minlen
                                    if flushleft
                                        let out .= repeat(' ', minlen - s:_width(out))
                                    else
                                        let out = repeat(lpad, minlen - s:_width(out)) . out
                                    endif
                                endif
                            
                                return out

FUNCTION  airline#parts#readonly()
Called 225 times
Total time:   0.004909
 Self time:   0.004909

count  total (s)   self (s)
  225              0.002032   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
  225              0.001257     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  <SNR>179_strwidth()
Called 29 times
Total time:   0.000318
 Self time:   0.000318

count  total (s)   self (s)
   29              0.000304 	retu exists('*strdisplaywidth') ? strdisplaywidth(a:str) : strlen(a:str)

FUNCTION  <SNR>103_blanks_adj()
Called 217 times
Total time:   0.009635
 Self time:   0.009635

count  total (s)   self (s)
  217              0.001007     let lnum_prev = a:lnum - 1
  423              0.004890     while lnum_prev != 0 && ( a:cache[lnum_prev]['is_blank'] || ( a:cache[lnum_prev]['is_comment'] && a:cache[lnum_prev]['indent'] <= a:cache[(a:lnum)]['indent'] ) )
  206              0.001114         let a:cache[lnum_prev]['foldexpr'] = a:foldlevel
  206              0.000548         let lnum_prev -= 1
  206              0.000310     endwhile

FUNCTION  airline#extensions#tagbar#get_status()
Called 9 times
Total time:   0.052260
 Self time:   0.000499

count  total (s)   self (s)
    9   0.000559   0.000128   let builder = airline#builder#new({ 'active': a:1 })
    9   0.000200   0.000114   call builder.add_section('airline_a', s:spc.'Tagbar'.s:spc)
    9   0.000144   0.000077   call builder.add_section('airline_b', s:spc.a:2.s:spc)
    9   0.000128   0.000072   call builder.add_section('airline_c', s:spc.a:3.s:spc)
    9   0.051210   0.000089   return builder.build()

FUNCTION  <SNR>144_addChild()
Called 10 times
Total time:   0.000111
 Self time:   0.000111

count  total (s)   self (s)
   10              0.000024     call add(self._childlist, a:tag)
                            
   10              0.000021     if has_key(self._childdict, a:tag.name)
                                    call add(self._childdict[a:tag.name], a:tag)
                                else
   10              0.000029         let self._childdict[a:tag.name] = [a:tag]
   10              0.000008     endif

FUNCTION  395()
Called 13 times
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
   13              0.000084     return get(self._files, a:fname, {})

FUNCTION  <SNR>179_glbpath()
Called 2 times
Total time:   0.000275
 Self time:   0.000117

count  total (s)   self (s)
    2   0.000272   0.000114 	retu call('ctrlp#utils#globpath', a:000)

FUNCTION  syntastic#util#bufIsActive()
Called 3 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
                                " convert to number, or hell breaks loose
    3              0.000011     let buf = str2nr(a:buffer)
                            
    3              0.000010     if !bufloaded(buf) || !buflisted(buf)
                                    return 0
                                endif
                            
                                " get rid of hidden buffers
    3              0.000013     for tab in range(1, tabpagenr('$'))
    3              0.000011         if index(tabpagebuflist(tab), buf) >= 0
    3              0.000003             return 1
                                    endif
                                endfor
                            
                                return 0

FUNCTION  <SNR>131_hl_group_exists()
Called 1158 times
Total time:   0.015873
 Self time:   0.015873

count  total (s)   self (s)
 1158              0.004579   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
                              endif
 1158              0.001265   return 1

FUNCTION  <SNR>72_cpath()
Called 5 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    5              0.000009   if exists('+fileignorecase') && &fileignorecase
                                return tolower(a:path)
                              else
    5              0.000004     return a:path
                              endif

FUNCTION  gitgutter#utility#setbufvar()
Called 23 times
Total time:   0.000414
 Self time:   0.000414

count  total (s)   self (s)
   23              0.000119   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
   23              0.000074   let needs_setting = empty(dict)
   23              0.000081   let dict[a:varname] = a:val
   23              0.000031   if needs_setting
    1              0.000003     call setbufvar(a:buffer, 'gitgutter', dict)
    1              0.000001   endif

FUNCTION  <SNR>110_is_excluded_window()
Called 18 times
Total time:   0.001616
 Self time:   0.001616

count  total (s)   self (s)
   18              0.000092   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
   72              0.000180   for matchw in g:airline_exclude_filenames
   54              0.000619     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
   54              0.000068   endfor
                            
   18              0.000054   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
   18              0.000034   return 0

FUNCTION  tagbar#prototypes#normaltag#new()
Called 14 times
Total time:   0.003385
 Self time:   0.000358

count  total (s)   self (s)
   14   0.002851   0.000087     let newobj = tagbar#prototypes#basetag#new(a:name)
                            
   14   0.000133   0.000071     let newobj.isNormalTag = function(s:add_snr('s:isNormalTag'))
   14   0.000118   0.000057     let newobj.strfmt = function(s:add_snr('s:strfmt'))
   14   0.000133   0.000057     let newobj.str = function(s:add_snr('s:str'))
   14   0.000118   0.000054     let newobj.getPrototype = function(s:add_snr('s:getPrototype'))
                            
   14              0.000011     return newobj

FUNCTION  airline#highlighter#exec()
Called 1309 times
Total time:   0.306375
 Self time:   0.091363

count  total (s)   self (s)
 1309              0.002676   if pumvisible()
                                return
                              endif
 1309              0.002459   let colors = a:colors
 1309              0.001915   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
 1309   0.168307   0.007117   let old_hi = airline#highlighter#get_highlight(a:group)
 1309              0.003034   if len(colors) == 4
  608              0.002256     call add(colors, '')
  608              0.000500   endif
 1309              0.001952   if g:airline_gui_mode ==# 'gui'
 1309              0.006878     let new_hi = [colors[0], colors[1], '', '', colors[4]]
 1309              0.001036   else
                                let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
                              endif
 1309   0.039067   0.006867   let colors = s:CheckDefined(colors)
 1309   0.023347   0.007474   if old_hi != new_hi || !s:hl_group_exists(a:group)
  151   0.009236   0.003487     let cmd = printf('hi %s %s %s %s %s %s %s %s', a:group, s:Get(colors, 0, 'guifg='), s:Get(colors, 1, 'guibg='), s:Get(colors, 2, 'ctermfg='), s:Get(colors, 3, 'ctermbg='), s:Get(colors, 4, 'gui='), s:Get(colors, 4, 'cterm='), s:Get(colors, 4, 'term='))
  151              0.002402     exe cmd
  151              0.000459     if has_key(s:hl_groups, a:group)
  151              0.000382       let s:hl_groups[a:group] = colors
  151              0.000106     endif
  151              0.000102   endif

FUNCTION  <SNR>145_add_snr()
Called 7 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    7              0.000010     if !exists("s:snr")
                                    let s:snr = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeget_snr$')
                                endif
    7              0.000008     return s:snr . a:funcname

FUNCTION  <SNR>179_SplitPattern()
Called 5 times
Total time:   0.002019
 Self time:   0.001239

count  total (s)   self (s)
    5              0.000025 	let str = a:str
    5              0.000021 	let s:savestr = str
    5              0.000015 	if s:regexp
                            		let pat = s:regexfilter(str)
                            	el
    5              0.000101 		let lst = split(str, '\zs')
    5              0.000058 		if exists('+ssl') && !&ssl
                            			cal map(lst, 'escape(v:val, ''\'')')
                            		en
   20              0.000091 		for each in ['^', '$', '.']
   15              0.000270 			cal map(lst, 'escape(v:val, each)')
   15              0.000070 		endfo
    5              0.000011 	en
    5              0.000029 	if exists('lst')
    5              0.000019 		let pat = ''
    5              0.000024 		if !empty(lst)
    4   0.000429   0.000074 			if s:byfname() && index(lst, ';') > 0
                            				let fbar = index(lst, ';')
                            				let lst_1 = s:sublist(lst, 0, fbar - 1)
                            				let lst_2 = len(lst) - 1 > fbar ? s:sublist(lst, fbar + 1, -1) : ['']
                            				let pat = s:buildpat(lst_1).';'.s:buildpat(lst_2)
                            			el
    4   0.000495   0.000070 				let pat = s:buildpat(lst)
    4              0.000009 			en
    4              0.000007 		en
    5              0.000008 	en
    5              0.000033 	retu escape(pat, '~')

FUNCTION  <SNR>66__normalise_filetype()
Called 2 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000010     let ft = get(s:_DEFAULT_FILETYPE_MAP, a:ftalias, a:ftalias)
    2              0.000004     let ft = get(g:syntastic_filetype_map, ft, ft)
    2              0.000011     let ft = substitute(ft, '\m-', '_', 'g')
    2              0.000002     return ft

FUNCTION  <SNR>141_getKind()
Called 28 times
Total time:   0.000501
 Self time:   0.000501

count  total (s)   self (s)
   28              0.000241     let idx = self.kinddict[a:kind]
   28              0.000216     return self.kinds[idx]

FUNCTION  <SNR>175_upsert_new_gitgutter_signs()
Called 2 times
Total time:   0.000804
 Self time:   0.000589

count  total (s)   self (s)
    2   0.000032   0.000012   let other_signs         = gitgutter#utility#getbufvar(a:bufnr, 'other_signs')
    2   0.000033   0.000016   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                            
   18              0.000021   for line in a:modified_lines
   16              0.000039     let line_number = line[0]  " <number>
   16              0.000047     if index(other_signs, line_number) == -1  " don't clobber others' signs
   16   0.000272   0.000094       let name = s:highlight_name_for_change(line[1])
   16              0.000056       if !has_key(old_gitgutter_signs, line_number)  " insert
                                    let id = s:next_sign_id()
                                    execute "sign place" id "line=" . line_number "name=" . name "buffer=" . a:bufnr
                                  else  " update if sign has changed
   16              0.000049         let old_sign = old_gitgutter_signs[line_number]
   16              0.000030         if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . a:bufnr
                                    end
   16              0.000012       endif
   16              0.000013     endif
   16              0.000011   endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  426()
Called 3 times
Total time:   0.000176
 Self time:   0.000075

count  total (s)   self (s)
    3              0.000012     let bufnum = get(self.buffers, a:i, -1)
    3              0.000003     if bufnum == -1
                                  return ''
                                endif
    3   0.000124   0.000023     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    3              0.000008     if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
    3              0.000004     return group

FUNCTION  <SNR>138_mark_window()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002     let w:tagbar_mark = 1

FUNCTION  <SNR>72_repo()
Called 452 times
Total time:   0.031923
 Self time:   0.031923

count  total (s)   self (s)
  452              0.008824   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
  452              0.001637   if dir !=# ''
  452              0.003232     if has_key(s:repos, dir)
  452              0.003224       let repo = get(s:repos, dir)
  452              0.001107     else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
  452              0.008054     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  <SNR>117_update_branch()
Called 223 times
Total time:   0.188253
 Self time:   0.033256

count  total (s)   self (s)
  669              0.005041   for vcs in keys(s:vcs_config)
  446   0.165071   0.010074     call {s:vcs_config[vcs].update_branch}()
  446              0.004929     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
    1              0.000002       let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
    1              0.000002       unlet! b:airline_head
    1              0.000000     endif
  446              0.001311   endfor

FUNCTION  <SNR>179_lsCmd()
Called 1 time
Total time:   0.000637
 Self time:   0.000120

count  total (s)   self (s)
    1              0.000009 	let cmd = s:usrcmd
    1              0.000010 	if type(cmd) == 1
                            		retu cmd
                            	elsei type(cmd) == 3 && len(cmd) >= 2 && cmd[:1] != ['', '']
    1   0.000546   0.000029 		if s:findroot(s:dyncwd, cmd[0], 0, 1) == []
                            			retu len(cmd) == 3 ? cmd[2] : ''
                            		en
    1              0.000012 		let s:vcscmd = s:lash == '\'
    1              0.000011 		retu cmd[1]
                            	elsei type(cmd) == 4 && ( has_key(cmd, 'types') || has_key(cmd, 'fallback') )
                            		let fndroot = []
                            		if has_key(cmd, 'types') && cmd['types'] != {}
                            			let [markrs, cmdtypes] = [[], values(cmd['types'])]
                            			for pair in cmdtypes
                            				cal add(markrs, pair[0])
                            			endfo
                            			let fndroot = s:findroot(s:dyncwd, markrs, 0, 1)
                            		en
                            		if fndroot == []
                            			retu has_key(cmd, 'fallback') ? cmd['fallback'] : ''
                            		en
                            		for pair in cmdtypes
                            			if pair[0] == fndroot[0] | brea | en
                            		endfo
                            		let s:vcscmd = s:lash == '\'
                            		retu pair[1]
                            	en

FUNCTION  <SNR>179_formatline()
Called 29 times
Total time:   0.003157
 Self time:   0.001962

count  total (s)   self (s)
   29              0.000094 	let str = a:str
   29   0.001097   0.000220 	let ct = s:curtype()
   29              0.000065 	if ct == 'buf'
                            		let bufnr = s:bufnrfilpath(str)[0]
                            		let parts = s:bufparts(bufnr)
                            		let str = printf('%'.s:bufnr_width.'s', bufnr)
                            		if s:has_conceal
                            			let str .= printf(' %-13s %s%-36s', '<bi>'.parts[0].'</bi>', '<bn>'.parts[1], '{'.parts[2].'}</bn>')
                            			if (!empty(s:bufpath_mod))
                            				let str .= printf('  %s', '<bp>'.parts[3].'</bp>')
                            			en
                            		el
                            			let str .= printf(' %-5s %-30s', parts[0], parts[2])
                            			if (!empty(s:bufpath_mod))
                            				let str .= printf('  %s', parts[3])
                            			en
                            		en
                            	en
   29   0.000636   0.000318 	let cond = ct != 'buf' &&s:ispath && ( s:winw - 4 ) < s:strwidth(str)
   29              0.000180 	retu s:lineprefix.( cond ? s:pathshorten(str) : str )

FUNCTION  airline#extensions#whitespace#check()
Called 223 times
Total time:   0.075105
 Self time:   0.063769

count  total (s)   self (s)
  223              0.002563   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
  223              0.004021   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
                            
  223              0.002058   if !exists('b:airline_whitespace_check')
    1              0.000002     let b:airline_whitespace_check = ''
    1              0.000005     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    1              0.000001     let trailing = 0
    1              0.000003     if index(checks, 'trailing') > -1
    1              0.000001       try
    1              0.000002         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    1              0.000566         let trailing = search(regexp, 'nw')
    1              0.000001       catch
                                    echomsg 'airline#whitespace: error occurred evaluating '. regexp
                                    echomsg v:exception
                                    return ''
                                  endtry
    1              0.000001     endif
                            
    1              0.000002     let mixed = 0
    1              0.000001     let check = 'indent'
    1              0.000009     if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
    1   0.001046   0.000014       let mixed = s:check_mixed_indent()
    1              0.000000     endif
                            
    1              0.000001     let mixed_file = ''
    1              0.000001     let check = 'mixed-indent-file'
    1              0.000007     if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
    1   0.000077   0.000008       let mixed_file = s:check_mixed_indent_file()
    1              0.000000     endif
                            
    1              0.000002     let long = 0
    1              0.000002     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
    1              0.000003     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                  endif
                                endif
    1              0.000000   endif
  223   0.014181   0.003946   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>179_log()
Called 2 times
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)
    2              0.000036 	if exists('g:ctrlp_log') && g:ctrlp_log | if a:m
                            		let cadir = ctrlp#utils#cachedir()
                            		let apd = g:ctrlp_log > 1 ? '>' : ''
                            		sil! exe 'redi! >'.apd cadir.s:lash(cadir).'ctrlp.log'
                            	el
                            		sil! redi END
                            	en | en

FUNCTION  airline#extensions#tabline#formatters#default#format()
Called 29 times
Total time:   0.002971
 Self time:   0.002323

count  total (s)   self (s)
   29              0.000119   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
   29              0.000051   let _ = ''
                            
   29              0.000111   let name = bufname(a:bufnr)
   29              0.000064   if empty(name)
                                let _ .= '[No Name]'
                              else
   29              0.000044     if s:fnamecollapse
   29              0.001088       let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
   29              0.000040     else
                                  let _ .= fnamemodify(name, fmod)
                                endif
   29              0.000173     if a:bufnr != bufnr('%') && s:fnametruncate && strlen(_) > s:fnametruncate
                                  let _ = strpart(_, 0, s:fnametruncate)
                                endif
   29              0.000025   endif
                            
   29   0.000912   0.000264   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  429()
Called 2 times
Total time:   0.000221
 Self time:   0.000073

count  total (s)   self (s)
    2              0.000006     let bufnum = get(self.buffers, a:i, -1)
    2   0.000085   0.000006     let group = self.get_group(a:i)
    2   0.000078   0.000009     let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
    2              0.000005     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1              0.000001       let space = s:spc
    1              0.000001     else
    1              0.000002       let space= (pgroup == group ? s:spc : '')
    1              0.000001     endif
                            
    2              0.000004     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. get(s:number_map, a:i+1, '') . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
    2              0.000008       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif

FUNCTION  <SNR>72_repo_tree()
Called 3 times
Total time:   0.000088
 Self time:   0.000073

count  total (s)   self (s)
    3   0.000029   0.000021   if self.dir() =~# '/\.git$'
    3   0.000020   0.000013     let dir = self.dir()[0:-6]
    3              0.000006     if dir !~# '/'
                                  let dir .= '/'
                                endif
    3              0.000001   else
                                let dir = s:configured_tree(self.git_dir)
                              endif
    3              0.000003   if dir ==# ''
                                call s:throw('no work tree')
                              else
    3              0.000007     return join([dir]+a:000,'/')
                              endif

FUNCTION  <SNR>179_MatchIt()
Called 5 times
Total time:   0.005655
 Self time:   0.005249

count  total (s)   self (s)
    5              0.000037 	let [lines, id] = [[], 0]
    5   0.000391   0.000087 	let pat = s:byfname() ? map(split(a:pat, '^[^;]\+\\\@<!\zs;', 1), 's:martcs.v:val') : s:martcs.a:pat
   91              0.000286 	for item in a:items
   87              0.000334 		let id += 1
   87              0.000171 		try
   87              0.001760 			if (s:matchcrfile || !( s:ispath && item ==# a:exc )) &&call(s:mfunc, [item, pat]) >= 0
   29              0.000132 				cal add(lines, item)
   29              0.000038 			en
   87              0.000199 		cat | brea | endt
   88              0.000583 		if a:limit > 0 && len(lines) >= a:limit | brea | en
   86              0.000169 	endfo
    5   0.000235   0.000133 	let s:mdata = [s:dyncwd, s:itemtype, s:regexp, s:sublist(a:items, id, -1)]
    5              0.000015 	retu lines

FUNCTION  airline#builder#should_change_group()
Called 174 times
Total time:   0.064892
 Self time:   0.005351

count  total (s)   self (s)
  174              0.000561   if a:group1 == a:group2
    7              0.000015     return 0
                              endif
  167   0.032406   0.001318   let color1 = airline#highlighter#get_highlight(a:group1)
  167   0.029688   0.001235   let color2 = airline#highlighter#get_highlight(a:group2)
  167              0.000361   if g:airline_gui_mode ==# 'gui'
  167              0.001126     return color1[1] != color2[1] || color1[0] != color2[0]
                              else
                                return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  <SNR>120_ws_refresh()
Called 2 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    2              0.000040   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    2              0.000009     return
                              endif
                              unlet! b:airline_whitespace_check
                              if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif
                              let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>144_getClosedParentTline()
Called 2 times
Total time:   0.000078
 Self time:   0.000069

count  total (s)   self (s)
    2              0.000004     let tagline  = self.tline
                            
                                " Find the first closed parent, starting from the top of the hierarchy.
    2              0.000003     let parents   = []
    2              0.000004     let curparent = self.parent
    4              0.000008     while !empty(curparent)
    2              0.000005         call add(parents, curparent)
    2              0.000004         let curparent = curparent.parent
    2              0.000002     endwhile
    4              0.000007     for parent in reverse(parents)
    2   0.000017   0.000008         if parent.isFolded()
                                        let tagline = parent.tline
                                        break
                                    endif
    2              0.000000     endfor
                            
    2              0.000002     return tagline

FUNCTION  <SNR>159_UpdateMatches()
Called 10 times
Total time:   0.003216
 Self time:   0.003216

count  total (s)   self (s)
   10              0.003195   exec s:python_command "ycm_state.UpdateMatches()"

FUNCTION  <SNR>47_strip_trailing_new_line()
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000012   return substitute(a:line, '\n$', '', '')

FUNCTION  <SNR>159_SetCompleteFunc()
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000010   let &completefunc = 'youcompleteme#CompleteFunc'

FUNCTION  ctrlp#nosy()
Called 6 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
    6              0.000086 	retu !( has('syntax') && exists('g:syntax_on') )

FUNCTION  298()
Called 6 times
Total time:   0.000081
 Self time:   0.000027

count  total (s)   self (s)
    6   0.000074   0.000020     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  <SNR>138_RenderContent()
Called 1 time
Total time:   0.033079
 Self time:   0.000310

count  total (s)   self (s)
    1   0.000009   0.000002     call tagbar#debug#log('RenderContent called')
    1              0.000002     let s:new_window = 0
                            
    1              0.000002     if a:0 == 1
    1              0.000001         let fileinfo = a:1
    1              0.000001     else
                                    let fileinfo = tagbar#state#get_current_file(0)
                                endif
                            
    1              0.000001     if empty(fileinfo)
                                    call tagbar#debug#log('Empty fileinfo, returning')
                                    return
                                endif
                            
    1   0.000029   0.000022     let tagbarwinnr = bufwinnr(s:TagbarBufName())
                            
    1              0.000002     if &filetype == 'tagbar'
                                    let in_tagbar = 1
                                else
    1              0.000001         let in_tagbar = 0
    1              0.000002         let prevwinnr = winnr()
                            
                                    " Get the previous window number, so that we can reproduce
                                    " the window entering history later. Do not run autocmd on
                                    " this command, make sure nothing is interfering.
                                    " let pprevwinnr = winnr('#') " Messes up windows for some reason
    1   0.030546   0.000006         call s:goto_win('p', 1)
    1              0.000004         let pprevwinnr = winnr()
    1   0.000073   0.000009         call s:goto_win(tagbarwinnr, 1)
    1              0.000001     endif
                            
    1   0.000068   0.000013     if !empty(tagbar#state#get_current_file(0)) && fileinfo.fpath ==# tagbar#state#get_current_file(0).fpath
                                    " We're redisplaying the same file, so save the view
                                    call tagbar#debug#log('Redisplaying file [' . fileinfo.fpath . ']')
                                    let saveline = line('.')
                                    let savecol  = col('.')
                                    let topline  = line('w0')
                                endif
                            
    1              0.000003     let lazyredraw_save = &lazyredraw
    1              0.000005     set lazyredraw
    1              0.000002     let eventignore_save = &eventignore
    1              0.000004     set eventignore=all
                            
    1              0.000004     setlocal modifiable
                            
    1              0.000056     silent %delete _
                            
    1   0.000124   0.000015     call s:PrintHelp()
                            
    1              0.000005     let typeinfo = fileinfo.typeinfo
                            
    1   0.000017   0.000013     if !empty(fileinfo.getTags())
                                    " Print tags
    1   0.001903   0.000010         call s:PrintKinds(typeinfo, fileinfo)
    1              0.000001     else
                                    call tagbar#debug#log('No tags found, skipping printing.')
                                    if g:tagbar_compact && s:short_help
                                        silent 0put ='\" No tags found.'
                                    else
                                        silent  put ='\" No tags found.'
                                    endif
                                endif
                            
                                " Delete empty lines at the end of the buffer
    2              0.000006     for linenr in range(line('$'), 1, -1)
    2              0.000015         if getline(linenr) =~ '^$'
    1              0.000020             execute 'silent ' . linenr . 'delete _'
    1              0.000001         else
    1              0.000000             break
                                    endif
    1              0.000001     endfor
                            
    1              0.000003     setlocal nomodifiable
                            
    1   0.000040   0.000008     if !empty(tagbar#state#get_current_file(0)) && fileinfo.fpath ==# tagbar#state#get_current_file(0).fpath
                                    let scrolloff_save = &scrolloff
                                    set scrolloff=0
                            
                                    call cursor(topline, 1)
                                    normal! zt
                                    call cursor(saveline, savecol)
                            
                                    let &scrolloff = scrolloff_save
                                else
                                    " Make sure as much of the Tagbar content as possible is shown in the
                                    " window by jumping to the top after drawing
    1              0.000003         execute 1
    1              0.000003         call winline()
                            
                                    " Invalidate highlight cache from old file
    1              0.000003         let s:last_highlight_tline = 0
    1              0.000001     endif
                            
    1              0.000003     let &lazyredraw  = lazyredraw_save
    1              0.000003     let &eventignore = eventignore_save
                            
    1              0.000001     if !in_tagbar
    1   0.000036   0.000004         call s:goto_win(pprevwinnr, 1)
    1   0.000031   0.000005         call s:goto_win(prevwinnr, 1)
    1              0.000000     endif

FUNCTION  <SNR>55_patterns_for()
Called 1 time
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000002   if a:type ==# ''
                                return []
                              endif
    1              0.000003   if !exists('s:patterns')
                                redir => capture
                                silent autocmd BufRead
                                redir END
                                let patterns = { 'c': ['*.c'], 'html': ['*.html'], 'sh': ['*.sh'], 'vim': ['vimrc', '.vimrc', '_vimrc'], }
                                let setfpattern = '\s\+\%(setf\%[iletype]\s\+\|set\%[local]\s\+\%(ft\|filetype\)=\|call SetFileTypeSH(["'']\%(ba\|k\)\=\%(sh\)\@=\)'
                                for line in split(capture, "\n")
                                  let match = matchlist(line, '^\s*\(\S\+\)\='.setfpattern.'\(\w\+\)')
                                  if !empty(match)
                                    call extend(patterns, {match[2]: []}, 'keep')
                                    call extend(patterns[match[2]], [match[1] ==# '' ? last : match[1]])
                                  endif
                                  let last = matchstr(line, '\S.*')
                                endfor
                                let s:patterns = patterns
                              endif
    1              0.000004   return copy(get(s:patterns, a:type, []))

FUNCTION  <SNR>61__is_same_index()
Called 1 time
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000005     if a:old_line >= 0 && a:line == a:old_line && a:idx >= 0
                                    if len(a:messages) <= 1
                                        return 1
                                    endif
                            
                                    if a:messages[a:idx].scol <= a:column || a:idx == 0
                                        if a:idx == len(a:messages) - 1 || a:column < a:messages[a:idx + 1].scol
                                            return 1
                                        else
                                            return 0
                                        endif
                                    else
                                        return 0
                                    endif
                                else
    1              0.000003         return 0
                                endif

FUNCTION  <SNR>179_compfnlen()
Called 53 times
Total time:   0.001569
 Self time:   0.001569

count  total (s)   self (s)
                            	" By filename length
   53              0.000761 	let len1 = strlen(split(a:1, s:lash)[-1])
   53              0.000516 	let len2 = strlen(split(a:2, s:lash)[-1])
   53              0.000207 	retu len1 == len2 ? 0 : len1 > len2 ? 1 : -1

FUNCTION  ctrlp#getcline()
Called 1 time
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    1              0.000053 	let [linenr, offset] = [line('.'), ( s:offset > 0 ? s:offset : 0 )]
    1              0.000028 	retu !empty(s:lines) && !( offset && linenr <= offset ) ? s:lines[linenr - 1 - offset] : ''

FUNCTION  <SNR>123_update_tabline()
Called 1 time
Total time:   0.000211
 Self time:   0.000147

count  total (s)   self (s)
    1              0.000006   if get(g:, 'airline#extensions#tabline#disable_refresh', 0)
                                return
                              endif
    1              0.000010   let match = expand('<afile>')
    1              0.000006   let ignore_bufadd_pat = get(g:, 'airline#extensions#tabline#ignore_bufadd_pat', '\c\vgundo|undotree|vimfiler|tagbar|nerd_tree')
    1              0.000003   if pumvisible()
                                return
                              elseif !get(g:, 'airline#extensions#tabline#enabled', 0)
                                return
                              " return, if buffer matches ignore pattern or is directory (netrw)
                              elseif empty(match) || match(match, ignore_bufadd_pat) > -1 || isdirectory(expand("<afile>"))
                                return
                              endif
    1   0.000131   0.000067   doautocmd User BufMRUChange
                              " sometimes, the tabline is not correctly updated see #1580
                              " so force redraw here
    1              0.000005   let &tabline = &tabline

FUNCTION  ctrlp#mrufiles#cachefile()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000004 	if !exists('s:cadir') || !exists('s:cafile')
                            		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
                            		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
                            	en
    1              0.000001 	retu s:cafile

FUNCTION  <SNR>72_buffer_commit()
Called 2 times
Total time:   0.000108
 Self time:   0.000030

count  total (s)   self (s)
    2   0.000107   0.000029   return matchstr(self.spec(),'^fugitive://.\{-\}//\zs\w*')

FUNCTION  <SNR>54_CreateDelimMapFromCms()
Called 3 times
Total time:   0.000193
 Self time:   0.000193

count  total (s)   self (s)
    3              0.000027     if &ft == '' && exists('g:NERDDefaultDelims')
                                    let delims = g:NERDDefaultDelims
                                    for i in ['left', 'leftAlt', 'right', 'rightAlt']
                                        if !has_key(delims, i)
                                            let delims[i] = ''
                                        endif
                                    endfor
                                    return delims
                                endif
    3              0.000125     return { 'left': substitute(&commentstring, '\([^ \t]*\)\s*%s.*', '\1', ''), 'right': substitute(&commentstring, '.*%s\s*\(.*\)', '\1', 'g'), 'nested': 0, 'leftAlt': '', 'rightAlt': '', 'nestedAlt': 0}

FUNCTION  gitgutter#process_buffer()
Called 7 times
Total time:   0.017811
 Self time:   0.000794

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
    7   0.002374   0.000125   if gitgutter#utility#is_active(a:bufnr)
    5   0.000383   0.000144     if a:force || s:has_fresh_changes(a:bufnr)
                            
    2              0.000003       let diff = ''
    2              0.000002       try
    2   0.014625   0.000096         let diff = gitgutter#diff#run_diff(a:bufnr, 0)
    2              0.000005       catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
    2              0.000006       if diff != 'async'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
    2              0.000001     endif
    5              0.000009   endif

FUNCTION  gitgutter#utility#repo_path()
Called 11 times
Total time:   0.000285
 Self time:   0.000104

count  total (s)   self (s)
   11   0.000199   0.000059   let p = gitgutter#utility#getbufvar(a:bufnr, 'path')
   11   0.000072   0.000031   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>179_nosplit()
Called 1 time
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
    1              0.000073 	retu !empty(s:nosplit) && match([bufname('%'), &l:ft, &l:bt], s:nosplit) >= 0

FUNCTION  <SNR>72_buffer_repo()
Called 6 times
Total time:   0.000152
 Self time:   0.000032

count  total (s)   self (s)
    6   0.000151   0.000031   return s:repo(self.getvar('git_dir'))

FUNCTION  <SNR>150_get_separator_change_with_end()
Called 26 times
Total time:   0.005582
 Self time:   0.000704

count  total (s)   self (s)
   26              0.000055   let sep_change = 0
   26              0.000065   if !empty(a:new_end_group) " Separator between title and the end
   14   0.004156   0.000116     let sep_change += airline#builder#should_change_group(a:new_group, a:new_end_group) ? a:sep_size : a:alt_sep_size
   14              0.000012   endif
   26              0.000058   if !empty(a:old_group) " Separator between the title and the one adjacent
    2   0.000458   0.000011     let sep_change += airline#builder#should_change_group(a:new_group, a:old_group) ? a:sep_size : a:alt_sep_size
    2              0.000005     if !empty(a:old_end_group) " Remove mis-predicted separator
    2   0.000402   0.000011       let sep_change -= airline#builder#should_change_group(a:old_group, a:old_end_group) ? a:sep_size : a:alt_sep_size
    2              0.000001     endif
    2              0.000001   endif
   26              0.000037   return sep_change

FUNCTION  <SNR>179_dohighlight()
Called 5 times
Total time:   0.000165
 Self time:   0.000086

count  total (s)   self (s)
    5   0.000160   0.000081 	retu s:mathi[0] && exists('*clearmatches') && !ctrlp#nosy()

FUNCTION  xolox#easytags#filetypes#canonicalize()
Called 2 times
Total time:   0.000670
 Self time:   0.000299

count  total (s)   self (s)
                              " Select a canonical, supported Vim file type given a value of &filetype.
    2   0.000486   0.000115   call s:discover_supported_filetypes()
                              " Split the possibly combined Vim file type into individual file types.
    2              0.000073   for filetype in split(tolower(a:vim_filetype_value), '\.')
                                " Canonicalize the Vim file type.
    2              0.000039     let filetype = get(s:canonical_filetypes, filetype, filetype)
    2              0.000036     if index(s:supported_filetypes, filetype) >= 0
    2              0.000012       return filetype
                                endif
                              endfor
                              return ''

FUNCTION  SyntaxCheckers_python_python_GetLocList()
Called 1 time
Total time:   0.049028
 Self time:   0.000047

count  total (s)   self (s)
    1              0.000004     let compiler = s:base_path . (g:syntastic_python_python_use_codec ? 'codec.py' : 'compile.py')
    1   0.000031   0.000005     call self.log('using compiler script', compiler)
    1   0.000429   0.000010     let makeprg = self.makeprgBuild({ 'exe': [self.getExec(), compiler] })
                            
    1              0.000001     let errorformat = '%E%f:%l:%c: %m'
                            
    1   0.000012   0.000004     let env = syntastic#util#isRunningWindows() ? {} : { 'TERM': 'dumb' }
                            
    1   0.048545   0.000017     return SyntasticMake({ 'makeprg': makeprg, 'errorformat': errorformat, 'env': env, 'returns': [0] })

FUNCTION  <SNR>179_Reset()
Called 1 time
Total time:   0.003085
 Self time:   0.000210

count  total (s)   self (s)
    1              0.000014 	let opts = has_key(a:args, 'opts') ? [a:args['opts']] : []
    1   0.002506   0.000032 	cal call('s:opts', opts)
    1   0.000102   0.000037 	cal s:autocmds()
    1   0.000361   0.000060 	cal ctrlp#utils#opts()
    1   0.000099   0.000064 	cal s:execextvar('opts')

FUNCTION  <SNR>146_compare_by_kind()
Called 26 times
Total time:   0.000478
 Self time:   0.000478

count  total (s)   self (s)
   26              0.000034     let typeinfo = s:compare_typeinfo
                            
   26              0.000055     if typeinfo.kinddict[a:tag1.fields.kind] <# typeinfo.kinddict[a:tag2.fields.kind]
    1              0.000001         return -1
                                elseif typeinfo.kinddict[a:tag1.fields.kind] ># typeinfo.kinddict[a:tag2.fields.kind]
    6              0.000002         return 1
                                else
                                    " Ignore '~' prefix for C++ destructors to sort them directly under
                                    " the constructors
   19              0.000028         if a:tag1.name[0] ==# '~'
                                        let name1 = a:tag1.name[1:]
                                    else
   19              0.000020             let name1 = a:tag1.name
   19              0.000011         endif
   19              0.000023         if a:tag2.name[0] ==# '~'
                                        let name2 = a:tag2.name[1:]
                                    else
   19              0.000043             let name2 = a:tag2.name
   19              0.000009         endif
                            
   19              0.000024         let ci = g:tagbar_case_insensitive
   19              0.000033         if (((!ci) && (name1 <=# name2)) || (ci && (name1 <=? name2)))
    9              0.000006             return -1
                                    else
   10              0.000007             return 1
                                    endif
                                endif

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
Called 29 times
Total time:   0.000648
 Self time:   0.000648

count  total (s)   self (s)
   29              0.000129   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
   29              0.000206   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
   29              0.000141   if getbufvar(a:bufnr, '&modified') == 1
   23              0.000054     let _ .= s:buf_modified_symbol
   23              0.000018   endif
   29              0.000043   return _

FUNCTION  gitgutter#utility#windows()
Called 3 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    3              0.000027   return has('win64') || has('win32') || has('win16')

FUNCTION  airline#parts#spell()
Called 223 times
Total time:   0.017171
 Self time:   0.017171

count  total (s)   self (s)
  223              0.007848   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
  223              0.001307   if g:airline_detect_spell && &spell
                                if winwidth(0) >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth(0) >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
  223              0.000631   return ''

FUNCTION  <SNR>159_StartMessagePoll()
Called 2 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000004   if s:pollers.receive_messages.id < 0
    2              0.000016     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
    2              0.000001   endif

FUNCTION  <SNR>138_add_tag_recursive()
Called 24 times
Total time:   0.003326
 Self time:   0.002234

count  total (s)   self (s)
                                " If the pathlist is empty we are at the correct scope for the current tag
   24              0.000039     if empty(a:pathlist)
                                    " If a child tag got processed before a parent tag then there will
                                    " be a pseudotag here as a placeholder. Copy the children over and
                                    " then replace the pseudotag with the real one.
   14              0.000020         let pseudotags = []
   14              0.000018         if empty(a:parent)
    4   0.000046   0.000034             let name_siblings = a:taginfo.fileinfo.getTagsByName(a:taginfo.name)
    4              0.000001         else
   10   0.000081   0.000052             let name_siblings = a:parent.getChildrenByName(a:taginfo.name)
   10              0.000007         endif
                            
                                    " Consider a tag as replaceable if the current tag is considered to
                                    " have more appropriate information
   14              0.000024         for tag in name_siblings
                                        if (tag.fields.kind ==# '?' || tag.fields.kind ==# a:taginfo.fields.kind) && (tag.isPseudoTag() || (!a:taginfo.isSplitTag() && tag.isSplitTag()))
                                            call add(pseudotags, tag)
                                        endif
                                    endfor
                            
   14              0.000021         if len(pseudotags) == 1
                                        let pseudotag = pseudotags[0]
                                        for child in pseudotag.getChildren()
                                            call a:taginfo.addChild(child)
                                            let child.parent = a:taginfo
                                        endfor
                                        if empty(a:parent)
                                            call a:taginfo.fileinfo.removeTag(pseudotag)
                                        else
                                            call a:parent.removeChild(pseudotag)
                                        endif
                                    elseif len(pseudotags) > 1
                                        echoerr 'Tagbar: Found duplicate pseudotag; this should never happen!' 'Please contact the script maintainer with an example.' 'Pseudotag name:' pseudotag.name
                                    endif
                            
                                    " If this is a tag that got created due to splitting up a tag name,
                                    " don't replace existing tags of the same kind.
   14   0.000060   0.000044         if a:taginfo.isSplitTag()
                                        for tag in name_siblings
                                            if tag.fields.kind ==# a:taginfo.fields.kind
                                                return
                                            endif
                                        endfor
                                    endif
                            
   14              0.000019         if empty(a:parent)
    4   0.000058   0.000015             call a:taginfo.fileinfo.addTag(a:taginfo)
    4              0.000004         else
   10   0.000144   0.000033             call a:parent.addChild(a:taginfo)
   10              0.000021             let a:taginfo.parent = a:parent
   10              0.000006         endif
   14              0.000010         return
                                endif
                            
                            
                                " There is still at least one more scope between the current one and the
                                " one of the current tag, so we have to either find or create the
                                " intermediate tags
                            
   10              0.000016     let grandparent = a:parent
   10              0.000025     let parentname = remove(a:pathlist, 0)
                            
   10              0.000016     if empty(grandparent)
   10   0.000100   0.000044         let name_siblings = a:taginfo.fileinfo.getTagsByName(parentname)
   10              0.000005     else
                                    let name_siblings = grandparent.getChildrenByName(parentname)
                                endif
   10              0.000013     if empty(a:pathlist)
                                    " If the current tag is a direct child of the parent we're looking for
                                    " then we can also filter the parents based on the scope information
   10              0.000014         let parents = []
   20              0.000026         for tag in name_siblings
   10              0.000043             if tag.fields.kind ==# '?' || get(a:taginfo.typeinfo.kind2scope, tag.fields.kind, "") == a:taginfo.scope
   10              0.000023                 call add(parents, tag)
   10              0.000005             endif
   10              0.000020         endfor
   10              0.000007     else
                                    let parents = name_siblings
                                endif
                            
   10              0.000012     if empty(parents)
                                    " No parents found, so either the parent is a pseudotag or it hasn't
                                    " been processed yet. Create a pseudotag as a placeholder; if the
                                    " actual parent gets processed later it will get replaced.
                                    if empty(a:pathlist)
                                        let pseudokind = a:taginfo.typeinfo.scope2kind[a:taginfo.scope]
                                    else
                                        let pseudokind = '?'
                                    endif
                                    let parent = s:create_pseudotag(parentname, grandparent, pseudokind, a:taginfo.typeinfo, a:taginfo.fileinfo)
                                    if empty(grandparent)
                                        call a:taginfo.fileinfo.addTag(parent)
                                    else
                                        call grandparent.addChild(parent)
                                    endif
                                elseif len(parents) == 1
   10              0.000023         let parent = parents[0]
   10              0.000006     else
                                    " If there are multiple possible parents (c.f. issue #139, or tags
                                    " with the same name but a different kind) then we will pick the one
                                    " that is closest above the current tag as a heuristic.
                            
                                    " Start at line 0 so that pseudotags get included
                                    let minline = 0
                                    for candidate in parents
                                        " If the line number of the current tag is 0 then we have no way
                                        " of determining the best candidate by comparing line numbers.
                                        " Just use the first one we have.
                                        if a:taginfo.fields.line == 0
                                            let parent = candidate
                                            break
                                        endif
                            
                                        if candidate.fields.line <= a:taginfo.fields.line && candidate.fields.line >= minline
                                            let parent = candidate
                                            let minline = candidate.fields.line
                                        endif
                                    endfor
                            
                                    if !exists('parent')
                                        " If we still haven't found a parent it must be below the current
                                        " tag, so find the closest parent below the tag. This can happen
                                        " for example in Go.
                                        let maxline = line('$')
                                        for candidate in parents
                                            if candidate.fields.line >= a:taginfo.fields.line && candidate.fields.line <= maxline
                                                let parent = candidate
                                                let maxline = candidate.fields.line
                                            endif
                                        endfor
                                    endif
                                endif
                            
                                " If the parent is a pseudotag it may have gotten created as an in-between
                                " tag without proper information about its kind because all if its
                                " children are also pseudotags, so it may be incorrect. If the current tag
                                " is a direct child of a pseudotag then we can derive the correct kind, so
                                " replace it if necessary.
   10   0.000053   0.000039     if parent.isPseudoTag() && empty(a:pathlist)
                                    let parentkind = a:taginfo.typeinfo.scope2kind[a:taginfo.scope]
                                    if parent.fields.kind ==# '?' || parentkind !=# parent.fields.kind
                                        let parent.fields.kind = parentkind
                                        call parent.initFoldState(s:known_files)
                                    endif
                                endif
                            
   10              0.000043     call s:add_tag_recursive(parent, a:taginfo, a:pathlist)

FUNCTION  400()
Called 78 times
Total time:   0.001382
 Self time:   0.001068

count  total (s)   self (s)
   78   0.001000   0.000686     if !tagbar#is_paused() || a:force_current
   78              0.000286         return self._current
                                else
                                    return self._paused
                                endif

FUNCTION  401()
Called 7 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    7              0.000042     let self._current = a:fileinfo

FUNCTION  403()
Called 11 times
Total time:   0.000432
 Self time:   0.000351

count  total (s)   self (s)
   11              0.000057   let self._first_title = a:first " lowest index
   11              0.000038   let self._last_title = a:last " highest index
   11              0.000036   let self._left_title = a:current " next index to add on the left
   11              0.000052   let self._right_title = a:current + 1 " next index to add on the right
   11   0.000185   0.000104   let self._left_position = self.get_position() " left end of titles
   11              0.000041   let self._right_position = self._left_position " right end of the titles

FUNCTION  404()
Called 13 times
Total time:   0.008508
 Self time:   0.000742

count  total (s)   self (s)
   13   0.001886   0.000127   let title = self.get_title(a:index)
   13   0.006028   0.000107   let title_size = s:tabline_evaluated_length(title) + a:sep_size
   13              0.000032   if a:force || self._remaining_space >= title_size
   13              0.000026     let pos = a:pos
   13              0.000035     if has_key(self, "get_pretitle")
                                  call self.insert_raw(self.get_pretitle(a:index), pos)
                                  let self._right_position += 1
                                  let pos += 1
                                endif
                            
   13   0.000178   0.000092     call self.insert_section(a:group, title, pos)
   13              0.000030     let self._right_position += 1
   13              0.000018     let pos += 1
                            
   13              0.000032     if has_key(self, "get_posttitle")
                                  call self.insert_raw(self.get_posttitle(a:index), pos)
                                  let self._right_position += 1
                                  let pos += 1
                                endif
                            
   13              0.000029     let self._remaining_space -= title_size
   13              0.000017     return 1
                              endif
                              return 0

FUNCTION  405()
Called 11 times
Total time:   0.121875
 Self time:   0.003110

count  total (s)   self (s)
   11              0.000087   if has_key(self, '_left_position') && self._first_title <= self._last_title
   11   0.048272   0.000220     let self._remaining_space = &columns - s:tabline_evaluated_length(self._build())
                            
   11              0.000052     let center_active = get(g:, 'airline#extensions#tabline#center_active', 0)
                            
   11   0.000676   0.000073     let sep_size = s:tabline_evaluated_length(self._context.left_sep)
   11   0.000625   0.000071     let alt_sep_size = s:tabline_evaluated_length(self._context.left_alt_sep)
                            
   11   0.000266   0.000083     let outer_left_group = airline#builder#get_prev_group(self._sections, self._left_position)
   11   0.000479   0.000098     let outer_right_group = airline#builder#get_next_group(self._sections, self._right_position)
                            
   11              0.000061     let overflow_marker = get(g:, 'airline#extensions#tabline#overflow_marker', g:airline_symbols.ellipsis)
   11   0.000681   0.000072     let overflow_marker_size = s:tabline_evaluated_length(overflow_marker)
                                " Allow space for the markers before we begin filling in titles.
   11              0.000030     if self._left_title > self._first_title
    1   0.000044   0.000010       let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_left_group, sep_size, alt_sep_size)
    1              0.000001     endif
   11              0.000020     if self._left_title < self._last_title
    1   0.000261   0.000009       let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_right_group, sep_size, alt_sep_size)
    1              0.000000     endif
                            
                                " Add the current title
   11   0.000820   0.000138     let group = self.get_group(self._left_title)
   11              0.000022     if self._left_title == self._first_title
   10   0.000475   0.000096       let sep_change = s:get_separator_change(group, "", outer_left_group, sep_size, alt_sep_size)
   10              0.000008     else
    1   0.000293   0.000007       let sep_change = s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
    1              0.000001     endif
   11              0.000017     if self._left_title == self._last_title
   10   0.003629   0.000083       let sep_change += s:get_separator_change(group, "", outer_right_group, sep_size, alt_sep_size)
   10              0.000007     else
    1   0.000234   0.000005       let sep_change += s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
    1              0.000001     endif
   11              0.000022     let left_group = group
   11              0.000024     let right_group = group
   11   0.007670   0.000102     let self._left_title -= self.try_insert_title(self._left_title, group, self._left_position, sep_change, 1)
                            
   11              0.000033     if get(g:, 'airline#extensions#tabline#current_first', 0)
                                  " always have current title first
                                  let self._left_position += 1
                                endif
                            
   11              0.000029     if !center_active && self._right_title <= self._last_title
                                  " Add the title to the right
    1   0.000038   0.000004       let group = self.get_group(self._right_title)
    1              0.000001       if self._right_title == self._last_title
    1   0.000625   0.000008         let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
    1              0.000001       else
                                    let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                  endif
    1              0.000001       let right_group = group
    1   0.000437   0.000006       let self._right_title += self.try_insert_title(self._right_title, group, self._right_position, sep_change, 1)
    1              0.000001     endif
                            
   12              0.000026     while self._remaining_space > 0
   12              0.000021       let done = 0
   12              0.000022       if self._left_title >= self._first_title
                                    " Insert next title to the left
    1   0.000044   0.000004         let group = self.get_group(self._left_title)
    1              0.000001         if self._left_title == self._first_title
    1   0.000490   0.000009           let sep_change = s:get_separator_change_with_end(group, left_group, outer_left_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
    1              0.000001         else
                                      let sep_change = s:get_separator_change(group, left_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
    1              0.000002         let left_group = group
    1   0.000516   0.000007         let done = self.try_insert_title(self._left_title, group, self._left_position, sep_change, 0)
    1              0.000002         let self._left_title -= done
    1              0.000000       endif
                                  " If center_active is set, this |if| operates as an independent |if|,
                                  " otherwise as an |elif|.
   12              0.000032       if self._right_title <= self._last_title && (center_active || !done)
                                    " Insert next title to the right
                                    let group = self.get_group(self._right_title)
                                    if self._right_title == self._last_title
                                      let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let right_group = group
                                    let done = self.try_insert_title(self._right_title, group, self._right_position, sep_change, 0)
                                    let self._right_title += done
                                  endif
   12              0.000014       if !done
   11              0.000012         break
                                  endif
    1              0.000001     endwhile
                            
   11              0.000017     if self._left_title >= self._first_title
                                  if get(g:, 'airline#extensions#tabline#current_first', 0)
                                    let self._left_position -= 1
                                  endif
                                  call self.insert_section(self.overflow_group, overflow_marker, self._left_position)
                                  let self._right_position += 1
                                endif
                            
   11              0.000019     if self._right_title <= self._last_title
                                  call self.insert_section(self.overflow_group, overflow_marker, self._right_position)
                                endif
   11              0.000013   endif
                            
   11   0.053364   0.000069   return self._build()

FUNCTION  <SNR>179_PrtAdd()
Called 5 times
Total time:   0.259979
 Self time:   0.000235

count  total (s)   self (s)
    5              0.000037 	unl! s:hstgot
    5              0.000043 	let s:act_add = 1
    5              0.000059 	let s:prompt[0] .= a:char
    5   0.259816   0.000072 	cal s:BuildPrompt(1)
    5              0.000011 	unl s:act_add

FUNCTION  <SNR>179_isterminal()
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000028 	retu getbufvar(a:buf, "&bt") == "terminal"

FUNCTION  <SNR>72_repo_head()
Called 223 times
Total time:   0.083885
 Self time:   0.022631

count  total (s)   self (s)
  223   0.054594   0.004860     let head = s:repo().head_ref()
                            
  223              0.005940     if head =~# '^ref: '
  223   0.016063   0.004543       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
  223              0.000951     elseif head =~# '^\x\{40\}$'
                                  " truncate hash to a:1 characters if we're in detached head mode
                                  let len = a:0 ? a:1 : 0
                                  let branch = len ? head[0:len-1] : ''
                                else
                                  return ''
                                endif
                            
  223              0.000894     return branch

FUNCTION  272()
Called 1 time
Total time:   0.000028
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000003     let b:syntastic_private_balloons = {}
    1              0.000003     if has('balloon_eval')
    1   0.000011   0.000004         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'balloons: reset')
    1              0.000002         unlet! b:syntastic_private_balloons
    1              0.000009         set noballooneval
    1              0.000000     endif

FUNCTION  <SNR>138_GetFileWinnr()
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000002     let filewinnr = 0
    1              0.000002     let prevwinnr = winnr("#")
                            
    1              0.000006     if winbufnr(prevwinnr) == a:fileinfo.bufnr && !getwinvar(prevwinnr, '&previewwindow')
    1              0.000002         let filewinnr = prevwinnr
    1              0.000000     else
                                    " Search for the first real window that has the correct buffer loaded
                                    " in it. Similar to bufwinnr() but skips the previewwindow.
                                    for i in range(1, winnr('$'))
                                        call s:goto_win(i, 1)
                                        if bufnr('%') == a:fileinfo.bufnr && !&previewwindow
                                            let filewinnr = winnr()
                                            break
                                        endif
                                    endfor
                            
                                    call s:goto_tagbar(1)
                                endif
                            
    1              0.000001     return filewinnr

FUNCTION  ctrlp#progress()
Called 1 time
Total time:   0.030972
 Self time:   0.030896

count  total (s)   self (s)
    1              0.000044 	if has('macunix') || has('mac') | sl 1m | en
    1              0.000011 	let txt = a:0 ? '(press ctrl-c to abort)' : ''
    1              0.000010 	if s:status != {}
    1              0.000025 		let argms = has_key(s:status, 'arg_type') && s:status['arg_type'] == 'dict' ? [{ 'str': a:enum }] : [a:enum]
    1   0.000195   0.000119 		let &l:stl = call(s:status['prog'], argms, s:status)
    1              0.000003 	el
                            		let &l:stl = '%#CtrlPStats# '.a:enum.' %* '.txt.'%=%<%#CtrlPMode2# %{getcwd()} %*'
                            	en
    1              0.030668 	redraws

FUNCTION  <SNR>72_sub()
Called 228 times
Total time:   0.011565
 Self time:   0.011565

count  total (s)   self (s)
  228              0.011277   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  tagbar#debug#enabled()
Called 3 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    3              0.000005     return s:debug_enabled

FUNCTION  <SNR>138_IsValidFile()
Called 9 times
Total time:   0.001358
 Self time:   0.001259

count  total (s)   self (s)
    9   0.000181   0.000086     call tagbar#debug#log('Checking if file is valid [' . a:fname . ']')
                            
    9              0.000034     if a:fname == '' || a:ftype == ''
    1   0.000008   0.000004         call tagbar#debug#log('Empty filename or type')
    1              0.000001         return 0
                                endif
                            
    8              0.000158     if !filereadable(a:fname) && getbufvar(a:fname, 'netrw_tmpfile') == ''
                                    call tagbar#debug#log('File not readable')
                                    return 0
                                endif
                            
    8              0.000184     if getbufvar(a:fname, 'tagbar_ignore') == 1
                                    call tagbar#debug#log('File is marked as ignored')
                                    return 0
                                endif
                            
    8              0.000242     let winnr = bufwinnr(a:fname)
    8              0.000056     if winnr != -1 && getwinvar(winnr, '&diff')
                                    call tagbar#debug#log('Window is in diff mode')
                                    return 0
                                endif
                            
    8              0.000013     if &previewwindow
                                    call tagbar#debug#log('In preview window')
                                    return 0
                                endif
                            
    8              0.000049     if !has_key(s:known_types, a:ftype)
                                    if exists('g:tagbar_type_' . a:ftype)
                                        " Filetype definition must have been specified in an 'ftplugin'
                                        " file, so load it now
                                        call s:LoadUserTypeDefs(a:ftype)
                                    else
                                        call tagbar#debug#log('Unsupported filetype: ' . a:ftype)
                                        return 0
                                    endif
                                endif
                            
    8              0.000017     return 1

FUNCTION  <SNR>159_OnBufferUnload()
Called 1 time
Total time:   0.003243
 Self time:   0.003162

count  total (s)   self (s)
                              " Expanding <abuf> returns the unloaded buffer number as a string but we want
                              " it as a true number for the getbufvar function.
    1              0.000009   let buffer_number = str2nr( expand( '<abuf>' ) )
    1   0.000090   0.000009   if !s:AllowedToCompleteInBuffer( buffer_number )
                                return
                              endif
                            
    1              0.003137   exec s:python_command "ycm_state.OnBufferUnload( " . buffer_number . " )"

FUNCTION  <SNR>45_chop()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000008 	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
    1              0.000001 	retu a:mrufs

FUNCTION  339()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000009     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))

FUNCTION  <SNR>159_PollFileParseResponse()
Called 4 times
Total time:   0.002266
 Self time:   0.001499

count  total (s)   self (s)
    4   0.000649   0.000058   if !s:Pyeval( "ycm_state.FileParseRequestReady()" )
                                let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
                                return
                              endif
                            
    4              0.001295   exec s:python_command "ycm_state.HandleFileParseRequest()"
    4   0.000222   0.000046   if s:Pyeval( "ycm_state.ShouldResendFileParseRequest()" )
                                call s:OnFileReadyToParse( 1 )
                              endif

FUNCTION  <SNR>143_isNormalTag()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001     return 1

FUNCTION  <SNR>138_JumpToTag()
Called 1 time
Total time:   0.109612
 Self time:   0.000194

count  total (s)   self (s)
    1   0.000157   0.000022     let taginfo = s:GetTagInfo(line('.'), 1)
                            
    1              0.000002     let autoclose = w:autoclose
                            
    1   0.000008   0.000006     if empty(taginfo) || !taginfo.isNormalTag()
                                    return
                                endif
                            
    1              0.000002     let tagbarwinnr = winnr()
                            
    1   0.092552   0.000017     call s:GotoFileWindow(taginfo.fileinfo)
                            
                                " Mark current position so it can be jumped back to
    1              0.000003     mark '
                            
                                " Jump to the line where the tag is defined. Don't use the search pattern
                                " since it doesn't take the scope into account and thus can fail if tags
                                " with the same name are defined in different scopes (e.g. classes)
    1   0.000015   0.000008     call tagbar#debug#log('Jumping to line ' . taginfo.fields.line)
    1              0.000004     execute taginfo.fields.line
                            
                                " If the file has been changed but not saved, the tag may not be on the
                                " saved line anymore, so search for it in the vicinity of the saved line
    1              0.000003     if taginfo.pattern != ''
    1   0.000009   0.000005         call tagbar#debug#log('Searching for pattern "' . taginfo.pattern . '"')
    1              0.000019         if match(getline('.'), taginfo.pattern) == -1
                                        let interval = 1
                                        let forward  = 1
                                        while search(taginfo.pattern, 'W' . forward ? '' : 'b') == 0
                                            if !forward
                                                if interval > line('$')
                                                    break
                                                else
                                                    let interval = interval * 2
                                                endif
                                            endif
                                            let forward = !forward
                                        endwhile
                                    endif
    1              0.000001     endif
                            
                                " If the tag is on a different line after unsaved changes update the tag
                                " and file infos/objects
    1              0.000002     let curline = line('.')
    1              0.000001     if taginfo.fields.line != curline
                                    let taginfo.fields.line = curline
                                    let taginfo.fileinfo.fline[curline] = taginfo
                                endif
                            
                                " Center the tag in the window and jump to the correct column if
                                " available, otherwise try to find it in the line
    1              0.000033     normal! z.
    1              0.000002     if taginfo.fields.column > 0
                                    call cursor(taginfo.fields.line, taginfo.fields.column)
                                else
    1              0.000002         call cursor(taginfo.fields.line, 1)
    1              0.000008         call search(taginfo.name, 'c', line('.'))
    1              0.000000     endif
                            
    1              0.000002     normal! zv
                            
    1              0.000002     if a:stay_in_tagbar
                                    call s:HighlightTag(0)
                                    call s:goto_win(tagbarwinnr)
                                    redraw
                                elseif g:tagbar_autoclose || autoclose
                                    " Also closes preview window
                                    call s:CloseWindow()
                                else
                                    " Close the preview window if it was opened by us
    1              0.000002         if s:pwin_by_tagbar
                                        pclose
                                    endif
    1   0.016743   0.000008         call s:HighlightTag(0)
    1              0.000001     endif

FUNCTION  <SNR>131_Get()
Called 1057 times
Total time:   0.005749
 Self time:   0.005749

count  total (s)   self (s)
 1057              0.002445   let res=get(a:dict, a:key, '')
 1057              0.001065   if res is ''
  577              0.000423     return ''
                              else
  480              0.000745     return a:prefix. res
                              endif

FUNCTION  410()
Called 3 times
Total time:   0.000109
 Self time:   0.000054

count  total (s)   self (s)
    3              0.000007     let bufnum = get(self.buffers, a:i, -1)
    3              0.000003     if bufnum == -1
                                  return ''
                                endif
    3   0.000076   0.000021     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    3              0.000006     if bufnum == bufnr('%')
    3              0.000008       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
    3              0.000002     endif
    3              0.000001     return group

FUNCTION  411()
Called 1 time
Total time:   0.000094
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000003     let bufnum = get(self.buffers, a:i, -1)
    1   0.000037   0.000004     let group = self.get_group(a:i)
    1   0.000034   0.000004     let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
    1              0.000002     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1              0.000001       let space = s:spc
    1              0.000000     else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
    1              0.000002     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. get(s:number_map, a:i+1, '') . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
    1              0.000003       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif

FUNCTION  <SNR>159_OnInsertLeave()
Called 1 time
Total time:   0.005149
 Self time:   0.002166

count  total (s)   self (s)
    1   0.000072   0.000007   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    1              0.000004   call timer_stop( s:pollers.completion.id )
    1              0.000002   let s:force_semantic = 0
    1              0.000002   let s:completion = s:default_completion
                            
    1   0.002903   0.000012   call s:OnFileReadyToParse()
    1              0.002088   exec s:python_command "ycm_state.OnInsertLeave()"
    1              0.000012   if g:ycm_autoclose_preview_window_after_completion || g:ycm_autoclose_preview_window_after_insertion
    1   0.000060   0.000033     call s:ClosePreviewWindowIfNeeded()
    1              0.000001   endif

FUNCTION  414()
Called 3 times
Total time:   0.000110
 Self time:   0.000049

count  total (s)   self (s)
    3              0.000007     let bufnum = get(self.buffers, a:i, -1)
    3              0.000003     if bufnum == -1
                                  return ''
                                endif
    3   0.000075   0.000014     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    3              0.000006     if bufnum == bufnr('%')
    3              0.000010       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
    3              0.000001     endif
    3              0.000000     return group

FUNCTION  415()
Called 1 time
Total time:   0.000136
 Self time:   0.000071

count  total (s)   self (s)
    1              0.000003     let bufnum = get(self.buffers, a:i, -1)
    1   0.000039   0.000004     let group = self.get_group(a:i)
    1   0.000034   0.000004     let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
    1              0.000034     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1              0.000003       let space = s:spc
    1              0.000000     else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
    1              0.000004     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. get(s:number_map, a:i+1, '') . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
    1              0.000004       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif

FUNCTION  416()
Called 3 times
Total time:   0.000195
 Self time:   0.000084

count  total (s)   self (s)
    3              0.000014     let bufnum = get(self.buffers, a:i, -1)
    3              0.000004     if bufnum == -1
                                  return ''
                                endif
    3   0.000139   0.000028     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    3              0.000010     if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
    3              0.000005     return group

FUNCTION  417()
Called 1 time
Total time:   0.000162
 Self time:   0.000053

count  total (s)   self (s)
    1              0.000005     let bufnum = get(self.buffers, a:i, -1)
    1   0.000063   0.000006     let group = self.get_group(a:i)
    1   0.000059   0.000007     let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
    1              0.000004     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1              0.000003       let space = s:spc
    1              0.000001     else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
    1              0.000004     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. get(s:number_map, a:i+1, '') . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
    1              0.000006       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif

FUNCTION  418()
Called 3 times
Total time:   0.000103
 Self time:   0.000040

count  total (s)   self (s)
    3              0.000007     let bufnum = get(self.buffers, a:i, -1)
    3              0.000003     if bufnum == -1
                                  return ''
                                endif
    3   0.000075   0.000012     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    3              0.000005     if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
    3              0.000002     return group

FUNCTION  syntastic#util#screenWidth()
Called 13 times
Total time:   0.000168
 Self time:   0.000168

count  total (s)   self (s)
   13              0.000045     let chunks = split(a:str, "\t", 1)
   13              0.000039     let width = s:_width(chunks[-1])
   13              0.000023     for c in chunks[:-2]
                                    let cwidth = s:_width(c)
                                    let width += cwidth + a:tabstop - cwidth % a:tabstop
                                endfor
   13              0.000011     return width

FUNCTION  <SNR>138_ProcessTag()
Called 14 times
Total time:   0.007797
 Self time:   0.001492

count  total (s)   self (s)
   14              0.000018     if a:is_split
                                    let taginfo = tagbar#prototypes#splittag#new(a:name)
                                else
   14   0.003467   0.000082         let taginfo = tagbar#prototypes#normaltag#new(a:name)
   14              0.000013     endif
                            
   14              0.000022     let taginfo.file    = a:filename
   14              0.000022     let taginfo.pattern = a:pattern
   14              0.000059     call extend(taginfo.fields, a:fields)
                            
                                " Needed for jsctags
   14              0.000026     if has_key(taginfo.fields, 'lineno')
                                    let taginfo.fields.line = str2nr(taginfo.fields.lineno)
                                endif
                                " Do some sanity checking in case ctags reports invalid line numbers
   14              0.000021     if taginfo.fields.line < 0
                                    let taginfo.fields.line = 0
                                endif
                            
   14              0.000023     if !has_key(taginfo.fields, 'kind')
                                    call tagbar#debug#log( "Warning: No 'kind' field found for tag " . basic_info[0] . "!")
                                    if index(s:warnings.type, a:typeinfo.ftype) == -1
                                        call s:warning("No 'kind' field found for tag " . basic_info[0] . "!" . " Please read the last section of ':help tagbar-extend'.")
                                        call add(s:warnings.type, a:typeinfo.ftype)
                                    endif
                                    return
                                endif
                            
   14              0.000019     let taginfo.fileinfo = a:fileinfo
   14              0.000016     let taginfo.typeinfo = a:typeinfo
                            
   14              0.000047     let a:fileinfo.fline[taginfo.fields.line] = taginfo
                            
                                " If this filetype doesn't have any scope information then we can stop
                                " here after adding the tag to the list
   14              0.000025     if !has_key(a:typeinfo, 'scope2kind')
                                    call a:fileinfo.addTag(taginfo)
                                    return
                                endif
                            
                            
                                " Make some information easier accessible
   32              0.000063     for scope in keys(a:typeinfo.scope2kind)
   28              0.000047         if has_key(taginfo.fields, scope)
   10              0.000016             let taginfo.scope = scope
   10              0.000018             let taginfo.path  = taginfo.fields[scope]
                            
   10              0.000027             let taginfo.fullpath = taginfo.path . a:typeinfo.sro . taginfo.name
   10              0.000007             break
                                    endif
   18              0.000013     endfor
   14              0.000079     let pathlist = split(taginfo.path, '\V' . escape(a:typeinfo.sro, '\'))
   14              0.000029     let taginfo.depth = len(pathlist)
                            
                                " Needed for folding
   14              0.000011     try
   14   0.000387   0.000063         call taginfo.initFoldState(s:known_files)
   14              0.000016     catch /^Vim(\a\+):E716:/ " 'Key not present in Dictionary'
                                    " The tag has a 'kind' that doesn't exist in the type definition
                                    call tagbar#debug#log('Warning: Unknown tag kind: ' . taginfo.fields.kind)
                                    if index(s:warnings.type, a:typeinfo.ftype) == -1
                                        call s:warning('Unknown tag kind encountered: ' . '"' . taginfo.fields.kind . '".' . ' Your ctags and Tagbar configurations are out of sync!' . ' Please read '':help tagbar-extend''.')
                                        call add(s:warnings.type, a:typeinfo.ftype)
                                    endif
                                    return
                                endtry
                            
   14   0.002668   0.000072     call s:add_tag_recursive({}, taginfo, pathlist)

FUNCTION  <SNR>72_buffer_path()
Called 1 time
Total time:   0.000472
 Self time:   0.000088

count  total (s)   self (s)
    1   0.000042   0.000019   let rev = matchstr(self.spec(),'^fugitive://.\{-\}//\zs.*')
    1              0.000001   if rev != ''
                                let rev = s:sub(rev,'\w*','')
                              elseif s:cpath(self.spec()[0 : len(self.repo().dir())]) ==# s:cpath(self.repo().dir() . '/')
                                let rev = '/.git'.self.spec()[strlen(self.repo().dir()) : -1]
                              elseif !self.repo().bare() && s:cpath(self.spec()[0 : len(self.repo().tree())]) ==# s:cpath(self.repo().tree() . '/')
    1   0.000084   0.000007     let rev = self.spec()[strlen(self.repo().tree()) : -1]
    1              0.000001   endif
    1   0.000021   0.000005   return s:sub(s:sub(rev,'.\zs/$',''),'^/',a:0 ? a:1 : '')

FUNCTION  airline#parts#crypt()
Called 223 times
Total time:   0.003872
 Self time:   0.003872

count  total (s)   self (s)
  223              0.003581   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  <SNR>179_writecache()
Called 1 time
Total time:   0.010864
 Self time:   0.000042

count  total (s)   self (s)
    1   0.000041   0.000022 	if ( g:ctrlp_newcache || !filereadable(a:cafile) ) && !s:nocache()
    1   0.010813   0.000010 		cal ctrlp#utils#writecache(g:ctrlp_allfiles)
    1              0.000009 		let g:ctrlp_newcache = 0
    1              0.000001 	en

FUNCTION  airline#extensions#keymap#status()
Called 223 times
Total time:   0.008010
 Self time:   0.008010

count  total (s)   self (s)
  223              0.003999   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
  223              0.003493     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  <SNR>91_Highlight_Matching_Pair()
Called 206 times
Total time:   0.066860
 Self time:   0.066860

count  total (s)   self (s)
                              " Remove any previous match.
  206              0.004207   if exists('w:paren_hl_on') && w:paren_hl_on
    2              0.000022     silent! call matchdelete(3)
    2              0.000013     let w:paren_hl_on = 0
    2              0.000007   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  206              0.002970   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  206              0.002058   let c_lnum = line('.')
  206              0.001791   let c_col = col('.')
  206              0.000760   let before = 0
                            
  206              0.001795   let text = getline(c_lnum)
  206              0.011573   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  206              0.001413   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
  206              0.003031     let [c_before, c] = matches[1:2]
  206              0.000518   endif
  206              0.009353   let plist = split(&matchpairs, '.\zs[:,]')
  206              0.001932   let i = index(plist, c)
  206              0.000791   if i < 0
                                " not found, in Insert mode try character before the cursor
  204              0.002121     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
  204              0.000607     if i < 0
                                  " not found, nothing to do
  204              0.000747       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
    2              0.000009   if i % 2 == 0
    1              0.000005     let s_flags = 'nW'
    1              0.000009     let c2 = plist[i + 1]
    1              0.000002   else
    1              0.000005     let s_flags = 'nbW'
    1              0.000005     let c2 = c
    1              0.000011     let c = plist[i - 1]
    1              0.000003   endif
    2              0.000011   if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    2              0.000008   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
    2              0.000028   let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
    2              0.002452   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
    2              0.000023   let stoplinebottom = line('w$')
    2              0.000016   let stoplinetop = line('w0')
    2              0.000009   if i % 2 == 0
    1              0.000007     let stopline = stoplinebottom
    1              0.000002   else
    1              0.000008     let stopline = stoplinetop
    1              0.000003   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    2              0.000025   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
    2              0.000031     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    2              0.000004   endif
    2              0.000008   try
    2              0.003039     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
    2              0.000030   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
    2              0.000027   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
    2              0.000019   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    2              0.000018     if exists('*matchaddpos')
    2              0.000210       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
    2              0.000007     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
    2              0.000019     let w:paren_hl_on = 1
    2              0.000004   endif

FUNCTION  421()
Called 1 time
Total time:   0.000165
 Self time:   0.000054

count  total (s)   self (s)
    1              0.000005     let bufnum = get(self.buffers, a:i, -1)
    1   0.000065   0.000006     let group = self.get_group(a:i)
    1   0.000059   0.000007     let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
    1              0.000004     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1              0.000002       let space = s:spc
    1              0.000001     else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
    1              0.000004     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. get(s:number_map, a:i+1, '') . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
    1              0.000006       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif

FUNCTION  422()
Called 3 times
Total time:   0.000151
 Self time:   0.000063

count  total (s)   self (s)
    3              0.000010     let bufnum = get(self.buffers, a:i, -1)
    3              0.000005     if bufnum == -1
                                  return ''
                                endif
    3   0.000105   0.000017     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    3              0.000008     if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
    3              0.000005     return group

FUNCTION  <SNR>159_ClosePreviewWindowIfNeeded()
Called 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000009   let current_buffer_name = bufname('')
                            
                              " We don't want to try to close the preview window in special buffers like
                              " "[Command Line]"; if we do, Vim goes bonkers. Special buffers always start
                              " with '['.
    1              0.000007   if current_buffer_name[ 0 ] == '['
                                return
                              endif
                            
                              " This command does the actual closing of the preview window. If no preview
                              " window is shown, nothing happens.
    1              0.000001   pclose

FUNCTION  SyntaxCheckers_python_flake8_GetLocList()
Called 1 time
Total time:   0.444439
 Self time:   0.001058

count  total (s)   self (s)
    1   0.000345   0.000004     let makeprg = self.makeprgBuild({})
                            
    1              0.000003     let errorformat = '%E%f:%l: could not compile,%-Z%p^,' . '%A%f:%l:%c: %m,' . '%A%f:%l: %m,' . '%-G%.%#'
                            
    1   0.000017   0.000007     let env = syntastic#util#isRunningWindows() ? {} : { 'TERM': 'dumb' }
                            
    1   0.443043   0.000013     let loclist = SyntasticMake({ 'makeprg': makeprg, 'errorformat': errorformat, 'env': env })
                            
   26              0.000022     for e in loclist
                                    " flake8 codes: https://gitlab.com/pycqa/flake8/issues/339
                            
   25              0.000355         let parts = matchlist(e['text'], '\v\C^([A-Z]+)(\d+):?\s+(.*)')
   25              0.000041         if len(parts) >= 4
   25              0.000057             let e['type'] = parts[1][0]
   25              0.000102             let e['text'] = printf('%s [%s%s]', parts[3], parts[1], parts[2])
                            
   25              0.000075             if e['type'] ==? 'E' && parts[2] !~# '\m^9'
   23              0.000034                 let e['subtype'] = 'Style'
   23              0.000018             endif
   25              0.000007         else
                                        let e['type'] = 'E'
                                    endif
                            
   25              0.000075         if e['type'] =~? '\m^[CHIMNRTW]'
                                        let e['subtype'] = 'Style'
                                    endif
                            
   25              0.000081         let e['type'] = e['type'] =~? '\m^[EFHC]' ? 'E' : 'W'
   25              0.000016     endfor
                            
    1              0.000003     return loclist

FUNCTION  427()
Called 1 time
Total time:   0.000164
 Self time:   0.000055

count  total (s)   self (s)
    1              0.000004     let bufnum = get(self.buffers, a:i, -1)
    1   0.000063   0.000006     let group = self.get_group(a:i)
    1   0.000059   0.000007     let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
    1              0.000004     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1              0.000003       let space = s:spc
    1              0.000001     else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
    1              0.000003     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. get(s:number_map, a:i+1, '') . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
    1              0.000006       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif

FUNCTION  428()
Called 6 times
Total time:   0.000237
 Self time:   0.000101

count  total (s)   self (s)
    6              0.000016     let bufnum = get(self.buffers, a:i, -1)
    6              0.000008     if bufnum == -1
                                  return ''
                                endif
    6   0.000163   0.000027     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    6              0.000012     if bufnum == bufnr('%')
    3              0.000011       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
    3              0.000002     endif
    6              0.000006     return group

FUNCTION  <SNR>68__os_name()
Called 4 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    4              0.000006     return g:_SYNTASTIC_UNAME

FUNCTION  <SNR>179_PrtBS()
Called 1 time
Total time:   0.033802
 Self time:   0.000194

count  total (s)   self (s)
    1              0.000025 	if !s:focus | retu | en
    1              0.000029 	if empty(s:prompt[0]) && s:brfprt != 0
                            		cal s:PrtExit()
                            		retu
                            	en
    1              0.000007 	unl! s:hstgot
    1              0.000082 	let [s:prompt[0], s:matches] = [substitute(s:prompt[0], '.$', '', ''), 1]
    1   0.033633   0.000025 	cal s:BuildPrompt(1)

FUNCTION  airline#extensions#branch#head()
Called 223 times
Total time:   0.264275
 Self time:   0.015603

count  total (s)   self (s)
  223              0.002131   if !exists('b:buffer_vcs_config')
    1   0.000041   0.000020     call s:init_buffer()
    1              0.000001   endif
                            
  223   0.191155   0.002902   call s:update_branch()
  223   0.063612   0.003417   call s:update_untracked()
                            
  223              0.002906   if exists('b:airline_head') && !empty(b:airline_head)
  222              0.000953     return b:airline_head
                              endif
                            
    1              0.000008   let b:airline_head = ''
    1              0.000008   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
    1              0.000001   let heads = []
    3              0.000005   for vcs in vcs_priority
    2              0.000009     if !empty(b:buffer_vcs_config[vcs].branch)
    1              0.000005       let heads += [vcs]
    1              0.000001     endif
    2              0.000001   endfor
                            
    2              0.000001   for vcs in heads
    1              0.000002     if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
    1              0.000003     if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
    1   0.000243   0.000057     let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
    1              0.000003     let b:airline_head .= b:buffer_vcs_config[vcs].untracked
    1              0.000001   endfor
                            
    1              0.000002   if empty(heads)
                                if s:has_vcscommand()
                                  call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
    1              0.000001   if empty(heads)
                                if s:has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
                              endif
                            
    1              0.000005   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  '' : '.')
                                endif
                              endif
                            
    1              0.000004   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
    1   0.000025   0.000008   let b:airline_head = airline#util#shorten(b:airline_head, 120, minwidth)
    1              0.000004   return b:airline_head

FUNCTION  syntastic#log#debugDump()
Called 1 time
Total time:   0.000011
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000010   0.000007     if !s:_isDebugEnabled(a:level)
    1              0.000001         return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:_SYNTASTIC_DEFAULTS)) )

FUNCTION  <SNR>179_ispathitem()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000010 	retu s:itemtype < len(s:coretypes) || s:getextvar('type') == 'path'

FUNCTION  <SNR>150_evaluate_tabline()
Called 57 times
Total time:   0.008254
 Self time:   0.003661

count  total (s)   self (s)
   57              0.000135   let tabline = a:tabline
   57   0.005476   0.000883   let tabline = substitute(tabline, '%{\([^}]\+\)}', '\=eval(submatch(1))', 'g')
   57              0.000825   let tabline = substitute(tabline, '%#[^#]\+#', '', 'g')
   57              0.000436   let tabline = substitute(tabline, '%(\([^)]\+\)%)', '\1', 'g')
   57              0.000291   let tabline = substitute(tabline, '%\d\+[TX]', '', 'g')
   57              0.000231   let tabline = substitute(tabline, '%=', '', 'g')
   57              0.000238   let tabline = substitute(tabline, '%\d*\*', '', 'g')
   57              0.000269   if has('tablineat')
                                let tabline = substitute(tabline, '%@[^@]\+@', '', 'g')
                              endif
   57              0.000082   return tabline

FUNCTION  gitgutter#diff#run_diff()
Called 2 times
Total time:   0.014529
 Self time:   0.011123

count  total (s)   self (s)
    4   0.000150   0.000050   while gitgutter#utility#repo_path(a:bufnr, 0) == -1
    2   0.010746   0.010623     sleep 5m
    2              0.000007   endwhile
                            
    2   0.000044   0.000010   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
                              endif
                            
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    2              0.000003   let cmd = '('
                            
                              " Append buffer number to avoid race conditions between writing and reading
                              " the files when asynchronously processing multiple buffers.
                              "
                              " Without the buffer number, index_file would have a race in the shell
                              " between the second process writing it (with git-show) and the first
                              " reading it (with git-diff).
    2              0.000010   let index_file = s:temp_index.'.'.a:bufnr
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    2              0.000006   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
    2   0.000098   0.000020   let extension = gitgutter#utility#extension(a:bufnr)
    2              0.000019   if !empty(extension)
    2              0.000005     let index_file .= '.'.extension
    2              0.000004     let buff_file .= '.'.extension
    2              0.000002   endif
                            
                              " Write file from index to temporary file.
    2   0.000108   0.000029   let index_name = g:gitgutter_diff_base.':'.gitgutter#utility#repo_path(a:bufnr, 1)
    2              0.000008   let cmd .= g:gitgutter_git_executable.' --no-pager show '.index_name.' > '.index_file.' && '
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    2   0.000379   0.000027   call s:write_buffer(a:bufnr, buff_file)
                            
                              " Call git-diff with the temporary files.
    2              0.000008   let cmd .= g:gitgutter_git_executable.' --no-pager'
    2              0.000002   if s:c_flag
    2              0.000004     let cmd .= ' -c "diff.autorefreshindex=0"'
    2              0.000003     let cmd .= ' -c "diff.noprefix=false"'
    2              0.000002     let cmd .= ' -c "core.safecrlf=false"'
    2              0.000001   endif
    2              0.000010   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.index_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
    2              0.000006   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
    2   0.000085   0.000020     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    2              0.000002   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    2              0.000005   let cmd .= ' || exit 0'
                            
    2              0.000004   let cmd .= ')'
                            
    2   0.000223   0.000012   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
    2   0.000017   0.000011   if g:gitgutter_async && gitgutter#async#available()
    2   0.002486   0.000128     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
    2              0.000012     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  WebDevIconsGetFileFormatSymbol()
Called 226 times
Total time:   0.024238
 Self time:   0.020822

count  total (s)   self (s)
  226              0.001269   let fileformat = ''
  226              0.000759   let bomb = ''
                            
  226              0.001477   if (&bomb && g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol !=? '')
                                let bomb = g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol . ' '
                              endif
                            
  226              0.001216   if &fileformat ==? 'dos'
                                let fileformat = ''
                              elseif &fileformat ==? 'unix'
  226   0.006925   0.003509     if s:isDarwin()
                                  let fileformat = ''
                                else
  226              0.000949       let fileformat = ''
  226              0.000448     endif
  226              0.000632   elseif &fileformat ==? 'mac'
                                let fileformat = ''
                              endif
                            
                              " Temporary (hopefully) fix for glyph issues in gvim (proper fix is with the
                              " actual font patcher)
  226              0.001477   let artifactFix = g:DevIconsArtifactFixChar
                            
  226              0.001648   return bomb . fileformat . artifactFix

FUNCTION  <SNR>179_PrtExit()
Called 1 time
Total time:   0.015856
 Self time:   0.000490

count  total (s)   self (s)
    1              0.000014 	let bw = bufwinnr('%')
    1              0.000310 	exe bufwinnr(s:bufnr).'winc w'
    1              0.000022 	if bufnr('%') == s:bufnr && bufname('%') == 'ControlP'
    1   0.015460   0.000094 		noa cal s:Close()
    1              0.000034 		noa winc p
    1              0.000003 	els
                            		exe bw.'winc w'
                            	en

FUNCTION  airline#extensions#syntastic#get()
Called 446 times
Total time:   0.158061
 Self time:   0.035361

count  total (s)   self (s)
  446              0.005181   let _backup = get(g:, 'syntastic_stl_format', '')
  446              0.003138   let is_err = (a:type  is# 'error')
  446              0.001345   if is_err
  223              0.002394     let g:syntastic_stl_format = get(g:, 'airline#extensions#syntastic#stl_format_err', '%E{[%e(#%fe)]}')
  223              0.000465   else
  223              0.002525     let g:syntastic_stl_format = get(g:, 'airline#extensions#syntastic#stl_format_warn', '%W{[%w(#%fw)]}')
  223              0.000435   endif
  446   0.127797   0.005097   let cnt = SyntasticStatuslineFlag()
  446              0.002507   if !empty(_backup)
  446              0.002361     let g:syntastic_stl_format = _backup
  446              0.000890   endif
  446              0.001956   if empty(cnt)
  444              0.001219     return ''
                              else
    2              0.000006     return (is_err ? s:error_symbol : s:warning_symbol).cnt
                              endif

FUNCTION  222()
Called 2 times
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
    2              0.000031     if exists("t:NERDTreeBufName")
                                    return bufwinnr(t:NERDTreeBufName)
                                endif
                            
    2              0.000009     return -1

FUNCTION  223()
Called 2 times
Total time:   0.000120
 Self time:   0.000046

count  total (s)   self (s)
    2   0.000118   0.000044     return s:NERDTree.GetWinNum() != -1

FUNCTION  <SNR>45_mergelists()
Called 1 time
Total time:   0.000439
 Self time:   0.000316

count  total (s)   self (s)
    1   0.000127   0.000013 	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
    1              0.000256 	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
    1              0.000035 	let mrufs = s:mrufs + diskmrufs
    1   0.000021   0.000012 	retu s:chop(mrufs)

FUNCTION  <SNR>179_gethistdata()
Called 1 time
Total time:   0.000579
 Self time:   0.000073

count  total (s)   self (s)
    1   0.000577   0.000071 	retu ctrlp#utils#readfile(s:gethistloc()[1])

FUNCTION  <SNR>179_mixedsort()
Called 53 times
Total time:   0.045874
 Self time:   0.008264

count  total (s)   self (s)
   53   0.002439   0.000375 	let ct = s:curtype()
   53              0.000157 	if ct == 'buf'
                            		let pat = '[\/]\?\[\d\+\*No Name\]$'
                            		if a:1 =~# pat && a:2 =~# pat | retu 0
                            		elsei a:1 =~# pat | retu 1
                            		elsei a:2 =~# pat | retu -1 | en
                            	en
   53   0.019582   0.001071 	let [cln, cml] = [ctrlp#complen(a:1, a:2), s:compmatlen(a:1, a:2)]
   53              0.000122 	if s:ispath
   53              0.000122 		let ms = []
   53              0.000163 		if s:res_count < 21
   53   0.002153   0.000584 			let ms += [s:compfnlen(a:1, a:2)]
   53   0.002295   0.001115 			if ct !~ '^\(buf\|mru\)$' | let ms += [s:comptime(a:1, a:2)] | en
   53   0.013660   0.000712 			if !s:itemtype | let ms += [s:comparent(a:1, a:2)] | en
   53              0.000061 		en
   53              0.000509 		if ct =~ '^\(buf\|mru\)$'
                            			let ms += [s:compmref(a:1, a:2)]
                            			let cln = cml ? cln : 0
                            		en
   53              0.000242 		let ms += [cml, 0, 0, 0]
   53   0.002140   0.000802 		let mp = call('s:multipliers', ms[:3])
   53              0.000685 		retu cln + ms[0] * mp[0] + ms[1] * mp[1] + ms[2] * mp[2] + ms[3] * mp[3]
                            	en
                            	retu cln + cml * 2

FUNCTION  <SNR>179_shortest()
Called 106 times
Total time:   0.001194
 Self time:   0.001194

count  total (s)   self (s)
  106              0.001139 	retu min(map(values(a:lens), 'v:val[0]'))

FUNCTION  GitGutterGetHunkSummary()
Called 222 times
Total time:   0.016854
 Self time:   0.003636

count  total (s)   self (s)
  222   0.016580   0.003362   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  431()
Called 2 times
Total time:   0.000198
 Self time:   0.000065

count  total (s)   self (s)
    2              0.000005     let bufnum = get(self.buffers, a:i, -1)
    2   0.000076   0.000007     let group = self.get_group(a:i)
    2   0.000071   0.000007     let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
    2              0.000004     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1              0.000002       let space = s:spc
    1              0.000000     else
    1              0.000003       let space= (pgroup == group ? s:spc : '')
    1              0.000000     endif
                            
    2              0.000004     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. get(s:number_map, a:i+1, '') . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
    2              0.000009       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif

FUNCTION  airline#parts#mode()
Called 223 times
Total time:   0.017481
 Self time:   0.005856

count  total (s)   self (s)
  223   0.017134   0.005509   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>131_CheckDefined()
Called 1309 times
Total time:   0.032200
 Self time:   0.032200

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
 1309              0.004893   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
 1309              0.004688   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
                              endif
                            
 1309              0.003521   for val in a:colors
 1309              0.003890     if !empty(val) && val !=# 'NONE'
 1309              0.001965       return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>151_ExcludeOther()
Called 7 times
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
    7              0.000108   if (getbufvar(a:nr, 'current_syntax') == 'qf') ||  (a:exclude_preview && getbufvar(a:nr, '&bufhidden') == 'wipe'  && getbufvar(a:nr, '&buftype') == 'nofile')
    1              0.000003     return 1 | endif

FUNCTION  airline#extensions#tabline#buflist#invalidate()
Called 8 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
    8              0.000062   unlet! s:current_buffer_list

FUNCTION  <SNR>143_strfmt()
Called 11 times
Total time:   0.000435
 Self time:   0.000189

count  total (s)   self (s)
   11              0.000017     let typeinfo = self.typeinfo
                            
   11              0.000025     let suffix = get(self.fields, 'signature', '')
   11              0.000016     if has_key(self.fields, 'type')
                                    let suffix .= ' : ' . self.fields.type
                                elseif has_key(get(typeinfo, 'kind2scope', {}), self.fields.kind)
    8              0.000020         let suffix .= ' : ' . typeinfo.kind2scope[self.fields.kind]
    8              0.000003     endif
                            
   11   0.000294   0.000048     return self._getPrefix() . self.name . suffix

FUNCTION  gitgutter#hunk#increment_lines_removed()
Called 5 times
Total time:   0.000249
 Self time:   0.000076

count  total (s)   self (s)
    5   0.000121   0.000028   let summary = gitgutter#hunk#summary(a:bufnr)
    5              0.000015   let summary[2] += a:count
    5   0.000112   0.000032   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>136_add_section()
Called 99 times
Total time:   0.010978
 Self time:   0.004341

count  total (s)   self (s)
   99              0.000731     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   99   0.001514   0.000763     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
    4              0.000006       return
                                endif
   95              0.000159     if condition
                                  call a:builder.add_raw('%(')
                                endif
   95   0.007213   0.001327     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   95              0.000163     if condition
                                  call a:builder.add_raw('%)')
                                endif

FUNCTION  <SNR>126_map_keys()
Called 14 times
Total time:   0.004151
 Self time:   0.004151

count  total (s)   self (s)
   14              0.000089   if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
   14              0.000731     noremap <silent> <Plug>AirlineSelectTab1 :call <SID>select_tab(0)<CR>
   14              0.000380     noremap <silent> <Plug>AirlineSelectTab2 :call <SID>select_tab(1)<CR>
   14              0.000312     noremap <silent> <Plug>AirlineSelectTab3 :call <SID>select_tab(2)<CR>
   14              0.000292     noremap <silent> <Plug>AirlineSelectTab4 :call <SID>select_tab(3)<CR>
   14              0.000301     noremap <silent> <Plug>AirlineSelectTab5 :call <SID>select_tab(4)<CR>
   14              0.000295     noremap <silent> <Plug>AirlineSelectTab6 :call <SID>select_tab(5)<CR>
   14              0.000271     noremap <silent> <Plug>AirlineSelectTab7 :call <SID>select_tab(6)<CR>
   14              0.000278     noremap <silent> <Plug>AirlineSelectTab8 :call <SID>select_tab(7)<CR>
   14              0.000288     noremap <silent> <Plug>AirlineSelectTab9 :call <SID>select_tab(8)<CR>
   14              0.000432     noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
   14              0.000386     noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
   14              0.000028   endif

FUNCTION  airline#util#strchars()
Called 57 times
Total time:   0.000374
 Self time:   0.000374

count  total (s)   self (s)
   57              0.000178   if exists('*strchars')
   57              0.000159     return strchars(a:str)
                              else
                                return strlen(substitute(a:str, '.', 'a', 'g'))
                              endif

FUNCTION  gitgutter#async#execute()
Called 3 times
Total time:   0.003381
 Self time:   0.003241

count  total (s)   self (s)
    3   0.000145   0.000022   call gitgutter#debug#log('[async] '.a:cmd)
                            
    3              0.000013   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    3   0.000032   0.000015   let command = s:build_command(a:cmd)
                            
    3              0.000008   if has('nvim')
                                call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
    3              0.003092     call job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
    3              0.000011   endif

FUNCTION  <SNR>92_LocalBrowse()
Called 5 times
Total time:   0.000423
 Self time:   0.000423

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                              
    5              0.000022   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
    5              0.000037   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                            "   call Decho("(s:LocalBrowse) COMBAK#23: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                            "   call Decho("(s:LocalBrowse) COMBAK#24: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                            "    call Decho("(s:LocalBrowse) COMBAK#25: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
    5              0.000005   endif
                            "  call Decho("(s:LocalBrowse) COMBAK#26: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  gitgutter#diff#handler()
Called 2 times
Total time:   0.005514
 Self time:   0.000237

count  total (s)   self (s)
    2   0.000095   0.000015   call gitgutter#debug#log(a:diff)
                            
    2   0.000685   0.000051   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    2   0.001799   0.000037   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    2              0.000006   let signs_count = len(modified_lines)
    2              0.000005   if signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
                              else
    2              0.000005     if g:gitgutter_signs || g:gitgutter_highlight_lines
    2   0.002796   0.000040       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    2              0.000002     endif
    2              0.000002   endif
                            
    2   0.000071   0.000026   call s:save_last_seen_change(a:bufnr)
    2              0.000015   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
                              endif

FUNCTION  <SNR>138_GotoFileWindow()
Called 1 time
Total time:   0.092535
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000003     let noauto = a:0 > 0 ? a:1 : 0
                            
    1   0.000035   0.000006     let filewinnr = s:GetFileWinnr(a:fileinfo)
                            
                                " If there is no window with the correct buffer loaded then load it
                                " into the first window that has a non-special buffer in it.
    1              0.000001     if filewinnr == 0
                                    for i in range(1, winnr('$'))
                                        call s:goto_win(i, 1)
                                        if &buftype == '' && !&previewwindow
                                            execute 'buffer ' . a:fileinfo.bufnr
                                            break
                                        endif
                                    endfor
                                else
    1   0.000046   0.000005         call s:goto_win(filewinnr, 1)
    1              0.000001     endif
                            
                                " To make ctrl-w_p work we switch between the Tagbar window and the
                                " correct window once
    1   0.014741   0.000007     call s:goto_tagbar(noauto)
    1   0.077697   0.000009     call s:goto_win('p', noauto)

FUNCTION  <SNR>14_LoadFTPlugin()
Called 2 times
Total time:   0.005731
 Self time:   0.004415

count  total (s)   self (s)
    2              0.000010     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
    2              0.000007     let s = expand("<amatch>")
    2              0.000003     if s != ""
    2              0.000017       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    4              0.000018       for name in split(s, '\.')
    2   0.005629   0.004313 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    2              0.000008       endfor
    2              0.000002     endif

FUNCTION  <SNR>179_mfunc()
Called 1 time
Total time:   0.000337
 Self time:   0.000102

count  total (s)   self (s)
    1              0.000004 	let mfunc = 'match'
    1   0.000185   0.000023 	if s:byfname()
                            		let mfunc = 's:matchfname'
                            	elsei s:curtype() == 'buf'
                            		let mfunc = 's:matchbuf'
                            	elsei s:itemtype >= len(s:coretypes)
                            		let matchtypes = { 'tabs': 's:matchtabs', 'tabe': 's:matchtabe' }
                            		if has_key(matchtypes, s:matchtype)
                            			let mfunc = matchtypes[s:matchtype]
                            		en
                            	en
    1              0.000006 	retu mfunc

FUNCTION  <SNR>144_add_snr()
Called 288 times
Total time:   0.001434
 Self time:   0.001434

count  total (s)   self (s)
  288              0.000442     if !exists("s:snr")
                                    let s:snr = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeget_snr$')
                                endif
  288              0.000335     return s:snr . a:funcname

FUNCTION  <SNR>159_OnBufferEnter()
Called 5 times
Total time:   0.003274
 Self time:   0.002142

count  total (s)   self (s)
    5   0.000295   0.000079   if !s:VisitedBufferRequiresReparse()
    4              0.000005     return
                              endif
                            
    1   0.000023   0.000003   call s:SetUpCompleteopt()
    1   0.000009   0.000002   call s:SetCompleteFunc()
    1   0.000015   0.000003   call s:StartMessagePoll()
                            
    1              0.002021   exec s:python_command "ycm_state.OnBufferVisit()"
                              " Last parse may be outdated because of changes from other buffers. Force a
                              " new parse.
    1   0.000895   0.000018   call s:OnFileReadyToParse( 1 )

FUNCTION  <SNR>144_isFolded()
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000010     return self.fileinfo.tagfolds[self.fields.kind][self.fullpath]

FUNCTION  <SNR>117_format_name()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002     return a:name

FUNCTION  <SNR>55_detect()
Called 2 times
Total time:   0.011764
 Self time:   0.000260

count  total (s)   self (s)
    2              0.000005   if &buftype ==# 'help'
                                return
                              endif
                            
    2   0.011485   0.000057   let options = s:guess(getline(1, 1024))
    2   0.000072   0.000028   if s:apply_if_ready(options)
    1              0.000000     return
                              endif
    1   0.000046   0.000014   let patterns = s:patterns_for(&filetype)
    1              0.000004   call filter(patterns, 'v:val !~# "/"')
    1              0.000015   let dir = expand('%:p:h')
    1              0.000004   let c = get(b:, 'sleuth_neighbor_limit', get(g:, 'sleuth_neighbor_limit', 20))
    5              0.000021   while isdirectory(dir) && dir !=# fnamemodify(dir, ':h') && c > 0
    4              0.000004     for pattern in patterns
                                  for neighbor in split(glob(dir.'/'.pattern), "\n")[0:7]
                                    if neighbor !=# expand('%:p') && filereadable(neighbor)
                                      call extend(options, s:guess(readfile(neighbor, '', 256)), 'keep')
                                      let c -= 1
                                    endif
                                    if s:apply_if_ready(options)
                                      let b:sleuth_culprit = neighbor
                                      return
                                    endif
                                    if c <= 0
                                      break
                                    endif
                                  endfor
                                  if c <= 0
                                    break
                                  endif
                                endfor
    4              0.000008     let dir = fnamemodify(dir, ':h')
    4              0.000005   endwhile
    1              0.000002   if has_key(options, 'shiftwidth')
                                return s:apply_if_ready(extend({'expandtab': 1}, options))
                              endif

FUNCTION  syntastic#util#fname2buf()
Called 8 times
Total time:   0.001468
 Self time:   0.001468

count  total (s)   self (s)
    8              0.000057     if exists('+shellslash')
                                    " bufnr() can't cope with backslashes
                                    let old_shellslash = &shellslash
                                    let &shellslash = 1
                                endif
                            
                                " this is a best-effort attempt to escape file patterns (cf. :h file-pattern)
                                " XXX it fails for filenames containing something like \{2,3}
    8              0.000024     let buf = -1
   11              0.000075     for md in [':~:.', ':~', ':p']
   11              0.000019         try
                                        " Older versions of Vim can throw E94 here
   11              0.000867             let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
   11              0.000024         catch
                                        " catch everything
                                    endtry
   11              0.000027         if buf != -1
    8              0.000011             break
                                    endif
    3              0.000010     endfor
    8              0.000017     if buf == -1
                                    " XXX definitely wrong, but hope is the last thing to die :)
                                    let buf = bufnr(fnamemodify(a:fname, ':p'))
                                endif
                            
    8              0.000032     if exists('+shellslash')
                                    let &shellslash = old_shellslash
                                endif
                            
    8              0.000020     return buf

FUNCTION  <SNR>122_wordcount_update()
Called 193 times
Total time:   0.029979
 Self time:   0.029979

count  total (s)   self (s)
  193              0.001946   if empty(bufname(''))
                                return
                              endif
  193              0.012135   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                let l:mode = mode()
                                if l:mode ==# 'v' || l:mode ==# 'V' || l:mode ==# 's' || l:mode ==# 'S'
                                  let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                  let b:airline_change_tick = b:changedtick
                                else
                                  if get(b:, 'airline_wordcount_cache', '') is# '' || b:airline_wordcount_cache isnot# get(b:, 'airline_wordcount', '') || get(b:, 'airline_change_tick', 0) != b:changedtick ||  get(b:, 'airline_winwidth', 0) != winwidth(0)
                                    " cache data
                                    let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                    let b:airline_wordcount_cache = b:airline_wordcount
                                    let b:airline_change_tick = b:changedtick
                                    let b:airline_winwidth = winwidth(0)
                                  endif
                                endif
                              endif

FUNCTION  <SNR>142_getTags()
Called 9 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    9              0.000015     return self._taglist

FUNCTION  airline#extensions#tabline#buflist#list()
Called 40 times
Total time:   0.001338
 Self time:   0.001194

count  total (s)   self (s)
   40              0.000185   if exists('s:current_buffer_list')
   36              0.000087     return s:current_buffer_list
                              endif
                            
    4              0.000023   let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
    4              0.000023   let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
    4              0.000023   let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
    4              0.000054   let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
    4              0.000009   let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
   17              0.000044   for nr in list
   13              0.000052     if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                            
                                  " check buffer numbers first
    7              0.000031       if index(exclude_buffers, nr) >= 0
                                    continue
                                    " check paths second
                                  elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                    " check other types last
                                  elseif s:ExcludeOther(nr, exclude_preview)
    1              0.000002         continue
                                  endif
                            
    6              0.000030       call add(buffers, nr)
    6              0.000007     endif
   12              0.000017   endfor
                            
    4              0.000019   let s:current_buffer_list = buffers
    4              0.000009   return buffers

FUNCTION  <SNR>156_build_command()
Called 3 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    3              0.000008   if has('unix')
    3              0.000006     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  <SNR>47_is_file_buffer()
Called 12 times
Total time:   0.000171
 Self time:   0.000171

count  total (s)   self (s)
   12              0.000156   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  airline#extensions#tabline#builder#new()
Called 11 times
Total time:   0.000844
 Self time:   0.000318

count  total (s)   self (s)
   11   0.000644   0.000118   let builder = airline#builder#new(a:context)
   11              0.000049   let builder._build = builder.build
   11              0.000103   call extend(builder, s:prototype, 'force')
   11              0.000023   return builder

FUNCTION  SimpylFold#FoldExpr()
Called 337 times
Total time:   0.112690
 Self time:   0.002279

count  total (s)   self (s)
  337              0.000704     if !exists('b:SimpylFold_cache')
    3   0.110557   0.000146         let b:SimpylFold_cache = s:cache()
    3              0.000004     endif
  337              0.000747     return b:SimpylFold_cache[(a:lnum)]['foldexpr']

FUNCTION  airline#extensions#tabline#get_buffer_name()
Called 29 times
Total time:   0.011531
 Self time:   0.000733

count  total (s)   self (s)
   29   0.000501   0.000293   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
   29              0.000135   let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
   29   0.010878   0.000288   return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  SyntasticMake()
Called 2 times
Total time:   0.491558
 Self time:   0.001180

count  total (s)   self (s)
    2   0.000026   0.000011     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'SyntasticMake: called with options:', a:options)
                            
                                " save options and locale env variables {{{3
    2              0.000004     let old_local_errorformat = &l:errorformat
    2              0.000004     let old_errorformat = &errorformat
    2              0.000008     let old_cwd = getcwd()
                                " }}}3
                            
    2              0.000004     if has_key(a:options, 'errorformat')
    2              0.000012         let &errorformat = a:options['errorformat']
    2              0.000004         set errorformat<
    2              0.000001     endif
                            
    2              0.000003     if has_key(a:options, 'cwd')
                                    execute 'lcd ' . fnameescape(a:options['cwd'])
                                endif
                            
                                " set environment variables {{{3
    2              0.000003     let env_save = {}
    2              0.000005     if has_key(a:options, 'env') && len(a:options['env'])
    4              0.000008         for key in keys(a:options['env'])
    2              0.000015             if key =~? '\m^[a-z_][a-z0-9_]*$'
    2              0.000015                 execute 'let env_save[' . string(key) . '] = $' . key
    2              0.000012                 execute 'let $' . key . ' = ' . string(a:options['env'][key])
    2              0.000001             endif
    2              0.000001         endfor
    2              0.000000     endif
                                " }}}3
                            
    2   0.490332   0.000051     let err_lines = split(syntastic#util#system(a:options['makeprg']), "\n", 1)
                            
                                " restore environment variables {{{3
    2              0.000008     if len(env_save)
    4              0.000010         for key in keys(env_save)
    2              0.000018             execute 'let $' . key . ' = ' . string(env_save[key])
    2              0.000002         endfor
    2              0.000002     endif
                                " }}}3
                            
    2   0.000032   0.000016     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                            
                                " Does it still make sense to go on?
    2   0.000064   0.000023     let bailout = syntastic#util#var('exit_checks') && has_key(a:options, 'returns') && index(a:options['returns'], v:shell_error) == -1
                            
    2              0.000002     if !bailout
    2              0.000003         if has_key(a:options, 'Preprocess')
                                        let err_lines = call(a:options['Preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess (external):', err_lines)
                                    elseif has_key(a:options, 'preprocess')
                                        let err_lines = call('syntastic#preprocess#' . a:options['preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess:', err_lines)
                                    endif
    2              0.000548         noautocmd lgetexpr err_lines
                            
    2              0.000091         let errors = deepcopy(getloclist(0))
                            
    2              0.000005         if has_key(a:options, 'cwd')
                                        execute 'lcd ' . fnameescape(old_cwd)
                                    endif
                            
    2              0.000003         try
    2              0.000020             silent lolder
    2              0.000003         catch /\m^Vim\%((\a\+)\)\=:E380/
                                        " E380: At bottom of quickfix stack
                                        call setloclist(0, [], 'r')
                                        try
                                            " Vim 7.4.2200 or later
                                            call setloclist(0, [], 'r', { 'title': '' })
                                        catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            " do nothing
                                        endtry
                                    catch /\m^Vim\%((\a\+)\)\=:E776/
                                        " E776: No location list
                                        " do nothing
                                    endtry
    2              0.000001     else
                                    let errors = []
                                endif
                            
                                " restore options {{{3
    2              0.000015     let &errorformat = old_errorformat
    2              0.000005     let &l:errorformat = old_local_errorformat
                                " }}}3
                            
    2   0.000051   0.000042     if !s:_running_windows && (s:_os_name() =~? 'FreeBSD' || s:_os_name() =~? 'OpenBSD')
                                    call syntastic#util#redraw(g:syntastic_full_redraws)
                                endif
                            
    2              0.000002     if bailout
                                    call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                                    throw 'Syntastic: checker error'
                                endif
                            
    2   0.000027   0.000011     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'raw loclist:', errors)
                            
    2              0.000004     if has_key(a:options, 'defaults')
                                    call s:_add_to_errors(errors, a:options['defaults'])
                                endif
                            
                                " Add subtype info if present.
    2              0.000003     if has_key(a:options, 'subtype')
                                    call s:_add_to_errors(errors, { 'subtype': a:options['subtype'] })
                                endif
                            
    2              0.000005     if has_key(a:options, 'Postprocess') && !empty(a:options['Postprocess'])
                                    for rule in a:options['Postprocess']
                                        let errors = call(rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess (external):', errors)
                                elseif has_key(a:options, 'postprocess') && !empty(a:options['postprocess'])
                                    for rule in a:options['postprocess']
                                        let errors = call('syntastic#postprocess#' . rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess:', errors)
                                endif
                            
    2              0.000003     return errors

FUNCTION  <SNR>72_shellslash()
Called 14 times
Total time:   0.000182
 Self time:   0.000104

count  total (s)   self (s)
   14   0.000122   0.000044   if s:winshell()
                                return s:gsub(a:path,'\\','/')
                              else
   14              0.000013     return a:path
                              endif

FUNCTION  <SNR>158_save_last_seen_change()
Called 2 times
Total time:   0.000045
 Self time:   0.000016

count  total (s)   self (s)
    2   0.000044   0.000015   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  <SNR>179_curtype()
Called 142 times
Total time:   0.005647
 Self time:   0.001250

count  total (s)   self (s)
  142   0.005583   0.001186 	return s:CurTypeName()[1]

FUNCTION  <SNR>138_TagbarBufName()
Called 35 times
Total time:   0.000479
 Self time:   0.000479

count  total (s)   self (s)
   35              0.000163     if !exists('t:tagbar_buf_name')
                                    let s:buffer_seqno += 1
                                    let t:tagbar_buf_name = '__Tagbar__.' . s:buffer_seqno
                                endif
                            
   35              0.000085     return t:tagbar_buf_name

FUNCTION  <SNR>158_process_modified()
Called 2 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
    2              0.000004   let offset = 0
   12              0.000027   while offset < a:to_count
   10              0.000028     let line_number = a:to_line + offset
   10              0.000041     call add(a:modifications, [line_number, 'modified'])
   10              0.000017     let offset += 1
   10              0.000011   endwhile

FUNCTION  ctrlp#setpathmode()
Called 1 time
Total time:   0.001522
 Self time:   0.000225

count  total (s)   self (s)
    1              0.000014 	if a:pmode == 'c' || ( a:pmode == 'a' && stridx(s:crfpath, s:cwd) < 0 )
                            		if exists('+acd') | let [s:glb_acd, &acd] = [&acd, 0] | en
                            		cal ctrlp#setdir(s:crfpath)
                            		retu 1
                            	elsei a:pmode == 'r'
    1              0.000010 		let spath = a:0 ? a:1 : s:crfpath
    1              0.000012 		let markers = ['.git', '.hg', '.svn', '.bzr', '_darcs']
    1              0.000019 		if type(s:rmarkers) == 3 && !empty(s:rmarkers)
                            			if s:findroot(spath, s:rmarkers, 0, 0) != [] | retu 1 | en
                            			cal filter(markers, 'index(s:rmarkers, v:val) < 0')
                            			let markers = s:rmarkers + markers
                            		en
    1   0.001390   0.000093 		if s:findroot(spath, markers, 0, 0) != [] | retu 1 | en
                            	en
                            	retu 0

FUNCTION  airline#extensions#apply()
Called 18 times
Total time:   0.003205
 Self time:   0.001589

count  total (s)   self (s)
   18              0.000097   let s:active_winnr = winnr()
                            
   18   0.001798   0.000182   if s:is_excluded_window()
                                return -1
                              endif
                            
   18              0.000056   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
   18              0.000033   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
   18              0.000200   if has_key(s:filetype_overrides, &ft)
                                let args = s:filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
                              endif
                            
   18              0.000115   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  413()
Called 1 time
Total time:   0.000214
 Self time:   0.000070

count  total (s)   self (s)
    1              0.000006     let bufnum = get(self.buffers, a:i, -1)
    1   0.000083   0.000007     let group = self.get_group(a:i)
    1   0.000077   0.000009     let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
    1              0.000005     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1              0.000003       let space = s:spc
    1              0.000001     else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
    1              0.000004     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. get(s:number_map, a:i+1, '') . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
    1              0.000008       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif

FUNCTION  <SNR>115_get_hunks_gitgutter()
Called 223 times
Total time:   0.028836
 Self time:   0.007185

count  total (s)   self (s)
  223   0.008511   0.003714   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
    1              0.000001     return ''
                              endif
  222   0.019035   0.002181   return GitGutterGetHunkSummary()

FUNCTION  <SNR>179_safe_printf()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000001 	try
    1              0.000007 		retu call('printf', [a:format] + a:000)
                            	cat
                            		retu a:format
                            	endt

FUNCTION  <SNR>142_getTagsByName()
Called 14 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
   14              0.000061     return get(self._tagdict, a:tagname, [])

FUNCTION  syntastic#util#unique()
Called 6 times
Total time:   0.000350
 Self time:   0.000350

count  total (s)   self (s)
    6              0.000011     let seen = {}
    6              0.000006     let uniques = []
   43              0.000036     for e in a:list
   37              0.000064         let k = string(e)
   37              0.000053         if !has_key(seen, k)
    8              0.000014             let seen[k] = 1
    8              0.000017             call add(uniques, e)
    8              0.000003         endif
   37              0.000032     endfor
    6              0.000006     return uniques

FUNCTION  <SNR>144__getPrefix()
Called 11 times
Total time:   0.000246
 Self time:   0.000246

count  total (s)   self (s)
   11              0.000016     let fileinfo = self.fileinfo
                            
   11              0.000013     if !empty(self._childlist)
    1              0.000002         if fileinfo.tagfolds[self.fields.kind][self.fullpath]
                                        let prefix = g:tagbar#icon_closed
                                    else
    1              0.000001             let prefix = g:tagbar#icon_open
    1              0.000000         endif
    1              0.000001     else
   10              0.000018         let prefix = ' '
   10              0.000006     endif
                                " Visibility is called 'access' in the ctags output
   11              0.000013     if g:tagbar_show_visibility
   11              0.000016         if has_key(self.fields, 'access')
    7              0.000021             let prefix .= get(s:visibility_symbols, self.fields.access, ' ')
    7              0.000008         elseif has_key(self.fields, 'file')
                                        let prefix .= s:visibility_symbols.private
                                    else
    4              0.000005             let prefix .= ' '
    4              0.000003         endif
   11              0.000004     endif
                            
   11              0.000011     return prefix

FUNCTION  <SNR>158_process_added()
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000002   let offset = 0
    2              0.000007   while offset < a:to_count
    1              0.000004     let line_number = a:to_line + offset
    1              0.000004     call add(a:modifications, [line_number, 'added'])
    1              0.000002     let offset += 1
    1              0.000001   endwhile

FUNCTION  <SNR>179_execextvar()
Called 3 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
    3              0.000041 	if !empty(g:ctrlp_ext_vars)
                            		cal map(filter(copy(g:ctrlp_ext_vars), 'has_key(v:val, a:key)'), 'eval(v:val[a:key])')
                            	en

FUNCTION  <SNR>68_BufWinEnterHook()
Called 1 time
Total time:   0.000555
 Self time:   0.000120

count  total (s)   self (s)
    1   0.000429   0.000023     let buf = syntastic#util#fname2buf(a:fname)
    1   0.000069   0.000040     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWinEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
    1              0.000012     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
    1              0.000015         let idx = index(reverse(copy(s:_check_stack)), buf)
    1              0.000006         if idx >= 0 && !has('vim_starting')
                                        call remove(s:_check_stack, -idx - 1)
                                        call s:UpdateErrors(buf, 1, [])
                                    endif
    1              0.000002     endif

FUNCTION  gitgutter#utility#is_active()
Called 12 times
Total time:   0.002720
 Self time:   0.000449

count  total (s)   self (s)
   12   0.002708   0.000437   return g:gitgutter_enabled && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  <SNR>177_discover_supported_filetypes()
Called 2 times
Total time:   0.000371
 Self time:   0.000371

count  total (s)   self (s)
                              " Initialize predefined groups & mappings and discover supported file types.
    2              0.000017   if !s:discovered_filetypes
                                " Discover the file types supported by Exuberant Ctags?
                                let command_line = xolox#easytags#ctags_command()
                                if !empty(command_line)
                                  let starttime = xolox#misc#timer#start()
                                  let command_line .= ' --list-languages'
                                  for line in xolox#misc#os#exec({'command': command_line})['stdout']
                                    if line =~ '\[disabled\]$'
                                      " Ignore languages that have been explicitly disabled using `--languages=-Vim'.
                                      continue
                                    elseif line =~ '^\w\S*$'
                                      call add(s:supported_filetypes, xolox#easytags#filetypes#to_vim(xolox#misc#str#trim(line)))
                                    elseif line =~ '\S'
                                      call xolox#misc#msg#warn("easytags.vim %s: Failed to parse line of output from ctags --list-languages: %s", g:xolox#easytags#version, string(line))
                                    endif
                                  endfor
                                  let msg = "easytags.vim %s: Retrieved %i supported languages in %s."
                                  call xolox#misc#timer#stop(msg, g:xolox#easytags#version, len(s:supported_filetypes), starttime)
                                endif
                                " Add file types supported by language specific programs.
                                call extend(s:supported_filetypes, keys(xolox#misc#option#get('easytags_languages', {})))
                                " Don't run s:discover_supported_filetypes() more than once.
                                let s:discovered_filetypes = 1
                              endif

FUNCTION  267()
Called 3 times
Total time:   0.028043
 Self time:   0.000037

count  total (s)   self (s)
    3   0.000042   0.000019     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
    3   0.028000   0.000017     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  268()
Called 3 times
Total time:   0.027983
 Self time:   0.000153

count  total (s)   self (s)
    3   0.000031   0.000012     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
    3   0.000038   0.000012     let auto_loc_list = syntastic#util#var('auto_loc_list')
    3   0.000020   0.000014     if !a:loclist.isEmpty()
    1              0.000001         if auto_loc_list == 1 || auto_loc_list == 3
    1   0.027793   0.000014             call a:loclist.show()
    1              0.000000         endif
    1              0.000000     else
    2              0.000012         if (auto_loc_list == 1 || auto_loc_list == 2) && !empty(get(w:, 'syntastic_loclist_set', []))
                                        try
                                            " Vim 7.4.2200 or later
                                            let title = get(getloclist(0, { 'title': 1 }), 'title', ':SyntasticCheck ')
                                        catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            let title = ':SyntasticCheck '
                                        endtry
                            
                                        if strpart(title, 0, 16) ==# ':SyntasticCheck '
                                            " TODO: this will close the loc list window if one was opened
                                            " by something other than syntastic
                                            call SyntasticLoclistHide()
                            
                                            try
                                                " Vim 7.4.2200 or later
                                                call setloclist(0, [], 'r', { 'title': '' })
                                            catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                                " do nothing
                                            endtry
                                            let w:syntastic_loclist_set = []
                                        endif
                                    endif
    2              0.000001     endif

FUNCTION  <SNR>144_isSplitTag()
Called 14 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
   14              0.000012     return 0

FUNCTION  <SNR>179_modevar()
Called 1 time
Total time:   0.000625
 Self time:   0.000145

count  total (s)   self (s)
    1   0.000054   0.000038 	let s:matchtype = s:mtype()
    1   0.000029   0.000018 	let s:ispath = s:ispathitem()
    1   0.000356   0.000019 	let s:mfunc = s:mfunc()
    1   0.000100   0.000034 	let s:nolim = s:getextvar('nolim')
    1   0.000068   0.000018 	let s:dosort = s:getextvar('sort')
    1              0.000014 	let s:spi = !s:itemtype || s:getextvar('specinput') > 0

FUNCTION  <SNR>156_on_exit_vim()
Called 3 times
Total time:   0.005648
 Self time:   0.000055

count  total (s)   self (s)
    3   0.005642   0.000049   call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))

FUNCTION  <SNR>138_ExecuteCtagsOnFile()
Called 1 time
Total time:   0.008588
 Self time:   0.000221

count  total (s)   self (s)
    1   0.000012   0.000006     call tagbar#debug#log('ExecuteCtagsOnFile called [' . a:fname . ']')
                            
    1              0.000004     if has_key(a:typeinfo, 'ctagsargs') && type(a:typeinfo.ctagsargs) == type('')
                                    " if ctagsargs is a string, prepend and append space separators
                                    let ctags_args = ' ' . a:typeinfo.ctagsargs . ' '
                                elseif has_key(a:typeinfo, 'ctagsargs') && type(a:typeinfo.ctagsargs) == type([])
                                    let ctags_args = a:typeinfo.ctagsargs
                                " otherwise ctagsargs is not defined or not defined as a valid type
                                else
                                    "Prefer constructing ctags_args as a list rather than a string
                                    "See s:EscapeCtagsCmd() - It's a best practice to shellescape()
                                    "each arg separately because in special cases where space is
                                    "intended to be in an argument, spaces in a single ctag_args
                                    "string would be ambiguous. Is the space an argument separator
                                    "or to be included in the argument
    1              0.000004         let ctags_args  = [ '-f', '-', '--format=2', '--excmd=pattern', '--fields=nksSaf', '--extra=', '--file-scope=yes', '--sort=no', '--append=no' ]
                            
                                    " verbose if debug enabled
    1   0.000008   0.000007         if tagbar#debug#enabled()
                                        let ctags_args += [ '-V' ]
                                    endif
                            
                                    " Include extra type definitions
    1              0.000002         if has_key(a:typeinfo, 'deffile')
                                        let ctags_args += ['--options=' . expand(a:typeinfo.deffile)]
                                    endif
                            
                                    " Third-party programs may not necessarily make use of this
    1              0.000001         if has_key(a:typeinfo, 'ctagstype')
    1              0.000002             let ctags_type = a:typeinfo.ctagstype
                            
    1              0.000001             let ctags_kinds = ''
    7              0.000004             for kind in a:typeinfo.kinds
    6              0.000005                 if kind.short !=# '?'
    5              0.000007                     let ctags_kinds .= kind.short
    5              0.000001                 endif
    6              0.000004             endfor
                            
    1              0.000003             let ctags_args += ['--language-force=' . ctags_type]
    1              0.000002             let ctags_args += ['--' . ctags_type . '-kinds=' . ctags_kinds]
    1              0.000000         endif
    1              0.000001     endif
                            
    1              0.000002     if has_key(a:typeinfo, 'ctagsbin')
                                    " reset 'wildignore' temporarily in case *.exe is included in it
                                    let wildignore_save = &wildignore
                                    set wildignore&
                                    let ctags_bin = expand(a:typeinfo.ctagsbin)
                                    let &wildignore = wildignore_save
                                else
    1              0.000002         let ctags_bin = g:tagbar_ctags_bin
    1              0.000001     endif
                            
    1   0.000195   0.000014     let ctags_cmd = s:EscapeCtagsCmd(ctags_bin, ctags_args, a:fname)
    1              0.000001     if ctags_cmd == ''
                                    return ''
                                endif
                            
    1   0.008180   0.000018     let ctags_output = s:ExecuteCtags(ctags_cmd)
                            
    1              0.000013     if v:shell_error || ctags_output =~ 'Warning: cannot open source file'
                                    call tagbar#debug#log('Command output:')
                                    call tagbar#debug#log(ctags_output)
                                    call tagbar#debug#log('Exit code: ' . v:shell_error)
                                    " Only display an error message if the Tagbar window is open and we
                                    " haven't seen the error before.
                                    if bufwinnr(s:TagbarBufName()) != -1 && (!s:known_files.has(a:realfname) || !empty(s:known_files.get(a:realfname)))
                                        call s:warning('Tagbar: Could not execute ctags for ' . a:realfname . '!')
                                        echomsg 'Executed command: "' . ctags_cmd . '"'
                                        if !empty(ctags_output)
                                            echomsg 'Command output:'
                                            for line in split(ctags_output, '\n')
                                                echomsg line
                                            endfor
                                        endif
                                        echomsg 'Exit code: ' . v:shell_error
                                    endif
                                    return -1
                                endif
                            
    1   0.000033   0.000022     call tagbar#debug#log('Ctags executed successfully')
    1   0.000028   0.000022     call tagbar#debug#log_ctags_output(ctags_output)
                            
    1              0.000002     return ctags_output

FUNCTION  tagbar#debug#log_ctags_output()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000001     if s:debug_enabled
                                    exe 'redir! > ' . s:debug_file . '.ctags_out'
                                    silent echon a:output
                                    redir END
                                endif

FUNCTION  syntastic#util#setLastTick()
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000012     call setbufvar(a:buf, 'syntastic_lasttick', getbufvar(a:buf, 'changedtick'))

FUNCTION  <SNR>176_untracked_output()
Called 2 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    2              0.000034   if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
                                let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
                              else
    2              0.000013     let a:dict.cfg.untracked[a:dict.file] = ''
    2              0.000003   endif

FUNCTION  <SNR>142_sortTags()
Called 1 time
Total time:   0.000684
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000003     if get(a:compare_typeinfo, 'sort', g:tagbar_sort)
    1   0.000678   0.000008         call tagbar#sorting#sort(self._taglist, 'kind', a:compare_typeinfo)
    1              0.000001     else
                                    call tagbar#sorting#sort(self._taglist, 'line', a:compare_typeinfo)
                                endif

FUNCTION  ctrlp#normcmd()
Called 1 time
Total time:   0.000450
 Self time:   0.000347

count  total (s)   self (s)
    1              0.000012 	let buftypes = [ 'quickfix', 'help', 'nofile' ]
    1   0.000106   0.000032 	if a:0 < 2 && s:nosplit() | retu a:cmd | en
    1   0.000152   0.000123 	let norwins = filter(range(1, winnr('$')), 'index(buftypes, getbufvar(winbufnr(v:val), "&bt")) == -1 || s:isterminal(winbufnr(v:val))')
    2              0.000016 	for each in norwins
    1              0.000009 		let bufnr = winbufnr(each)
    1              0.000019 		if empty(bufname(bufnr)) && empty(getbufvar(bufnr, '&ft'))
                            			let fstemp = each | brea
                            		en
    1              0.000035 	endfo
    1              0.000018 	let norwin = empty(norwins) ? 0 : norwins[0]
    1              0.000004 	if norwin
    1              0.000011 		if index(norwins, winnr()) < 0
                            			exe ( exists('fstemp') ? fstemp : norwin ).'winc w'
                            		en
    1              0.000006 		retu a:cmd
                            	en
                            	retu a:0 ? a:1 : 'bo vne'

FUNCTION  270()
Called 6 times
Total time:   0.000095
 Self time:   0.000033

count  total (s)   self (s)
    6   0.000092   0.000030     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  271()
Called 3 times
Total time:   0.000469
 Self time:   0.000059

count  total (s)   self (s)
    3              0.000008     unlet! b:syntastic_private_balloons
    3   0.000062   0.000014     if self.enabled() && !a:loclist.isEmpty()
    1   0.000369   0.000007         let b:syntastic_private_balloons = a:loclist.balloons()
    1              0.000002         if !empty(b:syntastic_private_balloons)
    1              0.000009             set ballooneval balloonexpr=SyntasticBalloonsExprNotifier()
    1              0.000001         endif
    1              0.000001     endif

FUNCTION  274()
Called 3 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    3              0.000003     return self._filetype

FUNCTION  276()
Called 5 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    5              0.000012     return self._filetype . '/' . self._name

FUNCTION  277()
Called 2 times
Total time:   0.000087
 Self time:   0.000047

count  total (s)   self (s)
    2              0.000002     if a:0
                                    let self._exec = a:1
                                else
    2              0.000004         let suffix = self._name . '_exec'
    2   0.000071   0.000031         let self._exec = expand( syntastic#util#var(self._filetype . '_' . suffix, syntastic#util#var(suffix, self._exec_default)), 1 )
    2              0.000002     endif

FUNCTION  278()
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
    1              0.000001     return self._exec

FUNCTION  279()
Called 2 times
Total time:   0.000049
 Self time:   0.000013

count  total (s)   self (s)
    2   0.000048   0.000012     return syntastic#util#shescape(self._exec)

FUNCTION  <SNR>72_can_diffoff()
Called 2 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    2              0.000058   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  419()
Called 1 time
Total time:   0.000094
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000003     let bufnum = get(self.buffers, a:i, -1)
    1   0.000037   0.000004     let group = self.get_group(a:i)
    1   0.000033   0.000004     let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
    1              0.000002     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1              0.000002       let space = s:spc
    1              0.000001     else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
    1              0.000002     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. get(s:number_map, a:i+1, '') . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
    1              0.000004       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif

FUNCTION  xolox#misc#option#get()
Called 4 times
Total time:   0.000296
 Self time:   0.000296

count  total (s)   self (s)
                              " Expects one or two arguments: 1. The name of a variable and 2. the default
                              " value if the variable does not exist.
                              "
                              " Returns the value of the variable from a buffer local variable, global
                              " variable or the default value, depending on which is defined.
                              "
                              " This is used by some of my Vim plug-ins for option handling, so that users
                              " can customize options for specific buffers.
    4              0.000067   if exists('b:' . a:name)
                                " Buffer local variable.
                                return eval('b:' . a:name)
                              elseif exists('g:' . a:name)
                                " Global variable.
                                return eval('g:' . a:name)
                              elseif exists('a:1')
                                " Default value.
    4              0.000021     return a:1
                              endif

FUNCTION  <SNR>179_highlight()
Called 4 times
Total time:   0.001908
 Self time:   0.001730

count  total (s)   self (s)
    4              0.000031 	if s:matcher != {} | retu | en
    4              0.000020 	cal clearmatches()
    4              0.000020 	if !empty(a:pat) && s:ispath
    3              0.000007 		if s:regexp
                            			let pat = substitute(a:pat, '\\\@<!\^', '^> \\zs', 'g')
                            			cal matchadd(a:grp, ( s:martcs == '' ? '\c' : '\C' ).pat)
                            		el
    3              0.000014 			let pat = a:pat
                            
                            			" get original characters so we can rebuild pat
    3              0.000074 			let chars = split(pat, '\[\^\\\?.\]\\{-}')
                            
                            			" Build a pattern like /a.*b.*c/ from abc (but with .\{-} non-greedy
                            			" matchers instead)
    3              0.000029 			let pat = join(chars, '.\{-}')
                            			" Ensure we match the last version of our pattern
    3              0.000019 			let ending = '\(.*'.pat.'\)\@!'
                            			" Case sensitive?
    3              0.000022 			let beginning = ( s:martcs == '' ? '\c' : '\C' ).'^.*'
    3   0.000205   0.000027 			if s:byfname()
                            				" Make sure there are no slashes in our match
                            				let beginning = beginning.'\([^\/]*$\)\@='
                            			en
                            
   10              0.000055 			for i in range(len(chars))
                            				" Surround our current target letter with \zs and \ze so it only
                            				" actually matches that one letter, but has all preceding and trailing
                            				" letters as well.
                            				" \zsa.*b.*c
                            				" a\(\zsb\|.*\zsb)\ze.*c
    7              0.000063 				let charcopy = copy(chars)
    7              0.000024 				if i == 0
    3              0.000031 					let charcopy[i] = '\zs'.charcopy[i].'\ze'
    3              0.000022 					let middle = join(charcopy, '.\{-}')
    3              0.000012 				el
    4              0.000060 					let before = join(charcopy[0:i-1], '.\{-}')
    4              0.000048 					let after = join(charcopy[i+1:-1], '.\{-}')
    4              0.000024 					let c = charcopy[i]
                            					" for abc, match either ab.\{-}c or a.*b.\{-}c in that order
    4              0.000036 					let cpat = '\(\zs'.c.'\|'.'.*\zs'.c.'\)\ze.*'
    4              0.000030 					let middle = before.cpat.after
    4              0.000008 				en
                            
                            				" Now we matchadd for each letter, the basic form being:
                            				" ^.*\zsx\ze.*$, but with our pattern we built above for the letter,
                            				" and a negative lookahead ensuring that we only highlight the last
                            				" occurrence of our letters. We also ensure that our matcher is case
                            				" insensitive or sensitive depending.
    7              0.000394 				cal matchadd(a:grp, beginning.middle.ending)
    7              0.000021 			endfo
    3              0.000005 		en
                            
    3              0.000068 		cal matchadd('CtrlPLinePre', '^>')
    3              0.000027 	elseif !empty(a:pat) && s:regexp && exists('g:ctrlp_regex_always_higlight') && g:ctrlp_regex_always_higlight
                            		let pat = substitute(a:pat, '\\\@<!\^', '^> \\zs', 'g')
                            		cal matchadd(a:grp, ( s:martcs == '' ? '\c' : '\C').pat)
                            	en

FUNCTION  <SNR>179_buffunc()
Called 2 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
    2              0.000024 	if a:e && has_key(s:buffunc, 'enter')
                            		cal call(s:buffunc['enter'], [], s:buffunc)
                            	elsei !a:e && has_key(s:buffunc, 'exit')
                            		cal call(s:buffunc['exit'], [], s:buffunc)
                            	en

FUNCTION  <SNR>159_VisitedBufferRequiresReparse()
Called 5 times
Total time:   0.000216
 Self time:   0.000082

count  total (s)   self (s)
    5              0.000033   if bufnr( '%' ) ==# s:previous_allowed_buffer_number
    2              0.000002     return 0
                              endif
                            
    3   0.000160   0.000026   return s:AllowedToCompleteInCurrentBuffer()

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 7 times
Total time:   0.002299
 Self time:   0.000209

count  total (s)   self (s)
    7              0.000026   if getbufvar(a:bufnr, '&modified')
    5              0.000050     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    5              0.000003   else
    2              0.000019     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    2              0.000000   endif
                            
    7              0.000011   if !empty(colors)
    7   0.002142   0.000052     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    7              0.000002   endif

FUNCTION  tagbar#prototypes#fileinfo#new()
Called 1 time
Total time:   0.000199
 Self time:   0.000144

count  total (s)   self (s)
    1              0.000002     let newobj = {}
                            
                                " The complete file path
    1              0.000002     let newobj.fpath = a:fname
                            
    1              0.000010     let newobj.bufnr = bufnr(a:fname)
                            
                                " File modification time
    1              0.000004     let newobj.mtime = getftime(a:fname)
                            
                                " The vim file type
    1              0.000001     let newobj.ftype = a:ftype
                            
                                " List of the tags that are present in the file, sorted according to the
                                " value of 'g:tagbar_sort'
    1              0.000002     let newobj._taglist = []
    1              0.000001     let newobj._tagdict = {}
                            
                                " Dictionary of the tags, indexed by line number in the file
    1              0.000001     let newobj.fline = {}
                            
                                " Dictionary of the tags, indexed by line number in the tagbar
    1              0.000001     let newobj.tline = {}
                            
                                " Dictionary of the folding state of 'kind's, indexed by short name
    1              0.000001     let newobj.kindfolds = {}
    1              0.000002     let newobj.typeinfo = a:typeinfo
                                " copy the default fold state from the type info
    7              0.000008     for kind in a:typeinfo.kinds
    6              0.000015         let newobj.kindfolds[kind.short] = g:tagbar_foldlevel == 0 ? 1 : kind.fold
    6              0.000003     endfor
                            
                                " Dictionary of dictionaries of the folding state of individual tags,
                                " indexed by kind and full path
    1              0.000001     let newobj.tagfolds = {}
    7              0.000006     for kind in a:typeinfo.kinds
    6              0.000011         let newobj.tagfolds[kind.short] = {}
    6              0.000002     endfor
                            
                                " The current foldlevel of the file
    1              0.000002     let newobj.foldlevel = g:tagbar_foldlevel
                            
    1   0.000018   0.000010     let newobj.addTag = function(s:add_snr('s:addTag'))
    1   0.000012   0.000006     let newobj.getTags = function(s:add_snr('s:getTags'))
    1   0.000019   0.000006     let newobj.getTagsByName = function(s:add_snr('s:getTagsByName'))
    1   0.000011   0.000006     let newobj.removeTag = function(s:add_snr('s:removeTag'))
    1   0.000010   0.000005     let newobj.reset = function(s:add_snr('s:reset'))
    1   0.000009   0.000004     let newobj.clearOldFolds = function(s:add_snr('s:clearOldFolds'))
    1   0.000009   0.000005     let newobj.sortTags = function(s:add_snr('s:sortTags'))
    1   0.000009   0.000004     let newobj.openKindFold = function(s:add_snr('s:openKindFold'))
    1   0.000009   0.000005     let newobj.closeKindFold = function(s:add_snr('s:closeKindFold'))
                            
    1              0.000001     return newobj

FUNCTION  <SNR>68_BufEnterHook()
Called 5 times
Total time:   0.545901
 Self time:   0.000506

count  total (s)   self (s)
    5   0.000748   0.000072     let buf = syntastic#util#fname2buf(a:fname)
    5   0.000213   0.000100     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
    5              0.000027     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
    3              0.000021         let idx = index(reverse(copy(s:_check_stack)), buf)
    3              0.000005         if idx >= 0
    1              0.000008             if !has('vim_starting')
    1              0.000007                 call remove(s:_check_stack, -idx - 1)
    1   0.542852   0.000026                 call s:UpdateErrors(buf, 1, [])
    1              0.000000             endif
    1              0.000001         elseif &buftype ==# ''
    2   0.001806   0.000026             call s:notifiers.refresh(g:SyntasticLoclist.current())
    2              0.000002         endif
    3              0.000003     elseif &buftype ==# 'quickfix'
                                    " TODO: this is needed because in recent versions of Vim lclose
                                    " can no longer be called from BufWinLeave
                                    " TODO: at this point there is no b:syntastic_loclist
                                    let loclist = filter(copy(getloclist(0)), 'v:val["valid"]')
                                    let owner = str2nr(getbufvar(buf, 'syntastic_owner_buffer'))
                                    let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
                                    if !empty(get(w:, 'syntastic_loclist_set', [])) && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                        call SyntasticLoclistHide()
                                    endif
                                endif

FUNCTION  xolox#easytags#autoload()
Called 2 times
Total time:   0.003289
 Self time:   0.002289

count  total (s)   self (s)
    2              0.000010   try
    2   0.000100   0.000066     let session_loading = xolox#easytags#session_is_loading() && a:event == 'BufReadPost'
    2   0.000257   0.000102     let do_update = xolox#misc#option#get('easytags_auto_update', 1) && !session_loading
    2   0.000224   0.000083     let do_highlight = xolox#misc#option#get('easytags_auto_highlight', 1) && &eventignore !~? '\<syntax\>'
                                " Don't execute this function for unsupported file types (doesn't load
                                " the list of file types if updates and highlighting are both disabled).
    2   0.000758   0.000088     if (do_update || do_highlight) && !empty(xolox#easytags#filetypes#canonicalize(&filetype))
                                  " Update entries for current file in tags file?
    2              0.000011       if do_update
    2              0.000052         let buffer_read = (a:event =~? 'BufReadPost')
    2              0.000041         let buffer_written = (a:event =~? 'BufWritePost')
    2              0.000030         if buffer_written || (buffer_read && xolox#misc#option#get('easytags_always_enabled', 0))
                                      call xolox#easytags#update(1, 0, [])
                                    endif
    2              0.000006       endif
                                  " Apply highlighting of tags to current buffer?
    2              0.000010       if do_highlight
    2              0.000028         if !exists('b:easytags_last_highlighted')
                                      call xolox#easytags#highlight()
                                    else
    6              0.001321           for tagfile in tagfiles()
    4              0.000085             if getftime(tagfile) > b:easytags_last_highlighted
                                          call xolox#easytags#highlight()
                                          break
                                        endif
    4              0.000015           endfor
    2              0.000009         endif
    2              0.000062         let b:easytags_last_highlighted = localtime()
    2              0.000007       endif
    2              0.000006     endif
    2              0.000009   catch
                                call xolox#misc#msg#warn("easytags.vim %s: %s (at %s)", g:xolox#easytags#version, v:exception, v:throwpoint)
                              endtry

FUNCTION  syntastic#util#setWids()
Called 1 time
Total time:   0.000252
 Self time:   0.000252

count  total (s)   self (s)
    2              0.000024     for tab in range(1, tabpagenr('$'))
    4              0.000026         for win in range(1, tabpagewinnr(tab, '$'))
    3              0.000031             if gettabwinvar(tab, win, 'syntastic_wid') ==# ''
    3              0.000059                 call settabwinvar(tab, win, 'syntastic_wid', s:_wid_base . s:_wid_pool)
    3              0.000027                 let s:_wid_pool += 1
    3              0.000008             endif
    3              0.000009         endfor
    1              0.000002     endfor

FUNCTION  airline#extensions#branch#get_head()
Called 223 times
Total time:   0.277975
 Self time:   0.013700

count  total (s)   self (s)
  223   0.267224   0.002949   let head = airline#extensions#branch#head()
  223              0.002645   let empty_message = get(g:, 'airline#extensions#branch#empty_message', '')
  223              0.002528   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
  223              0.004965   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  fugitive#head()
Called 223 times
Total time:   0.110928
 Self time:   0.009492

count  total (s)   self (s)
  223              0.001701   if !exists('b:git_dir')
                                return ''
                              endif
                            
  223   0.107518   0.006082   return s:repo().head(a:0 ? a:1 : 0)

FUNCTION  280()
Called 2 times
Total time:   0.494812
 Self time:   0.000239

count  total (s)   self (s)
    2              0.000006     let checker_start = reltime()
    2   0.000010   0.000006     let name = self.getCName()
                            
    2              0.000004     if has_key(self, '_enable')
                                    let status = syntastic#util#var(self._enable, -1)
                                    if type(status) != type(0)
                                        call syntastic#log#error('checker ' . name . ': invalid value ' . strtrans(string(status)) . ' for g:syntastic_' . self._enable . '; try 0 or 1 instead')
                                        return []
                                    endif
                                    if status < 0
                                        call syntastic#log#error('checker ' . name . ': checks disabled for security reasons; ' . 'set g:syntastic_' . self._enable . ' to 1 to override')
                                    endif
                                    if status <= 0
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' enabled but not forced')
                                        return []
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' forced')
                                    endif
                                endif
                            
    2              0.000002     try
    2   0.493514   0.000047         let list = self._locListFunc()
    2              0.000005         if self._exec !=# ''
    2   0.000034   0.000017             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' returned ' . v:shell_error)
    2              0.000000         endif
    2              0.000003     catch /\m\C^Syntastic: checker error$/
                                    let list = []
                                    if self._exec !=# ''
                                        call syntastic#log#error('checker ' . name . ' returned abnormal status ' . v:shell_error)
                                    else
                                        call syntastic#log#error('checker ' . name . ' aborted')
                                    endif
                                endtry
    2   0.000931   0.000019     call self._populateHighlightRegexes(list)
    2   0.000025   0.000011     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, name . ' raw:', list)
    2   0.000156   0.000010     call self._quietMessages(list)
    2   0.000055   0.000042     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' run in ' . split(reltimestr(reltime(checker_start)))[0] . 's')
    2              0.000005     return list

FUNCTION  281()
Called 2 times
Total time:   0.495039
 Self time:   0.000031

count  total (s)   self (s)
    2   0.495036   0.000028     return g:SyntasticLoclist.New(self.getLocListRaw())

FUNCTION  284()
Called 1 time
Total time:   0.000026
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000005   0.000003     let leader = self.getCName() . ': '
    1              0.000001     if a:0
    1   0.000016   0.000006         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, leader . a:msg, a:1)
    1              0.000001     else
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, leader . a:msg)
                                endif

FUNCTION  285()
Called 2 times
Total time:   0.000759
 Self time:   0.000104

count  total (s)   self (s)
    2              0.000004     let basename = self._filetype . '_' . self._name . '_'
                            
    2              0.000020     let parts = []
    2   0.000231   0.000021     call extend(parts, self._getOpt(a:opts, basename, 'exe', self.getExecEscaped()))
    2   0.000113   0.000009     call extend(parts, self._getOpt(a:opts, basename, 'args', ''))
    2   0.000168   0.000022     call extend(parts, self._getOpt(a:opts, basename, 'fname', syntastic#util#shexpand('%')))
    2   0.000109   0.000009     call extend(parts, self._getOpt(a:opts, basename, 'post_args', ''))
    2   0.000105   0.000010     call extend(parts, self._getOpt(a:opts, basename, 'tail', ''))
                            
    2              0.000005     return join(parts)

FUNCTION  286()
Called 2 times
Total time:   0.000118
 Self time:   0.000031

count  total (s)   self (s)
    2   0.000093   0.000006     call self.syncExec()
                            
    2              0.000004     if !has_key(self, '_available')
                                    let self._available = {}
                                endif
    2              0.000006     if !has_key(self._available, self._exec)
                                    let self._available[self._exec] = self._isAvailableFunc()
                                endif
                            
    2              0.000003     return self._available[self._exec]

FUNCTION  288()
Called 1 time
Total time:   0.000017
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000017   0.000007     return syntastic#util#var(self._filetype . '_' . self._name . '_sort', 0)

FUNCTION  airline#extensions#ctrlp#apply()
Called 9 times
Total time:   0.000152
 Self time:   0.000152

count  total (s)   self (s)
                              " disable statusline overwrite if ctrlp already did it
    9              0.000126   return match(&statusline, 'CtrlPwhite') >= 0 ? -1 : 0

FUNCTION  airline#extensions#ctrlp#ctrlp_airline_status()
Called 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000014   let len = '%#CtrlPdark# '.a:1
    1              0.000019   let dir = '%=%<%#CtrlParrow3#'.g:airline_right_sep.'%#CtrlPlight# '.getcwd().' %*'
    1              0.000008   return len.dir

FUNCTION  syntastic#util#rawVar()
Called 55 times
Total time:   0.000279
 Self time:   0.000279

count  total (s)   self (s)
   55              0.000250     return get(b:, a:name, get(g:, a:name, a:0 ? a:1 : ''))

FUNCTION  <SNR>179_lastvisual()
Called 1 time
Total time:   0.000365
 Self time:   0.000328

count  total (s)   self (s)
    1              0.000021 	let cview = winsaveview()
    1              0.000023 	let [ovreg, ovtype] = [getreg('v'), getregtype('v')]
    1              0.000022 	let [oureg, outype] = [getreg('"'), getregtype('"')]
    1              0.000037 	sil! norm! gV"vy
    1   0.000074   0.000037 	let selected = s:regisfilter('v')
    1              0.000016 	cal setreg('v', ovreg, ovtype)
    1              0.000020 	cal setreg('"', oureg, outype)
    1              0.000135 	cal winrestview(cview)
    1              0.000009 	retu selected

FUNCTION  <SNR>179_sanstail()
Called 6 times
Total time:   0.000817
 Self time:   0.000817

count  total (s)   self (s)
    6              0.000326 	let str = s:spi ? substitute(a:str, '^\(@.*$\|\\\\\ze@\|\.\.\zs[.\/]\+$\)', '', 'g') : a:str
    6              0.000135 	let [str, pat] = [substitute(str, '\\\\', '\', 'g'), '\([^:]\|\\:\)*$']
    6              0.000033 	unl! s:optail
    6              0.000134 	if str =~ '\\\@<!:'.pat
                            		let s:optail = matchstr(str, '\\\@<!:\zs'.pat)
                            		let str = substitute(str, '\\\@<!:'.pat, '', '')
                            	en
    6              0.000076 	retu substitute(str, '\\\ze:', '', 'g')

FUNCTION  syntastic#util#shexpand()
Called 2 times
Total time:   0.000050
 Self time:   0.000013

count  total (s)   self (s)
    2   0.000050   0.000013     return syntastic#util#shescape(a:0 ? expand(a:string, a:1) : expand(a:string, 1))

FUNCTION  airline#extensions#hunks#get_hunks()
Called 223 times
Total time:   0.103804
 Self time:   0.057219

count  total (s)   self (s)
  223              0.002080   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
                              " Cache values, so that it isn't called too often
  223              0.009916   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && winwidth(0) == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
                              endif
  223   0.049733   0.003148   let hunks = s:get_hunks()
  223              0.000888   let string = ''
  223              0.001258   if !empty(hunks)
  888              0.003910     for i in [0, 1, 2]
  666              0.006149       if (s:non_zero_only == 0 && winwidth(0) > 100) || hunks[i] > 0
  666              0.012042         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  666              0.001425       endif
  666              0.001578     endfor
  222              0.000521   endif
  223              0.001448   let b:airline_hunks = string
  223              0.001465   let b:airline_changenr = b:changedtick
  223              0.001581   let s:airline_winwidth = winwidth(0)
  223              0.000816   return string

FUNCTION  <SNR>72_repo_bare()
Called 1 time
Total time:   0.000017
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000016   0.000013   if self.dir() =~# '/\.git$'
    1              0.000001     return 0
                              else
                                return s:configured_tree(self.git_dir) ==# ''
                              endif

FUNCTION  <SNR>179_unmarksigns()
Called 6 times
Total time:   0.000160
 Self time:   0.000080

count  total (s)   self (s)
    6   0.000154   0.000074 	if !s:dosigns() | retu | en
                            	for key in keys(s:marked)
                            		exe 'sign unplace' key 'buffer='.s:bufnr
                            	endfo

FUNCTION  <SNR>138_GetNearbyTag()
Called 43 times
Total time:   0.014431
 Self time:   0.011067

count  total (s)   self (s)
   43              0.000191     if s:nearby_disabled
                                    return {}
                                endif
                            
   43   0.003560   0.000697     let fileinfo = tagbar#state#get_current_file(a:forcecurrent)
   43              0.000238     if empty(fileinfo)
                                    return {}
                                endif
                            
   43              0.000248     let typeinfo = fileinfo.typeinfo
   43              0.000150     if a:0 > 0
                                    let curline = a:1
                                else
   43              0.000278         let curline = line('.')
   43              0.000096     endif
   43              0.000177     let tag = {}
                            
                                " If a tag appears in a file more than once (for example namespaces in
                                " C++) only one of them has a 'tline' entry and can thus be highlighted.
                                " The only way to solve this would be to go over the whole tag list again,
                                " making everything slower. Since this should be a rare occurence and
                                " highlighting isn't /that/ important ignore it for now.
  203              0.001196     for line in range(curline, 1, -1)
  191              0.001384         if has_key(fileinfo.fline, line)
   31              0.000256             let curtag = fileinfo.fline[line]
   31   0.001104   0.000603             if a:all || typeinfo.getKind(curtag.fields.kind).stl
   31              0.000141                 let tag = curtag
   31              0.000081                 break
                                        endif
                                    endif
  160              0.000344     endfor
                            
   43              0.000148     return tag

FUNCTION  290()
Called 2 times
Total time:   0.000146
 Self time:   0.000085

count  total (s)   self (s)
                                " wildcard quiet_messages
    2   0.000042   0.000013     let quiet_filters = copy(syntastic#util#var('quiet_messages', {}))
    2              0.000006     if type(quiet_filters) != type({})
                                    call syntastic#log#warn('ignoring invalid syntastic_quiet_messages')
                                    unlet quiet_filters
                                    let quiet_filters = {}
                                endif
                            
                                " per checker quiet_messages
    2              0.000005     let name = self._filetype . '_' . self._name
    2              0.000001     try
    2   0.000034   0.000015         call extend( quiet_filters, copy(syntastic#util#var(name . '_quiet_messages', {})), 'force' )
    2              0.000003     catch /\m^Vim\%((\a\+)\)\=:E712/
                                    call syntastic#log#warn('ignoring invalid syntastic_' . name . '_quiet_messages')
                                endtry
                            
    2   0.000023   0.000010     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'quiet_messages filter:', quiet_filters)
                            
    2              0.000003     if !empty(quiet_filters)
                                    call syntastic#util#dictFilter(a:errors, quiet_filters)
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'filtered by quiet_messages:', a:errors)
                                endif

FUNCTION  291()
Called 2 times
Total time:   0.000912
 Self time:   0.000248

count  total (s)   self (s)
    2              0.000005     if has_key(self, '_highlightRegexFunc')
   26              0.000021         for e in a:errors
   25              0.000021             if e['valid']
   25   0.000741   0.000077                 let term = self._highlightRegexFunc(e)
   25              0.000019                 if term !=# ''
    2              0.000017                     let e['hl'] = term
    2              0.000001                 endif
   25              0.000010             endif
   25              0.000017         endfor
    1              0.000001     endif

FUNCTION  292()
Called 10 times
Total time:   0.000556
 Self time:   0.000200

count  total (s)   self (s)
   10              0.000014     let ret = []
   10   0.000135   0.000051     call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_before', '')) )
   10   0.000272   0.000077     call extend( ret, syntastic#util#argsescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
   10   0.000121   0.000044     call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_after', '')) )
                            
   10              0.000007     return ret

FUNCTION  294()
Called 6 times
Total time:   0.000072
 Self time:   0.000019

count  total (s)   self (s)
    6   0.000072   0.000019     return syntastic#util#var('echo_current_error')

FUNCTION  295()
Called 3 times
Total time:   0.002138
 Self time:   0.000081

count  total (s)   self (s)
    3   0.000053   0.000016     if self.enabled() && !a:loclist.isEmpty()
    1   0.000011   0.000005         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
    1   0.002025   0.000013         let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
    1              0.000002         let b:syntastic_private_line = -1
    1   0.000010   0.000008         let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
    1              0.000006         autocmd! syntastic CursorMoved
    1              0.000007         autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
    1              0.000001     endif

FUNCTION  296()
Called 1 time
Total time:   0.000020
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000010   0.000004     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: reset')
    1              0.000006     autocmd! syntastic CursorMoved
    1              0.000001     unlet! b:syntastic_private_messages
    1              0.000001     let b:syntastic_private_line = -1

FUNCTION  299()
Called 3 times
Total time:   0.000912
 Self time:   0.000794

count  total (s)   self (s)
    3   0.000043   0.000007     if self.enabled()
    3   0.000037   0.000014         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
    3   0.000060   0.000009         call self._reset()
    3              0.000006         let buf = bufnr('')
    3   0.000046   0.000038         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
   28              0.000022         for item in issues
   25              0.000074             let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
   25              0.000033             if has_key(item, 'hl')
    2              0.000028                 call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
    2              0.000003             elseif get(item, 'col', 0)
   23              0.000024                 if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
   23              0.000046                     let lastcol = col([item['lnum'], '$'])
   23              0.000021                     let coltype = 'c'
   23              0.000009                 endif
   23              0.000045                 let lcol = min([lastcol, item['col']])
                            
   23              0.000145                 call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
   23              0.000012             endif
   25              0.000012         endfor
    3              0.000003     endif

FUNCTION  gitgutter#utility#getbufvar()
Called 257 times
Total time:   0.008439
 Self time:   0.008439

count  total (s)   self (s)
  257              0.004325   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
  257              0.002106   if has_key(dict, a:varname)
  255              0.001465     return dict[a:varname]
                              else
    2              0.000000     if a:0
                                  return a:1
                                endif
    2              0.000001   endif

FUNCTION  <SNR>138_do_delayed_update()
Called 2 times
Total time:   0.000423
 Self time:   0.000210

count  total (s)   self (s)
    2   0.000261   0.000048     let curfile = tagbar#state#get_current_file(0)
    2              0.000017     if empty(curfile)
                                    let curfname = ''
                                else
    2              0.000019         let curfname = curfile.fpath
    2              0.000006     endif
                            
    2              0.000025     while !empty(s:delayed_update_files)
                                    let fname = remove(s:delayed_update_files, 0)
                                    let no_display = curfname !=# fname
                                    call s:AutoUpdate(fname, 1, no_display)
                                endwhile

FUNCTION  syntastic#util#argsescape()
Called 30 times
Total time:   0.000261
 Self time:   0.000232

count  total (s)   self (s)
   30              0.000062     if type(a:opt) == type('') && a:opt !=# ''
    3              0.000003         return [a:opt]
                                elseif type(a:opt) == type([])
    1   0.000038   0.000009         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
                                endif
                            
   26              0.000020     return []

FUNCTION  <SNR>174_reset_summary()
Called 2 times
Total time:   0.000048
 Self time:   0.000016

count  total (s)   self (s)
    2   0.000045   0.000013   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>179_bufnrfilpath()
Called 1 time
Total time:   0.000736
 Self time:   0.000614

count  total (s)   self (s)
    1   0.000115   0.000051   if s:isabs(a:line) || a:line =~ '^\~[/\\]' || a:line =~ '^\w\+:\/\/'
                            		let filpath = a:line
                            	el
    1   0.000080   0.000022 		let filpath = s:dyncwd.s:lash().a:line
    1              0.000003 	en
    1              0.000041 	let filpath = fnamemodify(filpath, ':p')
    1              0.000402 	let bufnr = bufnr('^'.filpath.'$')
    1              0.000035 	if (!filereadable(filpath) && bufnr < 1)
                            		if (a:line =~ '[\/]\?\[\d\+\*No Name\]$')
                            			let bufnr = str2nr(matchstr(a:line, '[\/]\?\[\zs\d\+\ze\*No Name\]$'))
                            			let filpath = bufnr
                            		els
                            			let bufnr = bufnr(a:line)
                            			retu [bufnr, a:line]
                            		en
                            	en
    1              0.000007 	retu [bufnr, filpath]

FUNCTION  SyntasticStatuslineFlag()
Called 446 times
Total time:   0.122700
 Self time:   0.009232

count  total (s)   self (s)
  446   0.122321   0.008853     return g:SyntasticLoclist.current().getStatuslineFlag()

FUNCTION  tagbar#ToggleWindow()
Called 1 time
Total time:   0.000355
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000004     let flags = a:0 > 0 ? a:1 : ''
    1   0.000350   0.000006     call s:ToggleWindow(flags)

FUNCTION  <SNR>179_isabs()
Called 1 time
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
    1              0.000030 	if (has('win32') || has('win64'))
                            		return a:path =~ '^\([a-zA-Z]:\)\{-}[/\\]'
                            	el
    1              0.000022 		return a:path =~ '^[/\\]'
                            	en

FUNCTION  airline#extensions#syntastic#get_warning()
Called 223 times
Total time:   0.085128
 Self time:   0.003414

count  total (s)   self (s)
  223   0.084878   0.003164   return airline#extensions#syntastic#get('warning')

FUNCTION  airline#util#prepend()
Called 450 times
Total time:   0.010427
 Self time:   0.010427

count  total (s)   self (s)
  450              0.002936   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  450              0.004862   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>72_buffer_getvar()
Called 15 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
   15              0.000049   return getbufvar(self['#'],a:var)

FUNCTION  <SNR>72_buffer()
Called 6 times
Total time:   0.000191
 Self time:   0.000159

count  total (s)   self (s)
    6              0.000033   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
    6              0.000073   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
    6   0.000064   0.000032   if buffer.getvar('git_dir') !=# ''
    6              0.000007     return buffer
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  SyntaxCheckers_python_flake8_GetHighlightRegex()
Called 25 times
Total time:   0.000664
 Self time:   0.000096

count  total (s)   self (s)
   25   0.000660   0.000092     return SyntaxCheckers_python_pyflakes_GetHighlightRegex(a:item)

FUNCTION  <SNR>137__isDebugEnabled_smart()
Called 61 times
Total time:   0.000228
 Self time:   0.000228

count  total (s)   self (s)
   61              0.000194     return and(g:syntastic_debug, a:level)

FUNCTION  ctrlp#files()
Called 1 time
Total time:   0.051848
 Self time:   0.000566

count  total (s)   self (s)
    1   0.000309   0.000058 	let cafile = ctrlp#utils#cachefile()
    1              0.000065 	if g:ctrlp_newcache || !filereadable(cafile) || s:nocache(cafile)
    1   0.000684   0.000047 		let [lscmd, s:initcwd, g:ctrlp_allfiles] = [s:lsCmd(), s:dyncwd, []]
                            		" Get the list of files
    1              0.000009 		if empty(lscmd)
                            			if !ctrlp#igncwd(s:dyncwd)
                            				cal s:InitCustomFuncs()
                            				cal s:GlobPath(s:fnesc(s:dyncwd, 'g', ','), 0)
                            				cal s:CloseCustomFuncs()
                            			en
                            		el
    1   0.031027   0.000055 			sil! cal ctrlp#progress('Indexing...')
    1   0.008126   0.000047 			try | cal s:UserCmd(lscmd)
    1              0.000003 			cat | retu [] | endt
    1              0.000000 		en
                            		" Remove base directory
    1   0.000066   0.000016 		cal ctrlp#rmbasedir(g:ctrlp_allfiles)
    1              0.000003 		if len(g:ctrlp_allfiles) <= s:compare_lim
    1   0.000586   0.000157 			cal sort(g:ctrlp_allfiles, 'ctrlp#complen')
    1              0.000000 		en
    1   0.010872   0.000008 		cal s:writecache(cafile)
    1              0.000012 		let catime = getftime(cafile)
    1              0.000001 	el
                            		let catime = getftime(cafile)
                            		if !( exists('s:initcwd') && s:initcwd == s:dyncwd ) || get(s:ficounts, s:dyncwd, [0, catime])[1] != catime
                            			let s:initcwd = s:dyncwd
                            			let g:ctrlp_allfiles = ctrlp#utils#readfile(cafile)
                            		en
                            	en
    1              0.000011 	cal extend(s:ficounts, { s:dyncwd : [len(g:ctrlp_allfiles), catime] })
    1              0.000004 	retu g:ctrlp_allfiles

FUNCTION  <SNR>63__remove_shadowed_items()
Called 17 times
Total time:   0.000631
 Self time:   0.000631

count  total (s)   self (s)
                                " keep only the first message at a given column
   17              0.000018     let i = 0
   25              0.000048     while i < len(a:errors) - 1
    8              0.000013         let j = i + 1
    8              0.000007         let dupes = 0
    8              0.000024         while j < len(a:errors) && a:errors[j].scol == a:errors[i].scol
                                        let dupes = 1
                                        let j += 1
                                    endwhile
    8              0.000006         if dupes
                                        call remove(a:errors, i + 1, j - 1)
                                    endif
    8              0.000008         let i += 1
    8              0.000002     endwhile
                            
                                " merge messages with the same text
   17              0.000010     let i = 0
   23              0.000037     while i < len(a:errors) - 1
    6              0.000006         let j = i + 1
    6              0.000005         let dupes = 0
   13              0.000039         while j < len(a:errors) && a:errors[j].text == a:errors[i].text
    7              0.000003             let dupes = 1
    7              0.000007             let j += 1
    7              0.000004         endwhile
    6              0.000005         if dupes
    5              0.000014             call remove(a:errors, i + 1, j - 1)
    5              0.000000         endif
    6              0.000005         let i += 1
    6              0.000005     endwhile

FUNCTION  <lambda>3()
Called 1 time
Total time:   0.000079
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000078   0.000017 return gitgutter#utility#setbufvar(bufnr, 'path', s:strip_trailing_new_line(path))

FUNCTION  <SNR>68_UpdateErrors()
Called 1 time
Total time:   0.542826
 Self time:   0.000210

count  total (s)   self (s)
    1   0.000043   0.000029     call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'version')
    1   0.000026   0.000016     call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
    1   0.000027   0.000016     call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
    1   0.000020   0.000011     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') . ': ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                            
    1   0.000038   0.000009     call s:modemap.synch()
                            
    1   0.000144   0.000011     if s:_skip_file(a:buf)
                                    return
                                endif
                            
    1   0.000116   0.000008     let run_checks = !a:auto_invoked || s:modemap.doAutoChecking(a:buf)
    1              0.000001     if run_checks
    1   0.496758   0.000029         call s:CacheErrors(a:buf, a:checker_names)
    1   0.000018   0.000011         call syntastic#util#setLastTick(a:buf)
    1              0.000002     elseif a:auto_invoked
                                    return
                                endif
                            
    1   0.000034   0.000005     let loclist = g:SyntasticLoclist.current(a:buf)
                            
    1              0.000002     if exists('*SyntasticCheckHook')
                                    call SyntasticCheckHook(loclist.getRaw())
                                endif
                            
                                " populate loclist and jump {{{3
    1   0.000016   0.000005     let do_jump = syntastic#util#var('auto_jump') + 0
    1              0.000001     if do_jump == 2
                                    let do_jump = loclist.getFirstError(1)
                                elseif do_jump == 3
                                    let do_jump = loclist.getFirstError()
                                elseif 0 > do_jump || do_jump > 3
                                    let do_jump = 0
                                endif
                            
    1   0.000012   0.000003     if syntastic#util#var('always_populate_loc_list') || do_jump
    1   0.000091   0.000007         call loclist.setloclist(1)
    1              0.000002         if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: jump')
                                        execute 'silent! lrewind ' . do_jump
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype ==# ''
                                            silent! filetype detect
                                        endif
                                    endif
    1              0.000001     endif
                                " }}}3
                            
    1   0.045440   0.000007     call s:notifiers.refresh(loclist)

FUNCTION  <SNR>179_getenv()
Called 1 time
Total time:   0.000732
 Self time:   0.000352

count  total (s)   self (s)
    1              0.000050 	let [s:cwd, s:winres] = [getcwd(), [winrestcmd(), &lines, winnr('$')]]
    1              0.000035 	let [s:crword, s:crnbword] = [expand('<cword>', 1), expand('<cWORD>', 1)]
    1              0.000033 	let [s:crgfile, s:crline] = [expand('<cfile>', 1), getline('.')]
    1              0.000028 	let [s:winmaxh, s:crcursor] = [min([s:mw_max, &lines]), getpos('.')]
    1   0.000441   0.000076 	let [s:crbufnr, s:crvisual] = [bufnr('%'), s:lastvisual()]
    1              0.000060 	let s:crfile = bufname('%') == '' ? '['.s:crbufnr.'*No Name]' : expand('%:p', 1)
    1              0.000026 	let s:crfpath = expand('%:p:h', 1)
    1   0.000054   0.000039 	let s:mrbs = ctrlp#mrufiles#bufs()

FUNCTION  <SNR>179_remarksigns()
Called 4 times
Total time:   0.000067
 Self time:   0.000035

count  total (s)   self (s)
    4   0.000064   0.000032 	if !s:dosigns() | retu | en
                            	for ic in range(1, len(s:lines))
                            		let line = s:ispath ? fnamemodify(s:lines[ic - 1], ':p') : s:lines[ic - 1]
                            		let key = s:dictindex(s:marked, line)
                            		if key > 0
                            			exe 'sign place' key 'line='.ic.' name=ctrlpmark buffer='.s:bufnr
                            		en
                            	endfo

FUNCTION  393()
Called 11 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
   11              0.000061   return len(self._sections)

FUNCTION  <SNR>117_update_untracked()
Called 223 times
Total time:   0.060195
 Self time:   0.049012

count  total (s)   self (s)
  223              0.007465   let file = expand("%:p")
  223              0.003278   if empty(file) || isdirectory(file)
                                return
                              endif
                            
  223              0.001200   let needs_update = 1
  669              0.003816   for vcs in keys(s:vcs_config)
  446              0.006507     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
                                endif
  446              0.003878     if has_key(s:vcs_config[vcs].untracked, file)
  221              0.000993       let needs_update = 0
  221   0.013025   0.004090       call airline#extensions#branch#update_untracked_config(file, vcs)
  221              0.000485     endif
  446              0.001032   endfor
                            
  223              0.000810   if !needs_update
  221              0.000654     return
                              endif
                            
    6              0.000035   for vcs in keys(s:vcs_config)
    4              0.000017     let config = s:vcs_config[vcs]
    4              0.000006     if g:airline#init#vim_async
                                  " Note that asynchronous update updates s:vcs_config only, and only
                                  " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                  " invalidated again before s:update_untracked is called, then we lose the
                                  " result of the previous call, i.e. the head string is not updated. It
                                  " doesn't happen often in practice, so we let it be.
    4   0.002386   0.000138       call airline#async#vim_vcs_untracked(config, file)
    4              0.000009     else
                                  " nvim async or vim without job-feature
                                  call airline#async#nvim_vcs_untracked(config, file, vcs)
                                endif
    4              0.000005   endfor

FUNCTION  <SNR>68_QuitPreHook()
Called 1 time
Total time:   0.002087
 Self time:   0.000337

count  total (s)   self (s)
    1   0.000329   0.000065     let buf = syntastic#util#fname2buf(a:fname)
    1   0.000159   0.000088     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: QuitPre, buffer ' . buf . ' = ' . string(a:fname))
                            
    1   0.000097   0.000019     if !syntastic#util#var('check_on_wq')
    1   0.000286   0.000034         call syntastic#util#setWids()
    1              0.000035         call add(s:_quit_pre, buf . '_' . getbufvar(buf, 'changetick') . '_' . w:syntastic_wid)
    1              0.000003     endif
                            
    1              0.000014     if !empty(get(w:, 'syntastic_loclist_set', []))
    1   0.001149   0.000064         call SyntasticLoclistHide()
    1              0.000005     endif

FUNCTION  <SNR>179_walker()
Called 14 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
   14              0.000117 	retu a:d >= 0 ? a:p < a:m ? a:p + a:d : 0 : a:p > 0 ? a:p + a:d : a:m

FUNCTION  <SNR>156_on_stdout_vim()
Called 9 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    9              0.000046   call add(self.stdoutbuffer, a:data)

FUNCTION  <SNR>103_multi_string()
Called 147 times
Total time:   0.014488
 Self time:   0.010441

count  total (s)   self (s)
                                " 2x performance for general case
  147              0.001965     if a:line !~# '[''"]'
  113              0.000546         return [a:in_string, 0, 0, '', '']
                                endif
                            
   34   0.002787   0.000431     let string_match = s:matchstrpos(a:line, a:first_re)
   34              0.000175     if string_match[1] == -1
                                    return [a:in_string, 0, 0, '', '']
                                endif
                            
                                " Anything before first match?
   34              0.000100     if string_match[1] >= 1
   28              0.000186         let before_first = a:line[:(string_match[1] - 1)]
   28              0.000038     else
    6              0.000023         let before_first = ''
    6              0.000010     endif
                            
   34              0.000129     let in_string = a:in_string
   34              0.000112     let next_re = ''
   34              0.000114     let line_slice = a:line
   34              0.000089     let found_ends = 0
   99              0.000358     while string_match[1] != -1
   72              0.000133         if in_string
   36              0.000075             let in_string = 0
   36              0.000087             let found_ends += 1
   36              0.000095             let next_re = s:string_start_re
   36              0.000045         else
   36              0.000077             let in_string = 1
   36              0.000603             let quotes = string_match[0][matchend(string_match[0], s:string_prefix_re):]
   36              0.000154             let next_re = '\\\@<!' . quotes
   36              0.000043         endif
                            
   72              0.000365         let line_slice = line_slice[(string_match[2]):]
   72              0.000221         if empty(line_slice)
    7              0.000012             break
                                    endif
   65   0.002283   0.000592         let string_match = s:matchstrpos(line_slice, next_re)
   65              0.000108     endwhile
                            
   34              0.000064     if in_string
                                    " Check if in single quoted string and line continues
    3              0.000048         let single_quoted = quotes =~# '^[''"]$'
    3              0.000015         if single_quoted && line_slice !~# s:line_cont_re
                                        return [0, single_quoted, (found_ends >= 1), '', before_first]
                                    else
    3              0.000027             return [1, single_quoted, (found_ends >= 1), next_re, before_first]
                                    endif
                                else
   31              0.000145         return [0, 0, (found_ends >= 2), '', before_first]
                                endif

FUNCTION  gitgutter#hunk#set_hunks()
Called 2 times
Total time:   0.000146
 Self time:   0.000051

count  total (s)   self (s)
    2   0.000066   0.000019   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    2   0.000077   0.000029   call s:reset_summary(a:bufnr)

FUNCTION  <SNR>63__compare_error_items_by_columns()
Called 14 times
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
   14              0.000018     if a:a['bufnr'] != a:b['bufnr']
                                    " group by file
                                    return a:a['bufnr'] - a:b['bufnr']
                                elseif a:a['lnum'] != a:b['lnum']
                                    " sort by line
                                    return a:a['lnum'] - a:b['lnum']
                                elseif a:a['scol'] != a:b['scol']
                                    " sort by screen column
   14              0.000024         return a:a['scol'] - a:b['scol']
                                elseif a:a['type'] !=? a:b['type']
                                    " errors take precedence over warnings
                                    return a:a['type'] ==? 'E' ? -1 : 1
                                else
                                    return 0
                                endif

FUNCTION  airline#builder#new()
Called 49 times
Total time:   0.002365
 Self time:   0.002365

count  total (s)   self (s)
   49              0.000695   let builder = copy(s:prototype)
   49              0.000250   let builder._context = a:context
   49              0.000155   let builder._sections = []
                            
   49              0.001016   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
   49              0.000128   return builder

FUNCTION  <SNR>138_GetTagInfo()
Called 1 time
Total time:   0.000135
 Self time:   0.000078

count  total (s)   self (s)
    1   0.000056   0.000008     let fileinfo = tagbar#state#get_current_file(0)
                            
    1              0.000003     if empty(fileinfo)
                                    return {}
                                endif
                            
                                " Don't do anything in empty and comment lines
    1   0.000041   0.000033     let curline = getbufline(bufnr(s:TagbarBufName()), a:linenr)[0]
    1              0.000006     if curline =~ '^\s*$' || curline[0] == '"'
                                    return {}
                                endif
                            
                                " Check if there is a tag on the current line
    1              0.000003     if !has_key(fileinfo.tline, a:linenr)
                                    return {}
                                endif
                            
    1              0.000003     let taginfo = fileinfo.tline[a:linenr]
                            
                                " Check if the current tag is not a pseudo-tag
    1   0.000012   0.000011     if a:ignorepseudo && taginfo.isPseudoTag()
                                    return {}
                                endif
                            
    1              0.000001     return taginfo

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    1   0.771018   0.000466  <SNR>179_AcceptSelection()
    1   0.770131   0.000654  ctrlp#acceptfile()
    1   0.752368   0.001478  <SNR>179_openfile()
    5   0.545901   0.000506  <SNR>68_BufEnterHook()
    1   0.542826   0.000210  <SNR>68_UpdateErrors()
    1   0.496729   0.000336  <SNR>68_CacheErrors()
    2   0.495039   0.000031  281()
    2   0.494812   0.000239  280()
    2   0.491558   0.001180  SyntasticMake()
    2   0.490281   0.000291  syntastic#util#system()
   56   0.463469   0.048015  394()
    1   0.444439   0.001058  SyntaxCheckers_python_flake8_GetLocList()
 2855   0.406584   0.172355  airline#highlighter#get_highlight()
  606   0.393005   0.031663  <SNR>131_exec_separator()
    7   0.332918   0.141355  <SNR>179_BuildPrompt()
  226   0.321796   0.056612  airline#check_mode()
  195   0.320696   0.012751  <SNR>135_get_transitioned_seperator()
  390   0.307945   0.009189  airline#highlighter#add_separator()
  156   0.307651   0.003331  <SNR>135_get_seperator()
 1309   0.306375   0.091363  airline#highlighter#exec()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 5710              0.204049  <SNR>131_get_syn()
 2855   0.406584   0.172355  airline#highlighter#get_highlight()
    7   0.332918   0.141355  <SNR>179_BuildPrompt()
  283              0.141154  WebDevIconsGetFileTypeSymbol()
 1309   0.306375   0.091363  airline#highlighter#exec()
  446   0.079397   0.079305  313()
    3   0.110411   0.075537  <SNR>103_cache()
    8   0.076389   0.074918  <SNR>138_HighlightTag()
  206              0.066860  <SNR>91_Highlight_Matching_Pair()
  223   0.075105   0.063769  airline#extensions#whitespace#check()
  223   0.103804   0.057219  airline#extensions#hunks#get_hunks()
  226   0.321796   0.056612  airline#check_mode()
  223   0.060195   0.049012  <SNR>117_update_untracked()
   56   0.463469   0.048015  394()
 1561              0.046090  airline#util#append()
  192   0.073671   0.044216  <SNR>159_OnCursorMovedNormalMode()
  446   0.158061   0.035361  airline#extensions#syntastic#get()
  223   0.188253   0.033256  <SNR>117_update_branch()
    3   0.033183   0.033052  ctrlp#utils#writecache()
 1309              0.032200  <SNR>131_CheckDefined()

